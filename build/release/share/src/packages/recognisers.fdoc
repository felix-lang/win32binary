@tangler recognisers.flx = share/lib/std/strings/recognisers.flx

@title String Matching recognisers
@h1 Recognisers
A recogniser is a component which tries to match the prefix of a string.
If it succeeds it returns the position of the first character not matched.

@h2 Buffer type
Recognisers work on an array of chars in memory. We use a Google
StringPiece to represent it. 

@tangle recognisers.flx
include "std/control/chips";
include "std/strings/grammars";
class Recognisers
{

struct Buffer
{
  sp: varray[char];
  pos: int;

  fun atend => self.pos >= self.sp.len.int;

  fun get => 
    if self.atend then char "" 
    else (self.sp) . (self.pos)
  ;

  proc next { 
    if not self*.atend do
      pre_incr self.pos;
    done
  }

  fun advanced =>
    if self.atend then self
    else Buffer (self.sp, self.pos + 1)
  ;
}


ctor Buffer (p:varray[char]) =>
  Buffer (p,0)
;

ctor Buffer (p:string) =>
  Buffer (p.varray[char],0)
;

ctor Buffer (p: &string) =>
  Buffer (*p)
;

instance Str[Buffer] {
  fun str (b:Buffer) => "@"+b.pos.str;
}

// hack, ignore underlying data.. FIXME
instance Eq[Buffer] {
  fun == (a:Buffer, b:Buffer) => a.pos == b.pos;
}

typedef recog_t = BaseChips::iochip_t[Buffer,Buffer];
// rendering lazy terms to actual recognizer

@h2 A string matcher.

@tangle recognisers.flx
chip match_string (s:string)
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
nextmatch:>
  var b = read io.inp;
  //println$ "Match " + s + " at " + b.str;
  for i in 0..< s.len.int do 
    if s.[i] != b.get goto nextmatch;
    b&.next;
  done
  //println$ "Matched " + s + " to " + b.str;
  write (io.out, b);
  goto nextmatch;  
}

@h2 Whitespace matcher.
@tangle recognisers.flx
chip match_white 
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
  while true do
    var b = read io.inp;
    while not b.atend and b.get <= char ' ' perform b&.next;
    write (io.out,b);
  done
}

@h2 regex matcher.

@tangle recognisers.flx
chip match_regex (r:RE2)
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
  while true do
    var b = read io.inp;
//println$ "Match regex " + r.str;
    var matched = varray[StringPiece] (1uz,StringPiece());
    var result = Match(r,StringPiece(b.sp),b.pos,ANCHOR_START,matched.stl_begin,1);
//println$ "Match result " + result.str;
    if result do
//println$ "Matched OK, match len = " + matched.0.len.str;
      var b2 = Buffer (b.sp,b.pos+matched.0.len.int);
//println$ "Writing buffer = " + b2.str;
      write(io.out,b2);
    done
  done
}

@h2 Identifier matcher.
For C like identifiers.

@tangle recognisers.flx
device cident_matcher = match_regex (RE2 "[A-Za-z][A-Za-z0-9_]*");

@h2 Integer matcher.
For plain identifiers.

@tangle recognisers.flx
device decimal_integer_matcher = match_regex (RE2 "[0-9]+");

@h2 String Literal matcher.
One shot. Simple, matches single or double quoted
string not spanning lines, with no escape codes, 
@tangle recognisers.flx
chip match_string_literal 
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
restart:>
  var b = read io.inp;
  if b.atend goto restart; // end of data
  var leadin = b.get;
//println$ "string literal matcher got char " + leadin.str;
  if not (leadin in (char '"', char "'")) goto restart;
//println$ "Got valid string start .. ";
  b&.next; 
  if b.atend goto restart;
  var ch = b.get;
  while ch != leadin do
    b&.next;
    if b.atend goto restart;
    ch = b.get;
    if ch == char "\n" goto restart; // end of line
  done
  b&.next;
  io.out `write` b;  
  goto restart;
}

chip match_string_literal_backquote
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
restart:>
  var b = read io.inp;
  if b.atend goto restart; // end of data
  var leadin = b.get;
//println$ "string literal matcher got char " + leadin.str;
  if leadin != char '`' goto restart;
//println$ "Got valid string start .. ";
  b&.next; 
  if b.atend goto restart;
  var ch = b.get;
  while ch != leadin do
    b&.next;
    if b.atend goto restart;
    ch = b.get;
    if ch == char "\n" goto restart; // end of line
  done
  b&.next;
  io.out `write` b;  
  goto restart;
}

@h1 Lazy Syntactic form
@tangle recognisers.flx
// this is a function, so it cannot construct pipeline
// chips, because they actually spawn the components internally
// and functions can't do service calls.
//
// So instead we just return a function 1->recog_t which does the
// job on invocation.
open Grammars;

typedef ntdef_t = string * recog_t;

fun find (v:varray[ntdef_t]) (nt:string) : size = 
{
  for i in 0uz ..< v.len do
    if v.i.0 == nt return i;
  done
  assert false;
}


fun render_prod 
  (lib:gramlib_t,v:varray[ntdef_t]) 
  (p:prod_t) 
: 1 -> recog_t =>
  match p with
  | Strng s => { match_string s }
  | Epsilon => { BaseChips::epsilon[Buffer] }
  | Seq ps => { BaseChips::pipeline_list (
      map (fun (p:prod_t) => #(render_prod (lib,v) p)) ps) }
  | Alt ps =>  { BaseChips::tryall_list (
      map (fun (p:prod_t) => #(render_prod (lib,v) p)) ps) }
  | Nonterminal nt => 
     { 
       var idx : size = find v nt;
       var pslot : &ntdef_t = -(v.stl_begin + idx); 
       var pchip : &recog_t = pslot . 1;
       return BaseChips::deref_first_read pchip;
     }
  endmatch
;

chip make_recogniser_from_grammar
  connector io
    pin inp: %<grammar_t
    pin out: %>recog_t
{

  while true do
    // read in the grammar
    var start, lib = read io.inp;

    // calculate the transitive closure of nonterminals
    // from the start symbol
    var cl = closure (start,lib);

    // allocate a varray with a slot for each nonterminal
    var n = cl.len;
    var v = varray[string * recog_t] n;

    // populate the varray with the terminal names and a dummy chip
    for nt in cl call // initialise array
      push_back (v,(nt,BaseChips::epsilon[Buffer]))
    ;

    // now assign the real recognisers to the array
    var index = 0uz;
    for nt in cl do
      match find lib nt with
      | None => assert false;
      | Some prod =>
        // get wrapped recogniser
        var xprod_closure = render_prod (lib, v) prod;

        // undo the wrappingt
        var entry = #xprod_closure;

        // address of the slot
        var pentry : &recog_t = (-(v.stl_begin+index)).1;

        // overwrite dummy value
        pentry <- entry;
      endmatch;
      ++index;
    done
    write (io.out, (v.(find v start).1));
  done
}

} // Recognisers

