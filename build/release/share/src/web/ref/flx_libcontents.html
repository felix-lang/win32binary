1.1.12 fdoc2html initialisation
1.1.12 flx2html initialisation
1.1.12 cpp2html initialisation
1.1.12 cpp2html initialisation
ocaml2html initialisation
Py2html initialisation
<html><body>
<h1>Felix Library Contents</h1>
<hr/><a href="/share/lib/std/__init__.flx">__init__.flx</a>
<hr/><a href="/share/lib/std/algebraic.flx">algebraic.flx</a>

<pre>0004:  <a href="/share/lib/std/algebraic.flx#0004">class FloatAddgrp[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Additive symmetric float-approximate group, symbol +.
 Note: associativity is not assumed.
</p></div>
<pre>0006:    <a href="/share/lib/std/algebraic.flx#0006">virtual fun zero: unit -> t</a></pre>
<pre>0020:    <a href="/share/lib/std/algebraic.flx#0020">fun add(x:t,y:t)</a></pre>
<pre>0021:    <a href="/share/lib/std/algebraic.flx#0021">fun plus(x:t)</a></pre>
<pre>0022:    <a href="/share/lib/std/algebraic.flx#0022">fun sub(x:t,y:t)</a></pre>
<pre>0023:    <a href="/share/lib/std/algebraic.flx#0023">fun neg(x:t)</a></pre>
<pre>0024:    <a href="/share/lib/std/algebraic.flx#0024">proc pluseq(px:&t, y:t)</a></pre>
<pre>0025:    <a href="/share/lib/std/algebraic.flx#0025">proc  minuseq(px:&t, y:t)</a></pre>

<pre>0030:  <a href="/share/lib/std/algebraic.flx#0030">class Addgrp[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Additive symmetric group, symbol +.
</p></div>

<pre>0038:  <a href="/share/lib/std/algebraic.flx#0038">class FloatMultSemi1[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Multiplicative symmetric float-approximate semi group with unit symbol *.
 Note: associativity is not assumed.
</p></div>
<pre>0040:    <a href="/share/lib/std/algebraic.flx#0040">proc muleq(px:&t, y:t)</a></pre>
<pre>0041:    <a href="/share/lib/std/algebraic.flx#0041">fun mul(x:t, y:t)</a></pre>
<pre>0042:    <a href="/share/lib/std/algebraic.flx#0042">fun sqr(x:t)</a></pre>
<pre>0043:    <a href="/share/lib/std/algebraic.flx#0043">fun cube(x:t)</a></pre>
<pre>0044:    <a href="/share/lib/std/algebraic.flx#0044">virtual fun one: unit -> t</a></pre>

<pre>0052:  <a href="/share/lib/std/algebraic.flx#0052">class MultSemi1[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Multiplicative semi group with unit.
</p></div>

<pre>0059:  <a href="/share/lib/std/algebraic.flx#0059">class FloatRing[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate ring.
</p></div>

<pre>0065:  <a href="/share/lib/std/algebraic.flx#0065">class Ring[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Ring.
</p></div>

<pre>0072:  <a href="/share/lib/std/algebraic.flx#0072">class FloatDring[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate division ring.
</p></div>
<pre>0079:    <a href="/share/lib/std/algebraic.flx#0079">fun div(x:t, y:t)</a></pre>
<pre>0080:    <a href="/share/lib/std/algebraic.flx#0080">fun mod(x:t, y:t)</a></pre>
<pre>0081:    <a href="/share/lib/std/algebraic.flx#0081">fun recip (x:t)</a></pre>
<pre>0083:    <a href="/share/lib/std/algebraic.flx#0083">proc diveq(px:&t, y:t)</a></pre>
<pre>0084:    <a href="/share/lib/std/algebraic.flx#0084">proc modeq(px:&t, y:t)</a></pre>

<pre>0088:  <a href="/share/lib/std/algebraic.flx#0088">class Dring[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Division ring.
</p></div>

<pre>0095:  <a href="/share/lib/std/algebraic.flx#0095">class Bits[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Bitwise operators.
</p></div>
<pre>0104:    <a href="/share/lib/std/algebraic.flx#0104">fun bxor(x:t,y:t)</a></pre>
<pre>0105:    <a href="/share/lib/std/algebraic.flx#0105">fun bor(x:t,y:t)</a></pre>
<pre>0106:    <a href="/share/lib/std/algebraic.flx#0106">fun band(x:t,y:t)</a></pre>
<pre>0107:    <a href="/share/lib/std/algebraic.flx#0107">fun bnot(x:t)</a></pre>

<pre>0112:  <a href="/share/lib/std/algebraic.flx#0112">class Integer[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Integers.
</p></div>
<pre>0119:    <a href="/share/lib/std/algebraic.flx#0119">fun shl(x:t,y:t)</a></pre>
<pre>0120:    <a href="/share/lib/std/algebraic.flx#0120">fun shr(x:t,y:t)</a></pre>

<pre>0124:  <a href="/share/lib/std/algebraic.flx#0124">class Signed_integer[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Signed Integers.
</p></div>
<pre>0126:    <a href="/share/lib/std/algebraic.flx#0126">virtual fun sgn: t -> int</a></pre>
<pre>0127:    <a href="/share/lib/std/algebraic.flx#0127">virtual fun abs: t -> t</a></pre>

<pre>0131:  <a href="/share/lib/std/algebraic.flx#0131">class Unsigned_integer[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Unsigned Integers.
</p></div>

<pre>0137:  <a href="/share/lib/std/algebraic.flx#0137">class Trig[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate trigonometric functions.
</p></div>
<pre>0146:    <a href="/share/lib/std/algebraic.flx#0146">virtual fun sin: t -> t</a></pre>
<pre>0147:    <a href="/share/lib/std/algebraic.flx#0147">virtual fun cos: t -> t</a></pre>
<pre>0148:    <a href="/share/lib/std/algebraic.flx#0148">virtual fun tan (x:t)</a></pre>
<pre>0150:    <a href="/share/lib/std/algebraic.flx#0150">virtual fun sec (x:t)</a></pre>
<pre>0151:    <a href="/share/lib/std/algebraic.flx#0151">virtual fun csc (x:t)</a></pre>
<pre>0152:    <a href="/share/lib/std/algebraic.flx#0152">virtual fun cot (x:t)</a></pre>
<pre>0154:    <a href="/share/lib/std/algebraic.flx#0154">virtual fun asin: t -> t</a></pre>
<pre>0155:    <a href="/share/lib/std/algebraic.flx#0155">virtual fun acos: t -> t</a></pre>
<pre>0156:    <a href="/share/lib/std/algebraic.flx#0156">virtual fun atan: t -> t</a></pre>
<pre>0158:    <a href="/share/lib/std/algebraic.flx#0158">virtual fun asec (x:t)</a></pre>
<pre>0159:    <a href="/share/lib/std/algebraic.flx#0159">virtual fun acsc (x:t)</a></pre>
<pre>0160:    <a href="/share/lib/std/algebraic.flx#0160">virtual fun acot (x:t)</a></pre>
<pre>0164:    <a href="/share/lib/std/algebraic.flx#0164">virtual fun sinh: t -> t</a></pre>
<pre>0165:    <a href="/share/lib/std/algebraic.flx#0165">virtual fun cosh: t -> t</a></pre>
<pre>0166:    <a href="/share/lib/std/algebraic.flx#0166">virtual fun tanh (x:t)</a></pre>
<pre>0168:    <a href="/share/lib/std/algebraic.flx#0168">virtual fun sech (x:t)</a></pre>
<pre>0169:    <a href="/share/lib/std/algebraic.flx#0169">virtual fun csch (x:t)</a></pre>
<pre>0170:    <a href="/share/lib/std/algebraic.flx#0170">virtual fun coth (x:t)</a></pre>
<pre>0172:    <a href="/share/lib/std/algebraic.flx#0172">virtual fun asinh: t -> t</a></pre>
<pre>0173:    <a href="/share/lib/std/algebraic.flx#0173">virtual fun acosh: t -> t</a></pre>
<pre>0174:    <a href="/share/lib/std/algebraic.flx#0174">virtual fun atanh: t -> t</a></pre>
<pre>0176:    <a href="/share/lib/std/algebraic.flx#0176">virtual fun asech (x:t)</a></pre>
<pre>0177:    <a href="/share/lib/std/algebraic.flx#0177">virtual fun acsch (x:t)</a></pre>
<pre>0178:    <a href="/share/lib/std/algebraic.flx#0178">virtual fun acoth (x:t)</a></pre>
<pre>0181:    <a href="/share/lib/std/algebraic.flx#0181">virtual fun exp: t -> t</a></pre>
<pre>0182:    <a href="/share/lib/std/algebraic.flx#0182">virtual fun log: t -> t</a></pre>
<pre>0183:    <a href="/share/lib/std/algebraic.flx#0183">virtual fun pow: t * t -> t</a></pre>

<pre>0187:  <a href="/share/lib/std/algebraic.flx#0187">class Special[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Finance and Statistics.
</p></div>
<pre>0188:    <a href="/share/lib/std/algebraic.flx#0188">virtual fun erf: t -> t</a></pre>
<pre>0189:    <a href="/share/lib/std/algebraic.flx#0189">virtual fun erfc: t -> t</a></pre>

<pre>0193:  <a href="/share/lib/std/algebraic.flx#0193">class Real[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate real numbers.
</p></div>
<pre>0197:    <a href="/share/lib/std/algebraic.flx#0197">virtual fun embed: int -> t</a></pre>
<pre>0199:    <a href="/share/lib/std/algebraic.flx#0199">virtual fun log10: t -> t</a></pre>
<pre>0200:    <a href="/share/lib/std/algebraic.flx#0200">virtual fun abs: t -> t</a></pre>
<pre>0201:    <a href="/share/lib/std/algebraic.flx#0201">virtual fun sqrt: t -> t</a></pre>
<pre>0202:    <a href="/share/lib/std/algebraic.flx#0202">virtual fun ceil: t -> t</a></pre>
<pre>0203:    <a href="/share/lib/std/algebraic.flx#0203">virtual fun floor: t -> t</a></pre>
<pre>0204:    <a href="/share/lib/std/algebraic.flx#0204">virtual fun trunc: t -> t</a></pre>

<pre>0208:  <a href="/share/lib/std/algebraic.flx#0208">class Complex[t,r]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate Complex.
</p></div>
<pre>0212:    <a href="/share/lib/std/algebraic.flx#0212">virtual fun real: t -> r</a></pre>
<pre>0213:    <a href="/share/lib/std/algebraic.flx#0213">virtual fun imag: t -> r</a></pre>
<pre>0214:    <a href="/share/lib/std/algebraic.flx#0214">virtual fun abs: t -> r</a></pre>
<pre>0215:    <a href="/share/lib/std/algebraic.flx#0215">virtual fun arg: t -> r</a></pre>
<hr/><a href="/share/lib/std/c_hack.flx">c_hack.flx</a>

<pre>0006:  <a href="/share/lib/std/c_hack.flx#0006">class C_hack</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> This class provides access to raw C/C++ encodings.
 Incorrect typing is likely to pass by Felix and
 be trapped by the C/C++ compiler. Incorrect management
 of storage can lead to corruption. The use of the
 C_hack class is necessary for interfacing.
</p></div>
<pre>0012:    <a href="/share/lib/std/c_hack.flx#0012">type va_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C void type. Incomplete, can't be instantiated.
 Standard variable argument list pointer type.
</p></div>
<pre>0016:    <a href="/share/lib/std/c_hack.flx#0016">type __builtin_va_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> GCC specific valist thingo: it will
 be optimised away if not used (eg on MSVC).
</p></div>
<pre>0021:    <a href="/share/lib/std/c_hack.flx#0021">proc ignore[t]:t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Throw away result of a function call:
 only useful for C functions that are mainly
 called for side effects.
</p></div>
<pre>0024:    <a href="/share/lib/std/c_hack.flx#0024">fun cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C style cast.
</p></div>
<pre>0027:    <a href="/share/lib/std/c_hack.flx#0027">fun static_cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ static cast.
</p></div>
<pre>0030:    <a href="/share/lib/std/c_hack.flx#0030">fun dynamic_cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ dynamic cast.
</p></div>
<pre>0033:    <a href="/share/lib/std/c_hack.flx#0033">fun const_cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ const cast.
</p></div>
<pre>0036:    <a href="/share/lib/std/c_hack.flx#0036">fun reinterpret_cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ reinterpret cast.
</p></div>
<pre>0041:    <a href="/share/lib/std/c_hack.flx#0041">fun reinterpret[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Felix reinterpret cast.
 More powerful than C++ reinterpret cast.
 Allows casting an rvalue to an lvalue.
</p></div>
<pre>0047:    <a href="/share/lib/std/c_hack.flx#0047">fun eq[T]: gcptr[T] * gcptr[T] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Equality for gcptr
</p></div>
<pre>0055:    <a href="/share/lib/std/c_hack.flx#0055">fun isNULL[t]: &t -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Special lvalue deref for gcptr
 Special NULL check for Felix pointers.
 Should never succeed.
</p></div>
<pre>0059:    <a href="/share/lib/std/c_hack.flx#0059">fun isNULL[t]: +t -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Special NULL check for carray.
 Should never succeed.
</p></div>
<pre>0063:    <a href="/share/lib/std/c_hack.flx#0063">fun isNULL[t]: gcptr[t] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Special NULL check for gcptr.
 Might succeed.
</p></div>
<pre>0074:    <a href="/share/lib/std/c_hack.flx#0074">fun dflt[t]:1->t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Polymorphic null pointer constant
 Values of this type should not exist.
 This value is provided for checking.
 C++ default value for a type T.
 Workaround for g++ 3.2.2 parsing bug,
 it can parse T() as a default ctor call,
 but screws up on (T())
</p></div>
<pre>0087:    <a href="/share/lib/std/c_hack.flx#0087">gen raw_malloc: !ints -> address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Raw unchecked malloc.
 Used typed malloc in carray if possible.
</p></div>
<pre>0091:    <a href="/share/lib/std/c_hack.flx#0091">gen malloc: !ints -> address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Malloc with out of memory check.
 Throws c"out of memory" if out of memory.
</p></div>
<pre>0094:    <a href="/share/lib/std/c_hack.flx#0094">proc free: address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Raw unchecked free.
</p></div>
<pre>0097:    <a href="/share/lib/std/c_hack.flx#0097">proc destroy[T] : &T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke C++ destructor
</p></div>
<hr/><a href="/share/lib/std/c_headers.flx">c_headers.flx</a>

<pre>0004:  <a href="/share/lib/std/c_headers.flx#0004">class C89_headers</a></pre>

<pre>0024:  <a href="/share/lib/std/c_headers.flx#0024">class C95_headers</a></pre>

<pre>0033:  <a href="/share/lib/std/c_headers.flx#0033">class C99_headers</a></pre>
<hr/><a href="/share/lib/std/carray.flx">carray.flx</a>

<pre>0002:  <a href="/share/lib/std/carray.flx#0002">open class Carray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> A carray[T] = +T is an incrementable, non-NULL, pointer.
</p></div>
<pre>0008:    <a href="/share/lib/std/carray.flx#0008">type carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The carray type.
</p></div>
<pre>0011:    <a href="/share/lib/std/carray.flx#0011">typedef fun +(T:TYPE) : TYPE</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Define prefix + notation.
</p></div>
<pre>0020:    <a href="/share/lib/std/carray.flx#0020">fun n"&." [T]: carray[T] * !ints -> &T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Unsafe conversion of Felix pointer to carray.
 Demote carray to Felix pointer (safe unless off the end).
 a &. i returns pointer to i'th component of an array.
</p></div>
<pre>0023:    <a href="/share/lib/std/carray.flx#0023">ctor[T] carray[T] : &T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Unsafe conversion of Felix pointer to carray.
</p></div>
<pre>0026:    <a href="/share/lib/std/carray.flx#0026">ctor[T,N] carray[T]: &array[T,N]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get a carray from a Felix array object.
</p></div>
<pre>0030:    <a href="/share/lib/std/carray.flx#0030">fun array_alloc[T]: !ints -> carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Allocate a C array on the C heap (malloc).
 Unsafe: Not tracked by GC.
</p></div>
<pre>0034:    <a href="/share/lib/std/carray.flx#0034">fun array_calloc[T]: !ints -> carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Allocate a C array on the C heap with 0 fill (cmalloc).
 Unsafe: Not tracked by GC.
</p></div>
<pre>0038:    <a href="/share/lib/std/carray.flx#0038">proc free[T]: carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Free a C array (free).
 Must point to C heap allocated storage. Unsafe.
</p></div>
<pre>0041:    <a href="/share/lib/std/carray.flx#0041">fun subscript[T]: carray[T] * !ints -> T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Lvalue reference to element by index position. Unsafe.
</p></div>
<pre>0047:    <a href="/share/lib/std/carray.flx#0047">fun get[T]: carray[T] * !ints -> T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Lvalue reference to element by pointer.
 Functional get by index.
</p></div>
<pre>0051:    <a href="/share/lib/std/carray.flx#0051">fun apply [T,I in ints] (i:I, x:carray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get by index using application.
 i x = x . i = get (x,i)
</p></div>
<pre>0054:    <a href="/share/lib/std/carray.flx#0054">proc set[T] : carray[T] * !ints * T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Store value in array at index position.
</p></div>
<pre>0057:    <a href="/share/lib/std/carray.flx#0057">fun stl_begin[T,N]: carray[array[T,N]] -> carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get carray of an array.
</p></div>
<pre>0070:    <a href="/share/lib/std/carray.flx#0070">proc pre_incr[T]: &carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Advance carray to next element.
 Backup carray to previous element.
 Calculate the offset in elements between
 two overlapping carrays.
 Mutable pre-increment ++p.
</p></div>
<pre>0073:    <a href="/share/lib/std/carray.flx#0073">proc post_incr[T]: &carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutable post-increment p++.
</p></div>
<pre>0076:    <a href="/share/lib/std/carray.flx#0076">proc pre_decr[T]: &carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutable pre-decarement --p.
</p></div>
<pre>0079:    <a href="/share/lib/std/carray.flx#0079">proc post_decr[T]: &carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutable post-decarement p--.
</p></div>
<pre>0102:    <a href="/share/lib/std/carray.flx#0102">fun array_of[T,N]: carray[T] -> &array[T,N]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutable advance by offset amount.
 Mutable backup by offset amount.
 Pointer equality.
 Pointer total ordering.
 Convert C array to Felix array.
</p></div>
<pre>0106:    <a href="/share/lib/std/carray.flx#0106">proc memcpy: address * address * size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fast byte-wise copy from address to address.
 WHY IS THIS HERE?
</p></div>
<pre>0112:    <a href="/share/lib/std/carray.flx#0112">fun memcmp: address * address * size -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fast bytewise comparison from address to address.
 WHY IS THIS HERE?
</p></div>
<pre>0120:    <a href="/share/lib/std/carray.flx#0120">proc strcpy: carray[char] * carray[char]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C strcpy.
</p></div>
<pre>0123:    <a href="/share/lib/std/carray.flx#0123">proc strncpy: carray[char] * carray[char] * !ints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C strncpy.
</p></div>
<pre>0126:    <a href="/share/lib/std/carray.flx#0126">fun strlen: carray[char] ->size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C strlen: NTBS length.
</p></div>
<pre>0129:    <a href="/share/lib/std/carray.flx#0129">gen strdup(s:carray[char])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Traditional NTBS strdup.
</p></div>
<hr/><a href="/share/lib/std/categ.flx">categ.flx</a>

<pre>0002:  <a href="/share/lib/std/categ.flx#0002">open class Categ</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Categorical Operators
</p></div>
<pre>0013:    <a href="/share/lib/std/categ.flx#0013">fun curry[u,v,r] (f:u*v->r) : u -> v -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> change star into arrow (2 components)
</p></div>
<pre>0016:    <a href="/share/lib/std/categ.flx#0016">fun curry[u,v,w,r] (f:u*v*w->r) : u -> v -> w -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> change star into arrow (3 components)
</p></div>
<pre>0019:    <a href="/share/lib/std/categ.flx#0019">fun uncurry2[u,v,r] (f:u->v->r) : u * v -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> change arrow into star (arity 2)
</p></div>
<pre>0022:    <a href="/share/lib/std/categ.flx#0022">fun uncurry3[u,v,w,r] (f:u->v->w->r) : u * v * w -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> change arrow into star (arity 3)
</p></div>
<pre>0025:    <a href="/share/lib/std/categ.flx#0025">fun twist[u,v,r] (f:u*v->r) : v * u -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> argument order permutation (2 components)
</p></div>
<pre>0028:    <a href="/share/lib/std/categ.flx#0028">fun proj1[u1,u2,r1,r2] (f:u1*u2->r1*r2) : u1 * u2 -> r1</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> projection 1 (2 components)
</p></div>
<pre>0032:    <a href="/share/lib/std/categ.flx#0032">fun proj2[u1,u2,r1,r2] (f:u1*u2->r1*r2) : u1 * u2 -> r2</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> projection 2 (2 components)
</p></div>
<pre>0037:    <a href="/share/lib/std/categ.flx#0037">fun ravel[u1,u2,r1,r2] (f1:u1->r1,f2:u2->r2) : u1 * u2 -> r1 * r2</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> parallel composition
</p></div>
<pre>0041:    <a href="/share/lib/std/categ.flx#0041">fun compose[u,v,w] (f:v->w, g:u->v) : u -> w</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> series composition (2 functions)
</p></div>
<pre>0051:    <a href="/share/lib/std/categ.flx#0051">fun rev_compose[u,v,w] (f:u->v, g:v->w) : u -> w</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> series reverse composition (2 functions)
</p></div>
<hr/><a href="/share/lib/std/codec/__init__.flx">codec/__init__.flx</a>
<hr/><a href="/share/lib/std/codec/base64.flx">codec/base64.flx</a>

<pre>0004:  <a href="/share/lib/std/codec/base64.flx#0004">class Base64</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Base64 encode/decode functions.
 http://en.wikipedia.org/wiki/Base64
</p></div>
<pre>0013:    <a href="/share/lib/std/codec/base64.flx#0013">gen make_string: size*char->string</a></pre>
<pre>0029:    <a href="/share/lib/std/codec/base64.flx#0029">fun encode (inp:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Returns base 64 encoding of supplied string inp.
</p></div>
<pre>0031:    <a href="/share/lib/std/codec/base64.flx#0031">fun encode (inp:string, iOff:int, iLen:int) : string</a></pre>
<pre>0066:    <a href="/share/lib/std/codec/base64.flx#0066">fun wrap (b64_str:string,ll:uint) : string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wraps encoded string after ll chars, no newline on last line.
</p></div>
<pre>0083:    <a href="/share/lib/std/codec/base64.flx#0083">fun decode(enc_str:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Decodes supplied base 64 encoded string.
</p></div>
<hr/><a href="/share/lib/std/codec/csv.flx">codec/csv.flx</a>

<pre>0003:  <a href="/share/lib/std/codec/csv.flx#0003">class Csv</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Comma Separated Values (CSV) reader
 Splits a string like 1,2,"hell" up into three strings.
</p></div>
<pre>0008:    <a href="/share/lib/std/codec/csv.flx#0008">proc get_csv_value(s:string, i:&int,res:&string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch a value string res from position i of string s.
 Update i past the comma ready to fetch another value.
</p></div>
<pre>0010:    <a href="/share/lib/std/codec/csv.flx#0010">proc add(j:int)</a></pre>
<pre>0013:    <a href="/share/lib/std/codec/csv.flx#0013">fun eq(a:state_t, b:state_t)</a></pre>
<pre>0044:    <a href="/share/lib/std/codec/csv.flx#0044">fun get_csv_values(s:string): list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch all the values in a CSV string
 and return them as list.
</p></div>
<hr/><a href="/share/lib/std/codec/uri_codec.flx">codec/uri_codec.flx</a>

<pre>0015:  <a href="/share/lib/std/codec/uri_codec.flx#0015">class URICodec</a></pre>
<pre>0058:    <a href="/share/lib/std/codec/uri_codec.flx#0058">gen uri_encode: string -> string</a></pre>
<pre>0066:    <a href="/share/lib/std/codec/uri_codec.flx#0066">fun uri_decode(encoded:string):string</a></pre>
<hr/><a href="/share/lib/std/control/__init__.fdoc">control/__init__.fdoc</a>
<hr/><a href="/share/lib/std/control/condition_variable.flx">control/condition_variable.flx</a>

<pre>0002:  <a href="/share/lib/std/control/condition_variable.flx#0002">open class Condition_Variable</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Condition Variable for pthread synchronisation.
</p></div>
<pre>0007:    <a href="/share/lib/std/control/condition_variable.flx#0007">type condition_variable</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of a condition variable.
</p></div>
<pre>0010:    <a href="/share/lib/std/control/condition_variable.flx#0010">ctor condition_variable: 1</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Condition variable constructor taking unit argument.
</p></div>
<pre>0013:    <a href="/share/lib/std/control/condition_variable.flx#0013">proc destroy: condition_variable</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to release a condition variable.
</p></div>
<pre>0017:    <a href="/share/lib/std/control/condition_variable.flx#0017">proc wait: condition_variable * mutex</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to wait until a signal is raised on
 the condition variable by another thread.
</p></div>
<pre>0022:    <a href="/share/lib/std/control/condition_variable.flx#0022">proc signal: condition_variable</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to raise a signal on a condition
 variable which will allow at most one thread
 waiting on it to proceed.
</p></div>
<pre>0026:    <a href="/share/lib/std/control/condition_variable.flx#0026">proc broadcast: condition_variable</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to broadcast a signal releasing all
 threads waiting on a conditiona variable.
</p></div>
<pre>0030:    <a href="/share/lib/std/control/condition_variable.flx#0030">gen timedwait: condition_variable * mutex * double -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Timed wait for signal on condition variable.
 Time in seconds. Resolution nanoseconds.
</p></div>
<hr/><a href="/share/lib/std/control/control.flx">control/control.flx</a>

<pre>0001:  <a href="/share/lib/std/control/control.flx#0001">open class Control</a></pre>
<pre>0005:    <a href="/share/lib/std/control/control.flx#0005">proc forever (bdy:unit->void)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> infinite loop
</p></div>
<pre>0014:    <a href="/share/lib/std/control/control.flx#0014">proc pass()</a></pre>
<pre>0017:    <a href="/share/lib/std/control/control.flx#0017">proc for_each</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C style for loop
</p></div>
<pre>0039:    <a href="/share/lib/std/control/control.flx#0039">gen throw[ret,exn] : exn -> any</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> throw[ret, exn] throw exception of type exn
 in a context expecting type ret. It can only be
 used in an expecting context such as the argument
 of a function return or handler of a match expression.
 Felix does not check the ret type, since it sees 
 the type is 'any'. The generated C++, however, will
 fail if the wrong type is used.
</p></div>
<pre>0043:    <a href="/share/lib/std/control/control.flx#0043">gen raise[exn] : exn -> any</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> raise is a statement/procedure which doesn't return.
 that is, it's the function throw with C++ type void.
</p></div>
<pre>0048:    <a href="/share/lib/std/control/control.flx#0048">proc fail:string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> fail is a deprecated procedure which throws
 a C++ standard runtime_error with the given message string.
 It is deprecated because Felix cannot detect it never returns.
</p></div>
<pre>0058:    <a href="/share/lib/std/control/control.flx#0058">fun current_continuation: unit -> cont</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> This is the type of a Felix procedural
 continuations in C++ lifted into Felix.
 Do not confuse this with the Felix type of the procedure.
 This is a hack to get the procedural continuation
 currently executing, it is just the procedures
 C++ this pointer.
</p></div>
<pre>0084:    <a href="/share/lib/std/control/control.flx#0084">proc throw_continuation(x: unit->void)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of a Felix fthread or fibre, which is
 a container which holds a procedural continuation.
  Throw a continuation. This is unsafe. It should
  work from a top level procedure, or any function
  called by such a procedure, but may fail
  if thrown from a procedure called by a function.
  The library run and driver will catch the
  continuation and execute it instead of the
  current continuation. If the library run is used
  and the continuation being executed is down the
  C stack, the C stack will not have been correctly
  popped. Crudely, nested drivers should rethrow
  the exception until the C stack is in the correct
  state to execute the continuation, but there is no
  way to determine that at the moment.
</p><p>  Compiler generated runs ignore the exception,
  the library run catches it. Exceptions typically
  use a non-local goto, and they cannot pass across
  a function boundary.
</p></div>
<pre>0098:    <a href="/share/lib/std/control/control.flx#0098">union svc_req_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of the implementation of a  synchronous channel.
 should be private but needed in this class for the data type,
 and also needed in schannels to do the svc call.
 Felix-OS service call codes.
</p></div>
<pre>0118:    <a href="/share/lib/std/control/control.flx#0118">noinline proc svc(x:svc_req_t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Procedure to perform a supervisor call. 
 this interface just gets rid of the horrible requirement
 the request be in a variable so it is addressable.
 The _svc statement is a compiler intrinsic.
</p></div>
<hr/><a href="/share/lib/std/control/fibres.flx">control/fibres.flx</a>

<pre>0002:  <a href="/share/lib/std/control/fibres.flx#0002">open class Fibres</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Low level management of Felix fthreads (fibres).
</p></div>
<pre>0007:    <a href="/share/lib/std/control/fibres.flx#0007">gen start[t] (p:t->0) (x:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to start a continution with argument type t.
</p></div>
<pre>0012:    <a href="/share/lib/std/control/fibres.flx#0012">gen start (p:1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to start a contiuation without an argument.
</p></div>
<pre>0015:    <a href="/share/lib/std/control/fibres.flx#0015">gen mk_thread: cont->fthread</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to make a fibre out of a continuation.
</p></div>
<pre>0019:    <a href="/share/lib/std/control/fibres.flx#0019">proc spawn_fthread(p:1->0)</a></pre>
<pre>0026:    <a href="/share/lib/std/control/fibres.flx#0026">proc schedule_fthread(p:1->0)</a></pre>
<pre>0034:    <a href="/share/lib/std/control/fibres.flx#0034">proc chain : cont</a></pre>
<pre>0037:    <a href="/share/lib/std/control/fibres.flx#0037">type fibre_scheduler</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of a fibre scheduler.
</p></div>
<pre>0041:    <a href="/share/lib/std/control/fibres.flx#0041">ctor fibre_scheduler: 1</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a fibre scheduler.
  NOTE: NOT GARBAGE COLLECTED!
</p></div>
<pre>0044:    <a href="/share/lib/std/control/fibres.flx#0044">proc delete_fibre_scheduler : fibre_scheduler</a></pre>
<pre>0056:    <a href="/share/lib/std/control/fibres.flx#0056">proc spawn_fibre: fibre_scheduler * fthread</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Spawn a fibre on a given scheduler with a given continuation.
</p></div>
<pre>0079:    <a href="/share/lib/std/control/fibres.flx#0079">fun get_state : fibre_scheduler -> fibre_scheduler_state</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of the stop state of the fibre scheduler.
 terminated: the scheduler is terminated.
 blocked: the scheduler is out of threads to run.
 delegated: the scheduler has been issued a service
  request by a thread which it cannot satisfy.
  The scheduler is put in delegated state and awaits
  for another service to satisfy the request and put
  it back in operation.
</p><p> Note: there is no "operating" state because the
 stop state can only be queried by the schedulers caller
 when the scheduler returns control to it.
</p></div>
<pre>0083:    <a href="/share/lib/std/control/fibres.flx#0083">proc spawn_fthread (fs:fibre_scheduler) (p:1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Core user procedure for launching a fibre.
</p></div>
<pre>0086:    <a href="/share/lib/std/control/fibres.flx#0086">gen step: cont -> cont</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Execute a single step of a fibre.
</p></div>
<pre>0089:    <a href="/share/lib/std/control/fibres.flx#0089">proc kill: fthread</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Schedule death of a fibre.
</p></div>
<pre>0095:    <a href="/share/lib/std/control/fibres.flx#0095">proc run: cont</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Run a continuation until it terminates.
 Do not use this proc if the underlying
 procedure attempts to read messages.
 This is a low level primitive, bypassing fthreads.
</p></div>
<pre>0134:    <a href="/share/lib/std/control/fibres.flx#0134">proc send[t] (p:&cont) (x:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Send a message to a continuation.
 There is no type checking on the message type.
 The procedure is executed until
 the next wait_state, then the message is stored.
 Low level primitive, bypassing fthreads.
</p></div>
<hr/><a href="/share/lib/std/control/forkjoin.flx">control/forkjoin.flx</a>

<pre>0002:  <a href="/share/lib/std/control/forkjoin.flx#0002">open class ForkJoin</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Implement fork/join protocol.
</p></div>
<pre>0006:    <a href="/share/lib/std/control/forkjoin.flx#0006">proc concurrently_by_iterator (var it:1 -> opt[1->0])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Launch a set of pthreads and wait
 until all of them are finished.
</p></div>
<pre>0028:    <a href="/share/lib/std/control/forkjoin.flx#0028">proc concurrently[T with Streamable[T,1->0]] (d:T)</a></pre>
<hr/><a href="/share/lib/std/control/future.fdoc">control/future.fdoc</a>

<pre>0025:  <a href="/share/lib/std/control/future.fdoc#0025">open class Future</a></pre>
<pre>0071:    <a href="/share/lib/std/control/future.fdoc#0071">type future[T]</a></pre>
<pre>0115:    <a href="/share/lib/std/control/future.fdoc#0115">ctor[T] future[T] (e:1->T)</a></pre>
<pre>0130:    <a href="/share/lib/std/control/future.fdoc#0130">inline gen get[T](fut:future[T]):T</a></pre>
<pre>0141:    <a href="/share/lib/std/control/future.fdoc#0141">fun apply[T] (x:future[T], a:unit)</a></pre>
<hr/><a href="/share/lib/std/control/mutex.flx">control/mutex.flx</a>

<pre>0001:  <a href="/share/lib/std/control/mutex.flx#0001">open class Mutex</a></pre>
<pre>0006:    <a href="/share/lib/std/control/mutex.flx#0006">type mutex</a></pre>
<pre>0007:    <a href="/share/lib/std/control/mutex.flx#0007">ctor mutex: unit</a></pre>
<pre>0008:    <a href="/share/lib/std/control/mutex.flx#0008">proc lock: mutex</a></pre>
<pre>0009:    <a href="/share/lib/std/control/mutex.flx#0009">proc unlock: mutex</a></pre>
<pre>0010:    <a href="/share/lib/std/control/mutex.flx#0010">proc destroy: mutex</a></pre>
<hr/><a href="/share/lib/std/control/mux.flx">control/mux.flx</a>

<pre>0003:  <a href="/share/lib/std/control/mux.flx#0003">open class Multiplexor</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Schannel multiplexor.
 Read multiple input schannels, write to an output schannel.
</p></div>
<pre>0006:    <a href="/share/lib/std/control/mux.flx#0006">noinline proc copy[T] (i:ischannel[T],o:oschannel[T]) ()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Schannel copy.
</p></div>
<pre>0017:    <a href="/share/lib/std/control/mux.flx#0017">proc mux[T] (inp:1->opt[ischannel[T]], out:oschannel[T]) ()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Schannel multiplexor based on iterator argument.
 Accepts stream of input schannels.
 Writes to output schannel.
</p></div>
<pre>0028:    <a href="/share/lib/std/control/mux.flx#0028">fun mux[C,T with Streamable[C,ischannel[T]]] (a:C, out:oschannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Schannel multiplexor based on streamable data structure.
 Creates stream of input schannels.
 Writes to output schannel.
</p></div>
<hr/><a href="/share/lib/std/control/pchannels.flx">control/pchannels.flx</a>

<pre>0009:  <a href="/share/lib/std/control/pchannels.flx#0009">open class Pchannel</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Pchannels are unbuffered synchronisation points
 for pre-emptive threads.
</p><p> Similarly to schannels, paired reader-writer pthreads
 cannot proceed until both parties agree data exchange is complete.
 Unlike schannels, both reader and writer can subsequently
 continue concurrently after the exchange.
</p></div>
<pre>0014:    <a href="/share/lib/std/control/pchannels.flx#0014">type pchannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pre-emptive thread channels (monitor).
</p></div>
<pre>0016:    <a href="/share/lib/std/control/pchannels.flx#0016">type ipchannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pre-emptive thread input channel.
</p></div>
<pre>0018:    <a href="/share/lib/std/control/pchannels.flx#0018">type opchannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pre-emptive thread output channel.
</p></div>
<pre>0021:    <a href="/share/lib/std/control/pchannels.flx#0021">fun mk_pchannel[t]: 1->pchannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make bidirectional pchannel.
</p></div>
<pre>0024:    <a href="/share/lib/std/control/pchannels.flx#0024">ctor[t] opchannel[t](x:pchannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Safe cast from bidirectional to output pchannel.
</p></div>
<pre>0026:    <a href="/share/lib/std/control/pchannels.flx#0026">ctor[t] ipchannel[t](x:pchannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Safe cast from bidirectional to input pchannel.
</p></div>
<pre>0029:    <a href="/share/lib/std/control/pchannels.flx#0029">fun mk_iopchannel_pair[t](var ch:pchannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make an input and an output pchannel out of a bidirectional channel.
</p></div>
<pre>0034:    <a href="/share/lib/std/control/pchannels.flx#0034">fun mk_iopchannel_pair[t]()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a connected input and output pchannel pair.
</p></div>
<pre>0047:    <a href="/share/lib/std/control/pchannels.flx#0047">proc _read[t]: pchannel[t] * &&t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Read from a pchannel.
</p></div>
<pre>0059:    <a href="/share/lib/std/control/pchannels.flx#0059">noinline gen read[t] (chan:pchannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write to a pchannel.
</p></div>
<pre>0064:    <a href="/share/lib/std/control/pchannels.flx#0064">gen read[t] (chan:ipchannel[t])</a></pre>
<pre>0066:    <a href="/share/lib/std/control/pchannels.flx#0066">proc _write[t]: pchannel[t] * &t</a></pre>
<pre>0077:    <a href="/share/lib/std/control/pchannels.flx#0077">noinline proc write[t](chan:pchannel[t], v:t)</a></pre>
<pre>0081:    <a href="/share/lib/std/control/pchannels.flx#0081">proc write[t] (chan:opchannel[t], v:t)</a></pre>
<hr/><a href="/share/lib/std/control/ppipe.flx">control/ppipe.flx</a>

<pre>0003:  <a href="/share/lib/std/control/ppipe.flx#0003">open class Ppipe</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Asynchronous Synchronous Pipe.
 Used to link pthreads.
</p></div>
<pre>0006:    <a href="/share/lib/std/control/ppipe.flx#0006">proc psource[T] (var it:1 -> T) (out:opchannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Send an stream down a channel.
</p></div>
<pre>0013:    <a href="/share/lib/std/control/ppipe.flx#0013">proc pisrc[V,T with Streamable[T,V]] (dat:T) (out:opchannel[opt[V]])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> isrc converts a streamable data structure
 such as an array into a source.
</p></div>
<pre>0021:    <a href="/share/lib/std/control/ppipe.flx#0021">fun pipe[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a source component to a sink.
 Return coupled fibre ready to run.
</p></div>
<pre>0036:    <a href="/share/lib/std/control/ppipe.flx#0036">fun pipe[T,U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a source component to a transducer.
 Return source.
</p></div>
<pre>0052:    <a href="/share/lib/std/control/ppipe.flx#0052">fun xpipe[V,T,U with Streamable[T,V]]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> xpipe connects a streamable data structure
 such as an array directly into a transducer.
</p></div>
<pre>0064:    <a href="/share/lib/std/control/ppipe.flx#0064">fun pipe[T,U,V]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a transducer into a transducer.
 Return another transducer.
</p></div>
<pre>0080:    <a href="/share/lib/std/control/ppipe.flx#0080">fun pipe[T,U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a transducer into a sink.
 Return a sink.
</p></div>
<pre>0097:    <a href="/share/lib/std/control/ppipe.flx#0097">proc sort[T with Tord[T]] (r: ipchannel[opt[T]], w: opchannel[opt[T]])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Stream sort using intermediate darray.
 Requires stream of option type.
</p></div>
<hr/><a href="/share/lib/std/control/pthread.flx">control/pthread.flx</a>

<pre>0013:  <a href="/share/lib/std/control/pthread.flx#0013">open class Pthread</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> This class provides access to the operating system's native
 threading routines. On systems with multiple cpus, this may
 increase performance as the operating system may schedule
 threads on different processors.
</p></div>
<pre>0017:    <a href="/share/lib/std/control/pthread.flx#0017">type job_queue</a></pre>
<pre>0018:    <a href="/share/lib/std/control/pthread.flx#0018">type worker_task</a></pre>
<pre>0019:    <a href="/share/lib/std/control/pthread.flx#0019">gen mk_job_queue: int * int -> job_queue</a></pre>
<pre>0020:    <a href="/share/lib/std/control/pthread.flx#0020">proc add_worker_task : job_queue  * worker_task</a></pre>
<pre>0023:    <a href="/share/lib/std/control/pthread.flx#0023">proc spawn_pthread(p:1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> spawn a detached pthread.
</p></div>
<hr/><a href="/share/lib/std/control/schannels.flx">control/schannels.flx</a>

<pre>0005:  <a href="/share/lib/std/control/schannels.flx#0005">open class Schannel</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Sychronous Channels.
 Used to exchange control and possibly data
 between Felix f-threads (aka fibres).
</p></div>
<pre>0017:    <a href="/share/lib/std/control/schannels.flx#0017">gen mk_schannel[t]: 1->schannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of a bidirectional synchronous channel.
 The type of an input synchronous channel.
 The type of an output synchronous channel.
 Create a bidirectional synchronous channel.
</p></div>
<pre>0026:    <a href="/share/lib/std/control/schannels.flx#0026">gen mk_null_schannel[t]: 1->schannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Model a NULL pointer as an schannel. 
 Necessary for killing off schannels,
 so as to make them unreachable, so the gc can reap them.
 Note: null_schannels are safe.
</p></div>
<pre>0031:    <a href="/share/lib/std/control/schannels.flx#0031">gen mk_null_ischannel[t]: 1->ischannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Model a NULL pointer as an ischannel. 
 Necessary for killing off schannels,
 so as to make them unreachable, so the gc can reap them.
</p></div>
<pre>0036:    <a href="/share/lib/std/control/schannels.flx#0036">gen mk_null_oschannel[t]: 1->oschannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Model a NULL pointer as an oschannel. 
 Necessary for killing off schannels,
 so as to make them unreachable, so the gc can reap them.
</p></div>
<pre>0039:    <a href="/share/lib/std/control/schannels.flx#0039">fun isNULL[T] :schannel[T] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if an schannel is NULL.
</p></div>
<pre>0042:    <a href="/share/lib/std/control/schannels.flx#0042">fun isNULL[T] :ischannel[T] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if an ischannel is NULL.
</p></div>
<pre>0045:    <a href="/share/lib/std/control/schannels.flx#0045">fun isNULL[T] :oschannel[T] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if an oschannel is NULL.
</p></div>
<pre>0048:    <a href="/share/lib/std/control/schannels.flx#0048">ctor[t] oschannel[t](x:schannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Safe cast from bidirectional to ouput synchronous channel.
</p></div>
<pre>0051:    <a href="/share/lib/std/control/schannels.flx#0051">ctor[t] ischannel[t](x:schannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Safe cast from bidirectional to input synchronous channel.
</p></div>
<pre>0054:    <a href="/share/lib/std/control/schannels.flx#0054">gen mk_ioschannel_pair[t](var ch:schannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make an input and an output channel out of a bidirectional channel.
</p></div>
<pre>0059:    <a href="/share/lib/std/control/schannels.flx#0059">gen mk_ioschannel_pair[t]()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a connected input and output channel pair.
</p></div>
<pre>0064:    <a href="/share/lib/std/control/schannels.flx#0064">inline gen read[T] (chan:schannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Read an item from a bidirectional channel.
</p></div>
<pre>0071:    <a href="/share/lib/std/control/schannels.flx#0071">inline gen read[T] (chan:ischannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Read an item from an input channel.
</p></div>
<pre>0074:    <a href="/share/lib/std/control/schannels.flx#0074">proc write[T] (chan:schannel[T], v:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write an item to a bidirectional channel.
</p></div>
<pre>0080:    <a href="/share/lib/std/control/schannels.flx#0080">proc broadcast[T] (chan:schannel[T], v:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Multi Write an item to a bidirectional channel.
</p></div>
<pre>0086:    <a href="/share/lib/std/control/schannels.flx#0086">proc write[T] (chan:oschannel[T], v:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Multi Write an item to an output channel.
</p></div>
<pre>0089:    <a href="/share/lib/std/control/schannels.flx#0089">proc broadcast[T] (chan:oschannel[T], v:T)</a></pre>
<hr/><a href="/share/lib/std/control/spipe.flx">control/spipe.flx</a>

<pre>0002:  <a href="/share/lib/std/control/spipe.flx#0002">open class Spipe</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Synchronous Pipe.
</p></div>
<pre>0005:    <a href="/share/lib/std/control/spipe.flx#0005">proc source[T] (var it:1 -> T) (out:oschannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Send an stream down a channel.
</p></div>
<pre>0012:    <a href="/share/lib/std/control/spipe.flx#0012">proc isrc[V,T with Streamable[T,V]] (var dat:T) (out:oschannel[opt[V]])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> isrc converts a streamable data structure
 such as an array into a source.
</p></div>
<pre>0020:    <a href="/share/lib/std/control/spipe.flx#0020">fun pipe[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a source component to a sink.
 Return coupled fibre ready to run.
</p></div>
<pre>0035:    <a href="/share/lib/std/control/spipe.flx#0035">fun pipe[T0,T1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire two sources to two sinks.
 Returns a SINGLE pipeline!
</p></div>
<pre>0054:    <a href="/share/lib/std/control/spipe.flx#0054">proc run_tee[T,N] (i:ischannel[T], oa:oschannel[T]^N)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Utility for tee connector: array of outputs
</p></div>
<pre>0067:    <a href="/share/lib/std/control/spipe.flx#0067">fun pipe[T,N]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire together a source component with an array of sinks.
 Returns a closed pipeline.
</p></div>
<pre>0091:    <a href="/share/lib/std/control/spipe.flx#0091">fun pipe[T,U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a source component to a transducer.
 Return source.
</p></div>
<pre>0107:    <a href="/share/lib/std/control/spipe.flx#0107">fun pipe[T0,T1,U0,U1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire two source components to two transducers.
 Return two sources.
</p></div>
<pre>0135:    <a href="/share/lib/std/control/spipe.flx#0135">fun pipe[T,U0,U1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire together a source component with two transducers
 Returns two sources.
</p></div>
<pre>0159:    <a href="/share/lib/std/control/spipe.flx#0159">fun xpipe[V,T,U with Streamable[T,V]]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> xpipe connects a streamable data structure
 such as an array directly into a transducer.
</p></div>
<pre>0171:    <a href="/share/lib/std/control/spipe.flx#0171">fun pipe[T,U,V]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a transducer into a transducer.
 Return another transducer.
</p></div>
<pre>0187:    <a href="/share/lib/std/control/spipe.flx#0187">fun pipe[T0,T1,U0,U1,V0,V1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire two transducers into two transducers.
 Return two transducers.
</p></div>
<pre>0207:    <a href="/share/lib/std/control/spipe.flx#0207">fun pipe[T,U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a transducer into a sink.
 Return a sink.
</p></div>
<pre>0223:    <a href="/share/lib/std/control/spipe.flx#0223">fun pipe[T0,T1,U0,U1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire two transducers into two sinks.
 Return two sinks.
</p></div>
<pre>0244:    <a href="/share/lib/std/control/spipe.flx#0244">proc sort[T with Tord[T]] (r: ischannel[opt[T]], w: oschannel[opt[T]])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Stream sort using intermediate darray.
 Requires stream of option type.
</p></div>
<hr/><a href="/share/lib/std/control/stream.flx">control/stream.flx</a>

<pre>0005:  <a href="/share/lib/std/control/stream.flx#0005">open class Streamable[ContainerType, ValueType]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Class of data structures supporting streaming.
 The container type just needs an iterator method.
 The iterator method returns a generator which
 yields the values stored in the container.
</p></div>
<pre>0006:    <a href="/share/lib/std/control/stream.flx#0006">virtual fun iterator : ContainerType -> 1 -> opt[ValueType]</a></pre>
<hr/><a href="/share/lib/std/control/ts_bound_queue.flx">control/ts_bound_queue.flx</a>

<pre>0001:  <a href="/share/lib/std/control/ts_bound_queue.flx#0001">open class TS_Bound_Queue</a></pre>
<pre>0009:    <a href="/share/lib/std/control/ts_bound_queue.flx#0009">ctor[T] ts_bound_queue_t[T]: !ints</a></pre>
<pre>0013:    <a href="/share/lib/std/control/ts_bound_queue.flx#0013">proc enqueue[T] (Q:ts_bound_queue_t[T])  (elt:T)</a></pre>
<pre>0016:    <a href="/share/lib/std/control/ts_bound_queue.flx#0016">gen dequeue[T] (Q:ts_bound_queue_t[T]): T</a></pre>
<pre>0017:    <a href="/share/lib/std/control/ts_bound_queue.flx#0017">proc wait[T]: ts_bound_queue_t[T]</a></pre>
<pre>0018:    <a href="/share/lib/std/control/ts_bound_queue.flx#0018">proc resize[T]: ts_bound_queue_t[T] * !ints</a></pre>
<hr/><a href="/share/lib/std/control/ts_counter.flx">control/ts_counter.flx</a>

<pre>0001:  <a href="/share/lib/std/control/ts_counter.flx#0001">open class Ts_counter</a></pre>
<pre>0003:    <a href="/share/lib/std/control/ts_counter.flx#0003">type ts_counter</a></pre>
<pre>0004:    <a href="/share/lib/std/control/ts_counter.flx#0004">ctor ts_counter : 1</a></pre>
<pre>0005:    <a href="/share/lib/std/control/ts_counter.flx#0005">proc destroy : ts_counter</a></pre>
<pre>0006:    <a href="/share/lib/std/control/ts_counter.flx#0006">gen pre_incr: ts_counter -> long</a></pre>
<pre>0007:    <a href="/share/lib/std/control/ts_counter.flx#0007">gen post_incr: ts_counter-> long</a></pre>
<pre>0008:    <a href="/share/lib/std/control/ts_counter.flx#0008">gen pre_decr: ts_counter -> long</a></pre>
<pre>0009:    <a href="/share/lib/std/control/ts_counter.flx#0009">gen post_decr: ts_counter -> long</a></pre>
<pre>0010:    <a href="/share/lib/std/control/ts_counter.flx#0010">gen decr_pos: ts_counter -> long</a></pre>
<pre>0011:    <a href="/share/lib/std/control/ts_counter.flx#0011">gen get: ts_counter -> long</a></pre>
<pre>0012:    <a href="/share/lib/std/control/ts_counter.flx#0012">proc set: ts_counter * long</a></pre>
<pre>0013:    <a href="/share/lib/std/control/ts_counter.flx#0013">gen swap: ts_counter * long -> long</a></pre>
<pre>0014:    <a href="/share/lib/std/control/ts_counter.flx#0014">proc wait_zero: ts_counter</a></pre>
<hr/><a href="/share/lib/std/cptr.flx">cptr.flx</a>

<pre>0005:  <a href="/share/lib/std/cptr.flx#0005">open class Cptr</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Felix and C pointers.
 Felix pointer ptr[T] = &T.
 C pointer cptr[T] = &T.
 See also carray for incrementable pointers carray[T] = +T.
</p></div>
<pre>0011:    <a href="/share/lib/std/cptr.flx#0011">typedef ptr[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a Felix pointer.
 Always points to an object.
 Cannot be NULL.
 Cannot be incremented.
</p></div>
<pre>0019:    <a href="/share/lib/std/cptr.flx#0019">union cptr[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Dereference a Felx pointer.
 Type of a C pointer.
 Either pointes to an object or is NULL.
 Cannot be incremented.
</p></div>
<pre>0022:    <a href="/share/lib/std/cptr.flx#0022">ctor[T] cptr[T]: &T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Demote a Felix pointer to a C pointer. Safe.
</p></div>
<pre>0027:    <a href="/share/lib/std/cptr.flx#0027">ctor[T] ptr[T]( px:cptr[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Promote a C pointer to a Felix pointer.
 Conversion is checked.
 Aborts with match failure if NULL.
</p></div>
<pre>0030:    <a href="/share/lib/std/cptr.flx#0030">fun deref[T] (px:cptr[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Checked dereference of C pointer.
</p></div>
<pre>0033:    <a href="/share/lib/std/cptr.flx#0033">fun is_nullptr[T] (px:cptr[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if a C pointer is NULL.
</p></div>
<hr/><a href="/share/lib/std/cstdlib.flx">cstdlib.flx</a>

<pre>0001:  <a href="/share/lib/std/cstdlib.flx#0001">open class Cstdlib</a></pre>
<pre>0007:    <a href="/share/lib/std/cstdlib.flx#0007">proc srand: uint</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C89 Standard C library seed random number generator.
</p></div>
<pre>0011:    <a href="/share/lib/std/cstdlib.flx#0011">fun rand: unit -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C89 Standard C library random number generator.
 Known to be not very good. Try not to use it!
</p></div>
<hr/><a href="/share/lib/std/cxx_headers.flx">cxx_headers.flx</a>

<pre>0001:  <a href="/share/lib/std/cxx_headers.flx#0001">class Cxx_headers</a></pre>

<pre>0059:  <a href="/share/lib/std/cxx_headers.flx#0059">class Cxx11_headers  // http://en.cppreference.com/w/cpp/header</a></pre>
<hr/><a href="/share/lib/std/datatype/__init__.fdoc">datatype/__init__.fdoc</a>
<hr/><a href="/share/lib/std/datatype/array.flx">datatype/array.flx</a>

<pre>0002:  <a href="/share/lib/std/datatype/array.flx#0002">open class Farray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Compile time fix length array.
</p></div>
<pre>0004:    <a href="/share/lib/std/datatype/array.flx#0004">typedef array[t,n]</a></pre>
<pre>0009:    <a href="/share/lib/std/datatype/array.flx#0009">fun copy[T,N] (var x:array[T,N])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Array copy.
</p></div>
<pre>0012:    <a href="/share/lib/std/datatype/array.flx#0012">ctor[T] array[T,1] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Array of one element.
</p></div>
<pre>0016:    <a href="/share/lib/std/datatype/array.flx#0016">fun len (x:array[t, n]): size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Array as value.
</p></div>
<pre>0018:    <a href="/share/lib/std/datatype/array.flx#0018">fun unsafe_get (var a: array[t, n], j: size): t</a></pre>
<pre>0023:    <a href="/share/lib/std/datatype/array.flx#0023">fun len (x:&array[t, n]): size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pointer to array as value.
</p></div>
<pre>0025:    <a href="/share/lib/std/datatype/array.flx#0025">fun unsafe_get: &array[t, n] * size  -> &t</a></pre>
<pre>0029:    <a href="/share/lib/std/datatype/array.flx#0029">proc unsafe_set[t,n] (a: &(t^n), i:size, v:t)</a></pre>
<pre>0030:    <a href="/share/lib/std/datatype/array.flx#0030">proc set[t,n, I in ints] (a: &array[t,n], i:I,v:t)</a></pre>
<pre>0036:    <a href="/share/lib/std/datatype/array.flx#0036">fun stl_begin[t,n]: &array[t,n] -> +t</a></pre>
<pre>0037:    <a href="/share/lib/std/datatype/array.flx#0037">fun stl_end[t,n] ( x:&array[t,n] ) : +t</a></pre>
<pre>0040:    <a href="/share/lib/std/datatype/array.flx#0040">fun map[V,N,U] (_f:V->U) (x:array[V,N]):array[U,N]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Array map.
</p></div>
<pre>0058:    <a href="/share/lib/std/datatype/array.flx#0058">fun join[T, N, M] (x:array[T, N]) (y:array[T, M]):array[T, N + M]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join two arrays (functional).
</p></div>
<pre>0077:    <a href="/share/lib/std/datatype/array.flx#0077">fun join[T, N] (x:array[T, N]) (y:T):array[T, N + 1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Append value to end of an array (functional).
</p></div>
<pre>0090:    <a href="/share/lib/std/datatype/array.flx#0090">fun join[T, M] (x:T) (y:array[T, M]):array[T, 1 + M]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Prepand value to start of an array (functional).
</p></div>
<pre>0111:    <a href="/share/lib/std/datatype/array.flx#0111">fun transpose[T,N,M] (y:array[array[T,M],N]) : array[array[T,N],M]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join two arrays (functional).
 Transpose and array.
 Subsumes zip.
 Example: transpose ( (1,2,3), (4,5,6) ) = ( (1,4), (2,4), (3,6) ).
</p></div>
<pre>0127:    <a href="/share/lib/std/datatype/array.flx#0127">fun rev[T, N] (x:array[T, N]): array[T, N]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Reverse elements of an array.
</p></div>
<pre>0138:    <a href="/share/lib/std/datatype/array.flx#0138">fun sort[T,N] (cmp: T * T -> bool) (var x:array[T,N]) : array[T,N]</a></pre>
<pre>0143:    <a href="/share/lib/std/datatype/array.flx#0143">fun sort[T,N] (var x:array[T,N]) : array[T,N]</a></pre>
<pre>0151:    <a href="/share/lib/std/datatype/array.flx#0151">fun str (xs:array[T,N])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Display: convert to string like (1,2,3).
</p></div>
<hr/><a href="/share/lib/std/datatype/array_class.fdoc">datatype/array_class.fdoc</a>

<pre>0014:  <a href="/share/lib/std/datatype/array_class.fdoc#0014">class ArrayValue[t,v]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Array as Value (immutable).
</p></div>
<pre>0021:    <a href="/share/lib/std/datatype/array_class.fdoc#0021">virtual fun len: t -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Length.
</p></div>
<pre>0028:    <a href="/share/lib/std/datatype/array_class.fdoc#0028">virtual fun unsafe_get: t * size -> v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Unchecked common indexing.
</p></div>
<pre>0032:    <a href="/share/lib/std/datatype/array_class.fdoc#0032">fun get[I in ints] (x:t, i:I)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Checked common indexing.
</p></div>
<pre>0040:    <a href="/share/lib/std/datatype/array_class.fdoc#0040">virtual function so that the default definitions</a></pre>
<pre>0057:    <a href="/share/lib/std/datatype/array_class.fdoc#0057">fun apply [I in ints] (i:I, x:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p>  Checked common indexing.
</p></div>
<pre>0062:    <a href="/share/lib/std/datatype/array_class.fdoc#0062">virtual proc iter (_f:v->void) (x:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Callback based value iterator.
</p></div>
<pre>0075:    <a href="/share/lib/std/datatype/array_class.fdoc#0075">virtual proc iiter (_f:size -> v->void) (x:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Callback based index and value iterator.
 Callback f index value.
</p></div>
<pre>0099:    <a href="/share/lib/std/datatype/array_class.fdoc#0099">gen iterator(xs:t) () : opt[v]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Stream  value iterator.
</p></div>
<pre>0116:    <a href="/share/lib/std/datatype/array_class.fdoc#0116">virtual fun fold_left[u] (_f:u->v->u) (init:u) (x:t): u</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Traditional left fold.
</p></div>
<pre>0132:    <a href="/share/lib/std/datatype/array_class.fdoc#0132">virtual fun fold_right[u] (_f:v->u->u) (x:t) (init:u): u</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Traditional right fold.
</p></div>
<pre>0152:    <a href="/share/lib/std/datatype/array_class.fdoc#0152">virtual fun fold[u] (_f:u->v->u) (init:u) (x:t): u</a></pre>
<pre>0161:    <a href="/share/lib/std/datatype/array_class.fdoc#0161">virtual fun mem(pred:v->bool) (x:t): bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Membership by predicate.
</p></div>
<pre>0180:    <a href="/share/lib/std/datatype/array_class.fdoc#0180">virtual fun mem[u] (rel:v*u->bool) (x:t) (e:u): bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Membership by relation to given value. 
</p></div>
<pre>0201:    <a href="/share/lib/std/datatype/array_class.fdoc#0201">virtual fun find(pred:v->bool) (x:t): opt[v]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Array as Set:
 Membership by equality of value type.
 Searching for value satisfying predicate.
</p></div>
<pre>0218:    <a href="/share/lib/std/datatype/array_class.fdoc#0218">virtual fun find (rel:v*v->bool) (x:t) (e:v): opt[v]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Searching for value satisfying relation to given value.
</p></div>

<pre>0249:  <a href="/share/lib/std/datatype/array_class.fdoc#0249">class TrueArrayValue [t,x,v]</a></pre>
<pre>0253:    <a href="/share/lib/std/datatype/array_class.fdoc#0253">fun true_unsafe_get (a:t, i:x)</a></pre>

<pre>0263:  <a href="/share/lib/std/datatype/array_class.fdoc#0263">class ArrayObject[t,v]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Array as Object (mutable).
</p></div>
<pre>0272:    <a href="/share/lib/std/datatype/array_class.fdoc#0272">virtual proc unsafe_set: t * size * v</a></pre>
<pre>0280:    <a href="/share/lib/std/datatype/array_class.fdoc#0280">virtual fun unsafe_get_ref : t * size -> &v</a></pre>
<pre>0287:    <a href="/share/lib/std/datatype/array_class.fdoc#0287">proc set[I in ints] (x:t, i:I, a:v)</a></pre>
<pre>0293:    <a href="/share/lib/std/datatype/array_class.fdoc#0293">fun n"&." [I in ints] (x:t, i:I) : &v</a></pre>

<pre>0303:  <a href="/share/lib/std/datatype/array_class.fdoc#0303">class TrueArrayObject[t,x, v]</a></pre>
<pre>0307:    <a href="/share/lib/std/datatype/array_class.fdoc#0307">proc true_unsafe_set(a:t, i:x, e:v)</a></pre>

<pre>0324:  <a href="/share/lib/std/datatype/array_class.fdoc#0324">class ContiguousArrayObject[t,v]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Array as Contiguous STL Object.
 Provides STL iterators type +v
</p></div>
<pre>0331:    <a href="/share/lib/std/datatype/array_class.fdoc#0331">virtual fun stl_begin: t -> +v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Start of array iterator.
</p></div>
<pre>0334:    <a href="/share/lib/std/datatype/array_class.fdoc#0334">virtual fun stl_end: t -> +v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> One past the end of array iterator.
</p></div>
<pre>0352:    <a href="/share/lib/std/datatype/array_class.fdoc#0352">proc sort (cmp: v * v -> bool) (a:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Add integer to iterator.
 In place sort using STL sort with Felix comparator.
</p></div>
<pre>0363:    <a href="/share/lib/std/datatype/array_class.fdoc#0363">proc sort[with Tord[v]] (a:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> In place sort using STL sort with default comparison.
</p></div>

<pre>0371:  <a href="/share/lib/std/datatype/array_class.fdoc#0371">class TrueContiguousArrayObject[t,x, v]</a></pre>
<hr/><a href="/share/lib/std/datatype/assoc_list.fdoc">datatype/assoc_list.fdoc</a>

<pre>0005:  <a href="/share/lib/std/datatype/assoc_list.fdoc#0005">open class Assoc_list</a></pre>
<pre>0007:    <a href="/share/lib/std/datatype/assoc_list.fdoc#0007">typedef assoc_list[A,B]</a></pre>
<pre>0011:    <a href="/share/lib/std/datatype/assoc_list.fdoc#0011">fun mem[A,B] (eq:A -> bool) (xs:assoc_list[A,B]) : bool</a></pre>
<pre>0017:    <a href="/share/lib/std/datatype/assoc_list.fdoc#0017">fun mem[A,B,T] (eq:A * T -> bool) (xs:assoc_list[A,B]) (e:T) : bool</a></pre>
<pre>0022:    <a href="/share/lib/std/datatype/assoc_list.fdoc#0022">fun mem[A,B with Eq[A]] (xs:assoc_list[A,B]) (e:A) : bool</a></pre>
<pre>0029:    <a href="/share/lib/std/datatype/assoc_list.fdoc#0029">fun find[A,B] (eq:A -> bool) (xs:assoc_list[A,B]) : opt[B]</a></pre>
<pre>0038:    <a href="/share/lib/std/datatype/assoc_list.fdoc#0038">fun find[A,B,T] (eq:A * T -> bool) (xs:assoc_list[A,B]) (e:T) : opt[B]</a></pre>
<pre>0042:    <a href="/share/lib/std/datatype/assoc_list.fdoc#0042">fun find[A,B with Eq[A]] (xs:assoc_list[A,B]) (e:A) : opt[B]</a></pre>
<hr/><a href="/share/lib/std/datatype/avl.flx">datatype/avl.flx</a>

<pre>0001:  <a href="/share/lib/std/datatype/avl.flx#0001">class Avl</a></pre>
<pre>0003:    <a href="/share/lib/std/datatype/avl.flx#0003">union avl[T]</a></pre>
<pre>0010:    <a href="/share/lib/std/datatype/avl.flx#0010">fun _ctor_avl[T] ()</a></pre>
<pre>0012:    <a href="/share/lib/std/datatype/avl.flx#0012">fun _ctor_avl[T] (x : T, left : avl[T], right : avl[T])</a></pre>
<pre>0078:    <a href="/share/lib/std/datatype/avl.flx#0078">fun insert[T] (tree : avl[T], y : T, cmp : T*T->int)</a></pre>
<pre>0093:    <a href="/share/lib/std/datatype/avl.flx#0093">fun insert[T] (y : T, cmp : T*T->int)</a></pre>
<pre>0099:    <a href="/share/lib/std/datatype/avl.flx#0099">fun find[T] (tree : avl[T], y : T, cmp : T*T->int) : opt[T]</a></pre>
<pre>0115:    <a href="/share/lib/std/datatype/avl.flx#0115">fun last[T] : avl[T]->T</a></pre>
<pre>0120:    <a href="/share/lib/std/datatype/avl.flx#0120">fun all_but_last[T] : avl[T]->avl[T]</a></pre>
<pre>0127:    <a href="/share/lib/std/datatype/avl.flx#0127">fun first[T] : avl[T]->T</a></pre>
<pre>0132:    <a href="/share/lib/std/datatype/avl.flx#0132">fun all_but_first[T] : avl[T]->avl[T]</a></pre>
<pre>0139:    <a href="/share/lib/std/datatype/avl.flx#0139">fun join[T] (A : avl[T], B : avl[T])</a></pre>
<pre>0146:    <a href="/share/lib/std/datatype/avl.flx#0146">fun remove[T] (tree : avl[T], y : T, cmp : T*T->int)</a></pre>
<pre>0162:    <a href="/share/lib/std/datatype/avl.flx#0162">fun fold_left[T, U] (f:U->T->U) (accumulated:U) (tree:avl[T]):U</a></pre>
<pre>0170:    <a href="/share/lib/std/datatype/avl.flx#0170">fun fold_right[T, U] (f:T->U->U) (tree:avl[T]) (accumulated:U)</a></pre>
<pre>0180:    <a href="/share/lib/std/datatype/avl.flx#0180">proc iter[T] (f:T->void, tree:avl[T])</a></pre>
<pre>0192:    <a href="/share/lib/std/datatype/avl.flx#0192">proc iter[T] (f:int*T->void, tree:avl[T])</a></pre>
<pre>0194:    <a href="/share/lib/std/datatype/avl.flx#0194">proc aux (depth:int, f:int*T->void, tree:avl[T])</a></pre>
<hr/><a href="/share/lib/std/datatype/bsarray.flx">datatype/bsarray.flx</a>

<pre>0005:  <a href="/share/lib/std/datatype/bsarray.flx#0005">open class Bsarray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Bounded sparse array.
 Basically a sarray with a given bound.
 The bound is ignored for get and set methods.
 The bound is used for membership tests and iteration.
</p></div>
<pre>0008:    <a href="/share/lib/std/datatype/bsarray.flx#0008">type bsarray[T]</a></pre>
<pre>0017:    <a href="/share/lib/std/datatype/bsarray.flx#0017">fun len(b:bsarray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Contruct with default value and bound.
 Contrue as array value.
</p></div>
<pre>0018:    <a href="/share/lib/std/datatype/bsarray.flx#0018">fun unsafe_get(b:bsarray[T], i:size)</a></pre>
<pre>0023:    <a href="/share/lib/std/datatype/bsarray.flx#0023">proc unsafe_set(b:bsarray[T], i:size, v:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Contrue as array object.
</p></div>
<pre>0041:    <a href="/share/lib/std/datatype/bsarray.flx#0041">fun str (xs:bsarray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Contrue as set: membership test.
 Convert to string.
</p></div>
<hr/><a href="/share/lib/std/datatype/darray.fdoc">datatype/darray.fdoc</a>

<pre>0019:  <a href="/share/lib/std/datatype/darray.fdoc#0019">open class Darray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Unbounded Variable length object array.
</p></div>
<pre>0067:    <a href="/share/lib/std/datatype/darray.fdoc#0067">type darray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> This is the default array resize function.
 If we run out of space, allocate what we have + 50%.
 If we need less than half the allocated space, return the requested size + 50%.
 Otherwise return the existing allocated space.
 Type of a darray.
</p></div>
<pre>0081:    <a href="/share/lib/std/datatype/darray.fdoc#0081">proc do_resize[T] (pd: darray[T], new_size: size)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Force a resize.
 Similar to C++ vector reserve function.
</p></div>
<pre>0090:    <a href="/share/lib/std/datatype/darray.fdoc#0090">ctor[T] darray[T] ()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make an empty darray, give it 20 slots for no particular reason.
</p></div>
<pre>0093:    <a href="/share/lib/std/datatype/darray.fdoc#0093">ctor[T,N] darray[T] (a:array[T,N])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make a darray from an array
</p></div>
<pre>0096:    <a href="/share/lib/std/datatype/darray.fdoc#0096">ctor[T] darray[T] (a:varray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make a darray from a varray
</p></div>
<pre>0099:    <a href="/share/lib/std/datatype/darray.fdoc#0099">ctor[T] darray[T] (a:darray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make a darray from a darray (copy)
</p></div>
<pre>0103:    <a href="/share/lib/std/datatype/darray.fdoc#0103">ctor[T] darray[T] (n:size, default:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> make a darray of a certain size initialised with some default value
</p></div>
<pre>0109:    <a href="/share/lib/std/datatype/darray.fdoc#0109">fun len (a:darray[v])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Basic array value stuff.
</p></div>
<pre>0110:    <a href="/share/lib/std/datatype/darray.fdoc#0110">fun unsafe_get (a:darray[v], i:size)</a></pre>
<pre>0117:    <a href="/share/lib/std/datatype/darray.fdoc#0117">proc unsafe_set (b:darray[v],  n:size, x:v)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Basic array object stuff.
</p></div>
<pre>0118:    <a href="/share/lib/std/datatype/darray.fdoc#0118">fun unsafe_get_ref (b:darray[v],  n:size) : &v</a></pre>
<pre>0125:    <a href="/share/lib/std/datatype/darray.fdoc#0125">fun stl_begin(b:darray[v])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Contrue as contiguous store.
</p></div>
<pre>0126:    <a href="/share/lib/std/datatype/darray.fdoc#0126">fun stl_end(b:darray[v])</a></pre>
<pre>0137:    <a href="/share/lib/std/datatype/darray.fdoc#0137">proc pop[t](a:darray[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pop a value from the end.
 Same as pop_back in C++.
</p></div>
<pre>0151:    <a href="/share/lib/std/datatype/darray.fdoc#0151">proc push_back[t] (a:darray[t], v:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Push a value onto the end.
 Same as push_back in C++.
 Push a value onto the end.
 Same as push_back in C++.
</p></div>
<pre>0159:    <a href="/share/lib/std/datatype/darray.fdoc#0159">proc insert[t] (a:darray[t], i:int, v:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> insert
</p></div>
<pre>0170:    <a href="/share/lib/std/datatype/darray.fdoc#0170">proc erase[t] (a:darray[t], i:int)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Erase an element, note doesn't resize the varray,
 probably should ..
</p></div>
<pre>0174:    <a href="/share/lib/std/datatype/darray.fdoc#0174">proc erase[t] (a:darray[t], first:int, last:int)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Erase multiple elements, note doesn't resize the varray,
 probably should ..
</p></div>
<pre>0182:    <a href="/share/lib/std/datatype/darray.fdoc#0182">fun str (x:darray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert an array to a string,
 provided the element type is convertible.
</p></div>
<hr/><a href="/share/lib/std/datatype/judy.flx">datatype/judy.flx</a>

<pre>0008:  <a href="/share/lib/std/datatype/judy.flx#0008">class Judy</a></pre>
<pre>0014:    <a href="/share/lib/std/datatype/judy.flx#0014">type word</a></pre>
<pre>0015:    <a href="/share/lib/std/datatype/judy.flx#0015">ctor word: !ints</a></pre>
<pre>0016:    <a href="/share/lib/std/datatype/judy.flx#0016">ctor word: address</a></pre>
<pre>0017:    <a href="/share/lib/std/datatype/judy.flx#0017">ctor int: word</a></pre>
<pre>0018:    <a href="/share/lib/std/datatype/judy.flx#0018">ctor uint: word</a></pre>
<pre>0019:    <a href="/share/lib/std/datatype/judy.flx#0019">ctor ulong: word</a></pre>
<pre>0020:    <a href="/share/lib/std/datatype/judy.flx#0020">ctor size: word</a></pre>
<pre>0021:    <a href="/share/lib/std/datatype/judy.flx#0021">ctor address: word</a></pre>
<pre>0022:    <a href="/share/lib/std/datatype/judy.flx#0022">fun isNULL: word -> bool</a></pre>
<pre>0023:    <a href="/share/lib/std/datatype/judy.flx#0023">fun isNULL: &word -> bool</a></pre>
<pre>0025:    <a href="/share/lib/std/datatype/judy.flx#0025">type JError_t</a></pre>
<pre>0030:    <a href="/share/lib/std/datatype/judy.flx#0030">typedef void *voidp</a></pre>
<pre>0060:    <a href="/share/lib/std/datatype/judy.flx#0060">gen _ctor_J1Array: 1 -> J1Array</a></pre>
<pre>0066:    <a href="/share/lib/std/datatype/judy.flx#0066">proc free: J1Array</a></pre>
<pre>0068:    <a href="/share/lib/std/datatype/judy.flx#0068">proc Judy1Set: J1Array * word * &JError_t * &int</a></pre>
<pre>0071:    <a href="/share/lib/std/datatype/judy.flx#0071">proc Judy1Unset: J1Array * word * &JError_t * &int</a></pre>
<pre>0074:    <a href="/share/lib/std/datatype/judy.flx#0074">proc Judy1Test: J1Array * word * &JError_t * &int</a></pre>
<pre>0085:    <a href="/share/lib/std/datatype/judy.flx#0085">proc Judy1Count: J1Array * word * word* &JError_t * &word</a></pre>
<pre>0088:    <a href="/share/lib/std/datatype/judy.flx#0088">proc Judy1ByCount: J1Array * word * &word * &JError_t * &word</a></pre>
<pre>0091:    <a href="/share/lib/std/datatype/judy.flx#0091">proc Judy1FreeArray: J1Array * &JError_t * &word</a></pre>
<pre>0094:    <a href="/share/lib/std/datatype/judy.flx#0094">proc Judy1MemUsed: J1Array * &word</a></pre>
<pre>0096:    <a href="/share/lib/std/datatype/judy.flx#0096">proc Judy1First: J1Array * &word * &JError_t * &int</a></pre>
<pre>0099:    <a href="/share/lib/std/datatype/judy.flx#0099">proc Judy1Next: J1Array * &word * &JError_t * &int</a></pre>
<pre>0102:    <a href="/share/lib/std/datatype/judy.flx#0102">proc Judy1Last: J1Array * &word * &JError_t * &int</a></pre>
<pre>0105:    <a href="/share/lib/std/datatype/judy.flx#0105">proc Judy1Prev: J1Array * &word * &JError_t * &int</a></pre>
<pre>0108:    <a href="/share/lib/std/datatype/judy.flx#0108">proc Judy1FirstEmpty: J1Array * &word * &JError_t * &int</a></pre>
<pre>0111:    <a href="/share/lib/std/datatype/judy.flx#0111">proc Judy1NextEmpty: J1Array * &word * &JError_t * &int</a></pre>
<pre>0114:    <a href="/share/lib/std/datatype/judy.flx#0114">proc Judy1LastEmpty: J1Array * &word * &JError_t * &int</a></pre>
<pre>0117:    <a href="/share/lib/std/datatype/judy.flx#0117">proc Judy1PrevEmpty: J1Array * &word * &JError_t * &int</a></pre>
<pre>0139:    <a href="/share/lib/std/datatype/judy.flx#0139">gen _ctor_JLArray: 1 -> JLArray</a></pre>
<pre>0145:    <a href="/share/lib/std/datatype/judy.flx#0145">proc free: JLArray</a></pre>
<pre>0148:    <a href="/share/lib/std/datatype/judy.flx#0148">proc JudyLIns: JLArray * word * &JError_t * &&word</a></pre>
<pre>0151:    <a href="/share/lib/std/datatype/judy.flx#0151">proc JudyLDel: JLArray * word * &JError_t * &int</a></pre>
<pre>0154:    <a href="/share/lib/std/datatype/judy.flx#0154">proc JudyLGet: JLArray * word * &JError_t * &&word</a></pre>
<pre>0157:    <a href="/share/lib/std/datatype/judy.flx#0157">proc JudyLCount: JLArray * word * word * &JError_t * &word</a></pre>
<pre>0160:    <a href="/share/lib/std/datatype/judy.flx#0160">proc JudyLByCount: JLArray * word * &word * &JError_t * &&word</a></pre>
<pre>0163:    <a href="/share/lib/std/datatype/judy.flx#0163">proc JudyLFreeArray: JLArray * &JError_t * &word</a></pre>
<pre>0166:    <a href="/share/lib/std/datatype/judy.flx#0166">proc JudyLMemUsed: JLArray * &word</a></pre>
<pre>0169:    <a href="/share/lib/std/datatype/judy.flx#0169">proc JudyLFirst: JLArray * &word * &JError_t * &&word</a></pre>
<pre>0172:    <a href="/share/lib/std/datatype/judy.flx#0172">proc JudyLNext: JLArray * &word * &JError_t * &&word</a></pre>
<pre>0175:    <a href="/share/lib/std/datatype/judy.flx#0175">proc JudyLLast: JLArray * &word * &JError_t * &&word</a></pre>
<pre>0178:    <a href="/share/lib/std/datatype/judy.flx#0178">proc JudyLPrev: JLArray * &word * &JError_t * &&word</a></pre>
<pre>0181:    <a href="/share/lib/std/datatype/judy.flx#0181">proc JudyLFirstEmpty: JLArray * &word * &JError_t * &word</a></pre>
<pre>0184:    <a href="/share/lib/std/datatype/judy.flx#0184">proc JudyLNextEmpty: JLArray * &word * &JError_t * &word</a></pre>
<pre>0187:    <a href="/share/lib/std/datatype/judy.flx#0187">proc JudyLLastEmpty: JLArray * &word * &JError_t * &word</a></pre>
<pre>0190:    <a href="/share/lib/std/datatype/judy.flx#0190">proc JudyLPrevEmpty: JLArray * &word * &JError_t * &word</a></pre>
<pre>0216:    <a href="/share/lib/std/datatype/judy.flx#0216">gen _ctor_JSLArray: 1 -> JSLArray</a></pre>
<pre>0222:    <a href="/share/lib/std/datatype/judy.flx#0222">proc free: JSLArray</a></pre>
<pre>0226:    <a href="/share/lib/std/datatype/judy.flx#0226">proc JudySLIns: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0232:    <a href="/share/lib/std/datatype/judy.flx#0232">proc JudySLDel: JSLArray * +char * &JError_t * &int</a></pre>
<pre>0235:    <a href="/share/lib/std/datatype/judy.flx#0235">proc JudySLGet: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0238:    <a href="/share/lib/std/datatype/judy.flx#0238">proc JudySLFirst: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0241:    <a href="/share/lib/std/datatype/judy.flx#0241">proc JudySLNext: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0244:    <a href="/share/lib/std/datatype/judy.flx#0244">proc JudySLLast: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0247:    <a href="/share/lib/std/datatype/judy.flx#0247">proc JudySLPrev: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0255:    <a href="/share/lib/std/datatype/judy.flx#0255">type JHSArray</a></pre>
<pre>0256:    <a href="/share/lib/std/datatype/judy.flx#0256">gen _ctor_JHSArray: 1 -> JHSArray</a></pre>
<pre>0258:    <a href="/share/lib/std/datatype/judy.flx#0258">proc free: JHSArray</a></pre>
<pre>0263:    <a href="/share/lib/std/datatype/judy.flx#0263">proc JudyHSIns: JHSArray * address * word * &JError_t * &&word</a></pre>
<pre>0266:    <a href="/share/lib/std/datatype/judy.flx#0266">proc JudyHSDel: JHSArray * address * word * &JError_t * &int</a></pre>
<pre>0269:    <a href="/share/lib/std/datatype/judy.flx#0269">proc JudyHSGet: JHSArray * address * word * &JError_t * &&word</a></pre>
<hr/><a href="/share/lib/std/datatype/list.fdoc">datatype/list.fdoc</a>

<pre>0005:  <a href="/share/lib/std/datatype/list.fdoc#0005">open class List</a></pre>
<pre>0009:    <a href="/share/lib/std/datatype/list.fdoc#0009">union list[T]</a></pre>
<pre>0033:    <a href="/share/lib/std/datatype/list.fdoc#0033">proc splice[T] : &list[T] * list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The second list is made the tail of the
 list stored at the location pointed at by the first argument.
 If the first list is empty, the variable will point
 at the second list. This operation is DANGEROUS because
 it is a mutator: lists are traditionally purely functional.
</p></div>
<pre>0036:    <a href="/share/lib/std/datatype/list.fdoc#0036">struct node_t</a></pre>
<pre>0049:    <a href="/share/lib/std/datatype/list.fdoc#0049">proc rev[T,PLT</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> In place list reversal: unsafe!
</p></div>
<pre>0055:    <a href="/share/lib/std/datatype/list.fdoc#0055">struct node_t</a></pre>
<pre>0076:    <a href="/share/lib/std/datatype/list.fdoc#0076">proc rev_last[T,PLT</a></pre>
<pre>0082:    <a href="/share/lib/std/datatype/list.fdoc#0082">struct node_t</a></pre>
<pre>0104:    <a href="/share/lib/std/datatype/list.fdoc#0104">fun copy[T] (x:list[T]):list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Copy a list.
</p></div>
<pre>0115:    <a href="/share/lib/std/datatype/list.fdoc#0115">proc copy_last[T] (inp:list[T], out:&list[T], last:&list[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Copy a list, and return last element as a list,
 empty if original list was empty.
</p></div>
<pre>0124:    <a href="/share/lib/std/datatype/list.fdoc#0124">ctor[T] list[T] ()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make an empty list.
</p></div>
<pre>0133:    <a href="/share/lib/std/datatype/list.fdoc#0133">ctor[T] list[T] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make a list with one element.
 NOTE: list (1,2) is a list of 2 ints.
 To get a list of one pair use list[int*int] (1,2) instead!
</p></div>
<pre>0138:    <a href="/share/lib/std/datatype/list.fdoc#0138">ctor[T,N] list[T] (x:array[T, N])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make a list from an array.
</p></div>
<pre>0154:    <a href="/share/lib/std/datatype/list.fdoc#0154">fun list_comprehension[T] (f: (1->opt[T]))</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> List comprehension:
 Make a list from a stream.
</p></div>
<pre>0156:    <a href="/share/lib/std/datatype/list.fdoc#0156">fun aux (l:list[T])</a></pre>
<pre>0174:    <a href="/share/lib/std/datatype/list.fdoc#0174">ctor[T] list[T](f: (1->opt[T]))</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> List comprehension:
 Make a list from a stream.
</p></div>
<pre>0184:    <a href="/share/lib/std/datatype/list.fdoc#0184">fun aux (acc:size) (x:list[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Contrue a list as an array value
 Return umber of elements in a list.
</p></div>
<pre>0203:    <a href="/share/lib/std/datatype/list.fdoc#0203">proc iter (_f:T->void) (x:list[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> get n'th element
 Apply a procedure to each element of a list.
</p></div>
<pre>0214:    <a href="/share/lib/std/datatype/list.fdoc#0214">fun fold_left[U] (_f:U->T->U) (init:U) (x:list[T]):U</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Traditional left fold over list (tail rec).
</p></div>
<pre>0216:    <a href="/share/lib/std/datatype/list.fdoc#0216">fun aux (init:U) (x:list[T]):U</a></pre>
<pre>0228:    <a href="/share/lib/std/datatype/list.fdoc#0228">fun fold_right[U] (_f:T->U->U) (x:list[T]) (init:U):U</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Right fold over list (not tail rec!).
</p></div>
<pre>0230:    <a href="/share/lib/std/datatype/list.fdoc#0230">fun aux (x:list[T]) (init:U):U</a></pre>
<pre>0244:    <a href="/share/lib/std/datatype/list.fdoc#0244">pure fun is_empty[T] : list[T] -> 2</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if a list is empty.
</p></div>
<pre>0252:    <a href="/share/lib/std/datatype/list.fdoc#0252">pure fun tail[T] (x:list[T]) : list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Tail of a list, abort with match failure if list is empty.
</p></div>
<pre>0261:    <a href="/share/lib/std/datatype/list.fdoc#0261">pure fun head[T] (x:list[T]) : T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Head of a list, abort with match failure if list is empty.
</p></div>
<pre>0271:    <a href="/share/lib/std/datatype/list.fdoc#0271">fun rev_map[T,U] (_f:T->U) (x:list[T]): list[U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> map a list, return mapped list in reverse order (tail rec).
</p></div>
<pre>0272:    <a href="/share/lib/std/datatype/list.fdoc#0272">fun aux (inp:list[T]) (out:list[U]) : list[U]</a></pre>
<pre>0287:    <a href="/share/lib/std/datatype/list.fdoc#0287">fun map[T,U] (_f:T->U) (x:list[T]): list[U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> map a list (tail-rec).
</p></div>
<pre>0298:    <a href="/share/lib/std/datatype/list.fdoc#0298">pure fun rev[T] (x:list[T]):list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> reverse a list (tail rec).
</p></div>
<pre>0299:    <a href="/share/lib/std/datatype/list.fdoc#0299">fun aux (x:list[T]) (y:list[T]) : list[T]</a></pre>
<pre>0316:    <a href="/share/lib/std/datatype/list.fdoc#0316">fun zip2[T1,T2] (l1: list[T1]) (l2: list[T2]) : list[T1 * T2]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Zip two lists into a list of pairs.
 Zips to length of shortest list.
</p></div>
<pre>0318:    <a href="/share/lib/std/datatype/list.fdoc#0318">fun aux (l1: list[T1]) (l2: list[T2]) (acc: list[T1 * T2])</a></pre>
<pre>0332:    <a href="/share/lib/std/datatype/list.fdoc#0332">fun range (low:int, high:int, step:int)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Generate an ordered list of ints between low and high with given step.
 Low included, high not included.
</p></div>
<pre>0334:    <a href="/share/lib/std/datatype/list.fdoc#0334">fun inner(low:int, high:int, step:int, values:list[int])</a></pre>
<pre>0364:    <a href="/share/lib/std/datatype/list.fdoc#0364">fun range (low:int, high:int)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Range with step 1.
</p></div>
<pre>0370:    <a href="/share/lib/std/datatype/list.fdoc#0370">fun range (num:int)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Range from 0 to num (excluded).
</p></div>
<pre>0375:    <a href="/share/lib/std/datatype/list.fdoc#0375">fun join[T] (x:list[T]) (y:list[T]):list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Concatenate two lists.
</p></div>
<pre>0408:    <a href="/share/lib/std/datatype/list.fdoc#0408">noinline fun cat[T] (x:list[list[T]]):list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Concatenate two lists.
 Prepend element to head of list.
 Append element to tail of list (slow!).
 Append element to tail of list (slow!).
 Concatenate all the lists in a list of lists.
</p></div>
<pre>0421:    <a href="/share/lib/std/datatype/list.fdoc#0421">pure fun cat (sep:string) (x:list[string]):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Concatenate all the strings in a list with given separator.
</p></div>
<pre>0434:    <a href="/share/lib/std/datatype/list.fdoc#0434">fun catmap[T] (sep:string) (f:T -> string) (ls: list[T])</a></pre>
<pre>0438:    <a href="/share/lib/std/datatype/list.fdoc#0438">fun strcat[T with Str[T]]  (sep: string) (ls: list[T])</a></pre>
<pre>0442:    <a href="/share/lib/std/datatype/list.fdoc#0442">fun strcat[T with Str[T]]  (ls: list[T])</a></pre>
<pre>0450:    <a href="/share/lib/std/datatype/list.fdoc#0450">fun mem[T] (eq:T -> bool) (xs:list[T]) : bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return true if one value in a list satisfies the predicate.
</p></div>
<pre>0460:    <a href="/share/lib/std/datatype/list.fdoc#0460">fun mem[T, U] (eq:T * U -> bool) (xs:list[T]) (e:U) : bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return true if one value in the list satisfies the relation 
 in the left slot with 
 the given element on the right slot.
</p></div>
<pre>0474:    <a href="/share/lib/std/datatype/list.fdoc#0474">fun find[T] (eq:T -> bool) (xs:list[T]) : opt[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construe a list as a set, imbuing it with a membership
 test, provided the element type has an equality operator.
 return option of the first element in a list satisfying the predicate.
</p></div>
<pre>0485:    <a href="/share/lib/std/datatype/list.fdoc#0485">fun find[T, U] (eq:T * U -> bool) (xs:list[T]) (e:U) : opt[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return option the first value in the list satisfies the relation 
 in the left slot with 
 the given element on the right slot.
</p></div>
<pre>0490:    <a href="/share/lib/std/datatype/list.fdoc#0490">noinline fun filter[T] (P:T -> bool) (x:list[T]) : list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a sub list with elements satisfying the given predicate.
</p></div>
<pre>0492:    <a href="/share/lib/std/datatype/list.fdoc#0492">fun aux (inp:list[T], out: list[T])</a></pre>
<pre>0506:    <a href="/share/lib/std/datatype/list.fdoc#0506">fun prepend_unique[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Push element onto front of list if there isn't one in the
 list already satisfying the relation.
</p></div>
<pre>0512:    <a href="/share/lib/std/datatype/list.fdoc#0512">fun insert_unique[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Attach element to tail of list if there isn't one in the
 list already satisfying the relation.
</p></div>
<pre>0517:    <a href="/share/lib/std/datatype/list.fdoc#0517">fun remove[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Remove all elements from a list satisfying relation.
</p></div>
<pre>0523:    <a href="/share/lib/std/datatype/list.fdoc#0523">noinline fun append_unique[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Attach element to tail of list if there isn't one in the
 list already satisfying the relation (tail-rec).
</p></div>
<pre>0524:    <a href="/share/lib/std/datatype/list.fdoc#0524">fun aux (inp:list[T], out: list[T])</a></pre>
<pre>0537:    <a href="/share/lib/std/datatype/list.fdoc#0537">fun take[T] (k:int) (lst:list[T]) : list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Take the first k elements from a list.
</p></div>
<pre>0549:    <a href="/share/lib/std/datatype/list.fdoc#0549">fun drop[T] (k:int) (lst:list[T]) : list[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Drop the first k elements from a list.
</p></div>
<pre>0562:    <a href="/share/lib/std/datatype/list.fdoc#0562">fun sort[T] (lt:T*T->bool) (x:list[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Sort a list with given less than operator, which must be
 total order. Uses varray sort (which uses STL sort).
</p></div>
<pre>0577:    <a href="/share/lib/std/datatype/list.fdoc#0577">fun sort[T with Tord[T]](x:list[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Sort a list with default total order.
 Uses varray sort (which uses STL sort).
</p></div>
<pre>0581:    <a href="/share/lib/std/datatype/list.fdoc#0581">gen iterator (var xs:list[T]) ()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert a list to a stream.
</p></div>
<pre>0603:    <a href="/share/lib/std/datatype/list.fdoc#0603">noinline fun str (xs:List::list[T])</a></pre>
<hr/><a href="/share/lib/std/datatype/option.flx">datatype/option.flx</a>
<pre>0004:    <a href="/share/lib/std/datatype/option.flx#0004">union opt[T]</a></pre>

<pre>0009:  <a href="/share/lib/std/datatype/option.flx#0009">open class Option</a></pre>
<pre>0012:    <a href="/share/lib/std/datatype/option.flx#0012">fun str (x:opt[T])</a></pre>
<pre>0022:    <a href="/share/lib/std/datatype/option.flx#0022">fun or_else[T] (x:opt[T]) (d:T) : T</a></pre>
<pre>0031:    <a href="/share/lib/std/datatype/option.flx#0031">fun or_else[T] (x:opt[T]) (alt:opt[T]) : opt[T]</a></pre>
<pre>0039:    <a href="/share/lib/std/datatype/option.flx#0039">proc iter[T] (_f:T->void) (x:opt[T])</a></pre>
<pre>0047:    <a href="/share/lib/std/datatype/option.flx#0047">ctor[T] list[T] (x:opt[T])</a></pre>
<pre>0055:    <a href="/share/lib/std/datatype/option.flx#0055">pure fun is_empty[T] : opt[T] -> 2</a></pre>
<pre>0061:    <a href="/share/lib/std/datatype/option.flx#0061">pure fun is_defined[T] : opt[T] -> 2</a></pre>
<pre>0067:    <a href="/share/lib/std/datatype/option.flx#0067">fun get[T] : opt[T] -> T</a></pre>
<pre>0073:    <a href="/share/lib/std/datatype/option.flx#0073">fun map[T,U] (_f:T->U) (x:opt[T]): opt[U]</a></pre>
<pre>0083:    <a href="/share/lib/std/datatype/option.flx#0083">fun filter[T] (P:T -> bool) (x:opt[T]) : opt[T]</a></pre>
<pre>0093:    <a href="/share/lib/std/datatype/option.flx#0093">gen iterator[T] (var x:opt[T]) ()</a></pre>

<pre>0099:  <a href="/share/lib/std/datatype/option.flx#0099">class DefaultValue[T]</a></pre>
<pre>0100:    <a href="/share/lib/std/datatype/option.flx#0100">virtual fun default[T]: 1->T</a></pre>
<pre>0102:    <a href="/share/lib/std/datatype/option.flx#0102">fun or_default[T]  (x:opt[T]) ()</a></pre>
<hr/><a href="/share/lib/std/datatype/ralist.flx">datatype/ralist.flx</a>

<pre>0009:  <a href="/share/lib/std/datatype/ralist.flx#0009">class Ralist</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Purely functional Random Access List.
 Based on design from Okasaki, Purely Functional Datastructures.
 Transcribed from Hongwei Xi's encoding for ATS2 library.
</p><p> An ralist provides O(log N) indexed access and amortised
 O(1) consing. This is roughly the closest thing to
 purely functional array available.
</p></div>
<pre>0013:    <a href="/share/lib/std/datatype/ralist.flx#0013">union pt[a]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Auxilliary data structure.
</p></div>
<pre>0016:    <a href="/share/lib/std/datatype/ralist.flx#0016">union ralist[a]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of an ralist.
</p></div>
<pre>0023:    <a href="/share/lib/std/datatype/ralist.flx#0023">fun ralist_length[a] : ralist[a] -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Length of an ralist.
</p></div>
<pre>0040:    <a href="/share/lib/std/datatype/ralist.flx#0040">fun ralist_cons[a] (x:a, xs: ralist[a])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Cons: new list with extra value at the head.
</p></div>
<pre>0045:    <a href="/share/lib/std/datatype/ralist.flx#0045">fun ralist_empty[a]: ralist[a] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check for an empty list.
</p></div>
<pre>0074:    <a href="/share/lib/std/datatype/ralist.flx#0074">proc ralist_uncons[a] (xs: ralist[a], phd: &a, ptl: &ralist[a])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Proedure to split a non-empty ralist
 into a head element and a tail.
</p></div>
<pre>0084:    <a href="/share/lib/std/datatype/ralist.flx#0084">fun ralist_head[a] (xs: ralist[a]) : a</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Head element of a non-empty ralist.
</p></div>
<pre>0093:    <a href="/share/lib/std/datatype/ralist.flx#0093">fun ralist_tail[a] (xs: ralist[a]) : ralist[a]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Tail list of a non-empty ralist.
</p></div>
<pre>0128:    <a href="/share/lib/std/datatype/ralist.flx#0128">fun ralist_lookup[a] (xs:ralist[a],i:int)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Random access to an ralist. Unchecked.
</p></div>
<pre>0169:    <a href="/share/lib/std/datatype/ralist.flx#0169">fun ralist_update[a] (xs:ralist[a], i:int, x0:a)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a list with the i'th element replaced by x0.
 Index is unchecked.
</p></div>
<pre>0210:    <a href="/share/lib/std/datatype/ralist.flx#0210">proc ralist_foreach[a]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Callback based iteration.
 Apply procedure to each element of the ralist.
</p></div>
<pre>0229:    <a href="/share/lib/std/datatype/ralist.flx#0229">fun str (xx: ralist[a]):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert ralist to a string.
</p></div>
<hr/><a href="/share/lib/std/datatype/sarray.flx">datatype/sarray.flx</a>

<pre>0004:  <a href="/share/lib/std/datatype/sarray.flx#0004">open class Sarray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Unbounded sparse psuedo-array sarray.
 This data type is not a real array because it has no bounds
 and therefore cannot support iteration.
</p></div>
<pre>0010:    <a href="/share/lib/std/datatype/sarray.flx#0010">type sarray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a sarray.
</p></div>
<pre>0013:    <a href="/share/lib/std/datatype/sarray.flx#0013">ctor[T] sarray[T] (dflt:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct an infinite sarray with all values set to the given default.
</p></div>
<pre>0016:    <a href="/share/lib/std/datatype/sarray.flx#0016">fun get[T] (a:sarray[T], i:size) : T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the value at the given position.
</p></div>
<pre>0025:    <a href="/share/lib/std/datatype/sarray.flx#0025">proc set[T] (a:sarray[T], i:size, v:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Set the given value at the given position.
</p></div>
<pre>0048:    <a href="/share/lib/std/datatype/sarray.flx#0048">proc del[T] (a:sarray[T], i:size)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Replace the value at a given position with the default.
</p></div>
<pre>0068:    <a href="/share/lib/std/datatype/sarray.flx#0068">proc pack[T] (a:sarray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pack a sparse array. 
 This is an optimisation with no semantics.
 Reorganises the sarray to reduce memory use and optimise lookup.
</p></div>
<hr/><a href="/share/lib/std/datatype/sexpr.fdoc">datatype/sexpr.fdoc</a>

<pre>0005:  <a href="/share/lib/std/datatype/sexpr.fdoc#0005">class S_expr</a></pre>
<pre>0007:    <a href="/share/lib/std/datatype/sexpr.fdoc#0007">union sexpr[T]</a></pre>
<pre>0009:    <a href="/share/lib/std/datatype/sexpr.fdoc#0009">fun fold_left[T,U] (_f:U->T->U) (init:U) (x:sexpr[T]):U</a></pre>
<pre>0015:    <a href="/share/lib/std/datatype/sexpr.fdoc#0015">proc iter[T] (_f:T->void) (x:sexpr[T])</a></pre>
<pre>0022:    <a href="/share/lib/std/datatype/sexpr.fdoc#0022">fun map[T,U] (_f:T->U) (x:sexpr[T]):sexpr[U]</a></pre>
<hr/><a href="/share/lib/std/datatype/slice.flx">datatype/slice.flx</a>
<pre>0002:    <a href="/share/lib/std/datatype/slice.flx#0002">union slice[T]</a></pre>
<pre>0010:    <a href="/share/lib/std/datatype/slice.flx#0010">gen slice_range[T with Integer[T]] (first:T) (last:T) ()</a></pre>
<pre>0015:    <a href="/share/lib/std/datatype/slice.flx#0015">gen iterator[t] (f:1->opt[t])</a></pre>
<pre>0030:    <a href="/share/lib/std/datatype/slice.flx#0030">fun cal_slice (n:int, var b:int, var e:int)</a></pre>
<hr/><a href="/share/lib/std/datatype/sort.flx">datatype/sort.flx</a>

<pre>0002:  <a href="/share/lib/std/datatype/sort.flx#0002">class Sort</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Utility class to leverage STL sort.
</p></div>
<pre>0009:    <a href="/share/lib/std/datatype/sort.flx#0009">struct comparator</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> STL compliant comparator object built from
 a closure of a Felix function.
</p></div>
<pre>0021:    <a href="/share/lib/std/datatype/sort.flx#0021">type stl_comparator[T]</a></pre>
<pre>0028:    <a href="/share/lib/std/datatype/sort.flx#0028">ctor[T] stl_comparator[T] (cmp:T * T -> bool)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make a C++ STL comparator object from a Felix comparison function.
</p></div>
<pre>0033:    <a href="/share/lib/std/datatype/sort.flx#0033">proc stl_sort[T]: stl_comparator[T] * +T * +T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke stl sort with C++ comparator.
</p></div>
<pre>0037:    <a href="/share/lib/std/datatype/sort.flx#0037">inline proc stl_sort[T] (cmp: T * T -> bool, b: +T,  e:+T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke stl sort with Felix comparison function.
</p></div>
<pre>0042:    <a href="/share/lib/std/datatype/sort.flx#0042">inline proc stl_sort[T with Tord[T]] (b:+T, e:+T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke stl sort default comparison function.
</p></div>
<hr/><a href="/share/lib/std/datatype/strdict.flx">datatype/strdict.flx</a>

<pre>0014:  <a href="/share/lib/std/datatype/strdict.flx#0014">class StrDict[T]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> A strdict is dictionary keyed by strings.
 The strings must not contain nul bytes.
</p><p> This is an ultra high performance data structure
 implemented using a JudySLArray.
 Typically about the same speed as a hashtable on exact key retrieval,
 but with the ability to perform linear key seeking as well.
 Linear seeking means searching for a key satisfying one of the total
 ordering relations to a given key, including ordered iteration.
</p><p> Scales to terabytes.
 No other data structure can do this.
</p></div>
<pre>0018:    <a href="/share/lib/std/datatype/strdict.flx#0018">type strdict</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a strdict.
</p></div>
<pre>0021:    <a href="/share/lib/std/datatype/strdict.flx#0021">ctor strdict()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct and empty dictionary.
</p></div>
<pre>0023:    <a href="/share/lib/std/datatype/strdict.flx#0023">proc add (x:strdict) (key:string) (value: T)</a></pre>
<pre>0031:    <a href="/share/lib/std/datatype/strdict.flx#0031">ctor strdict ( kv: list[string * T] )</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a dictionary from a list of pairs.
</p></div>
<pre>0039:    <a href="/share/lib/std/datatype/strdict.flx#0039">fun get (x:strdict) (key: string) : opt[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch a value optionally using the given key.
</p></div>
<pre>0047:    <a href="/share/lib/std/datatype/strdict.flx#0047">fun haskey (x:strdict) (key: string) : bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if value is in the dictionary.
</p></div>
<pre>0059:    <a href="/share/lib/std/datatype/strdict.flx#0059">fun get_dflt (x:strdict) (key:string, dflt:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch a value using the given key.
 If there is no value in the dictionary with that key,
 then return a default value.
</p></div>
<pre>0068:    <a href="/share/lib/std/datatype/strdict.flx#0068">gen del (x:strdict) (key: string) : bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Remove a key/value pair from the dictionary if it exists.
 Return a boolean value signalling if it existed. 
</p></div>
<pre>0077:    <a href="/share/lib/std/datatype/strdict.flx#0077">gen charp_get_ge (x:strdict) (var key: +char) : opt[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key greater than or equal to
 the supplied NTBS (unsafe!)
</p></div>
<pre>0091:    <a href="/share/lib/std/datatype/strdict.flx#0091">fun get_ge (x:strdict) (var key: string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key greater than or equal to
 the supplied string. Safer than the NTBS version but slower. 
 Fails if the string contains a nul byte.
</p></div>
<pre>0110:    <a href="/share/lib/std/datatype/strdict.flx#0110">gen charp_get_gt (x:strdict) (var key: +char)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key greater than  (>)
 the supplied NTBS (unsafe!)
</p></div>
<pre>0124:    <a href="/share/lib/std/datatype/strdict.flx#0124">fun get_gt (x:strdict) (var key: string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key greater than (>) 
 the supplied string. Safer than the NTBS version but slower. 
 Fails if the string contains a nul byte.
</p></div>
<pre>0143:    <a href="/share/lib/std/datatype/strdict.flx#0143">gen charp_get_le (x:strdict) (var key: +char)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key less than or equal to (<=)
 the supplied NTBS (unsafe!)
</p></div>
<pre>0157:    <a href="/share/lib/std/datatype/strdict.flx#0157">fun get_le (x:strdict) (var key: string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key less than or equal to (<=)
 the supplied string. Safer than the NTBS version but slower. 
 Fails if the string contains a nul byte.
</p></div>
<pre>0176:    <a href="/share/lib/std/datatype/strdict.flx#0176">gen charp_get_lt (x:strdict) (var key: +char)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key less than (<)
 the supplied NTBS (unsafe!)
</p></div>
<pre>0190:    <a href="/share/lib/std/datatype/strdict.flx#0190">fun get_lt (x:strdict) (var key: string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key less than (<)
 the supplied string. Safer than the NTBS version but slower. 
 Fails if the string contains a nul byte.
</p></div>
<pre>0209:    <a href="/share/lib/std/datatype/strdict.flx#0209">gen charp_first (x:strdict) (buffer:+char)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the optional first key in the dictionary into
 the supplied NTBS (unsafe!)
</p></div>
<pre>0215:    <a href="/share/lib/std/datatype/strdict.flx#0215">fun first (x:strdict) : opt[string * T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the optional first key in the dictionary.
</p></div>
<pre>0220:    <a href="/share/lib/std/datatype/strdict.flx#0220">gen iterator (x:strdict) () : opt[string * T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Stream iterator scanning through all key value pairs
 in the dictionary, in key order.
</p></div>
<pre>0236:    <a href="/share/lib/std/datatype/strdict.flx#0236">fun str(var x:strdict) : string</a></pre>
<hr/><a href="/share/lib/std/datatype/tuple.flx">datatype/tuple.flx</a>

<pre>0005:  <a href="/share/lib/std/datatype/tuple.flx#0005">class Tuple[U]</a></pre>
<pre>0006:    <a href="/share/lib/std/datatype/tuple.flx#0006">virtual fun tuple_str (x:U)</a></pre>
<pre>0010:    <a href="/share/lib/std/datatype/tuple.flx#0010">fun tuple_str (x: U ** V)</a></pre>
<pre>0018:    <a href="/share/lib/std/datatype/tuple.flx#0018">fun tuple_str (x: U * V)</a></pre>
<pre>0027:    <a href="/share/lib/std/datatype/tuple.flx#0027">fun str (x: U ** V)</a></pre>
<pre>0031:    <a href="/share/lib/std/datatype/tuple.flx#0031">fun str (t:T, u:U)</a></pre>
<pre>0034:    <a href="/share/lib/std/datatype/tuple.flx#0034">fun str (t1:T, t2:T)</a></pre>
<pre>0087:    <a href="/share/lib/std/datatype/tuple.flx#0087">fun field[n,t,u where n</a></pre>
<pre>0088:    <a href="/share/lib/std/datatype/tuple.flx#0088">fun field[n,t,u where n</a></pre>
<pre>0090:    <a href="/share/lib/std/datatype/tuple.flx#0090">fun field[n,t,u,v where n</a></pre>
<pre>0091:    <a href="/share/lib/std/datatype/tuple.flx#0091">fun field[n,t,u,v where n</a></pre>
<pre>0092:    <a href="/share/lib/std/datatype/tuple.flx#0092">fun field[n,t,u,v where n</a></pre>
<pre>0094:    <a href="/share/lib/std/datatype/tuple.flx#0094">fun field[n,t,u,v,w where n</a></pre>
<pre>0095:    <a href="/share/lib/std/datatype/tuple.flx#0095">fun field[n,t,u,v,w where n</a></pre>
<pre>0096:    <a href="/share/lib/std/datatype/tuple.flx#0096">fun field[n,t,u,v,w where n</a></pre>
<pre>0097:    <a href="/share/lib/std/datatype/tuple.flx#0097">fun field[n,t,u,v,w where n</a></pre>
<pre>0099:    <a href="/share/lib/std/datatype/tuple.flx#0099">fun field[n,t,u,v,w,x where n</a></pre>
<pre>0100:    <a href="/share/lib/std/datatype/tuple.flx#0100">fun field[n,t,u,v,w,x where n</a></pre>
<pre>0101:    <a href="/share/lib/std/datatype/tuple.flx#0101">fun field[n,t,u,v,w,x where n</a></pre>
<pre>0102:    <a href="/share/lib/std/datatype/tuple.flx#0102">fun field[n,t,u,v,w,x where n</a></pre>
<pre>0103:    <a href="/share/lib/std/datatype/tuple.flx#0103">fun field[n,t,u,v,w,x where n</a></pre>
<hr/><a href="/share/lib/std/datatype/unitsum.fdoc">datatype/unitsum.fdoc</a>
<pre>0005:    <a href="/share/lib/std/datatype/unitsum.fdoc#0005">typedef unitsums</a></pre>
<pre>0012:    <a href="/share/lib/std/datatype/unitsum.fdoc#0012">fun zero ()</a></pre>
<pre>0019:    <a href="/share/lib/std/datatype/unitsum.fdoc#0019">fun str(x:T)</a></pre>
<hr/><a href="/share/lib/std/datatype/varray.flx">datatype/varray.flx</a>

<pre>0003:  <a href="/share/lib/std/datatype/varray.flx#0003">open class Varray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Bounded Variable length arrays, bound set at construction time.
</p></div>
<pre>0010:    <a href="/share/lib/std/datatype/varray.flx#0010">ctor[t] carray[t] : varray[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A varray is just a pointer. 
 The current length and bound are maintained by the GC.
 An ordinary carray, but owned by the GC.
</p></div>
<pre>0013:    <a href="/share/lib/std/datatype/varray.flx#0013">ctor[t] varray[t]: size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create an empty varray with the given bound.
</p></div>
<pre>0023:    <a href="/share/lib/std/datatype/varray.flx#0023">ctor[t] varray[t] (bound:size, default:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Raw memory initialisation (really, this belongs in C_hack).
 Construct a varray filled up with a default value.
</p></div>
<pre>0032:    <a href="/share/lib/std/datatype/varray.flx#0032">ctor[t] varray[t] (bound:size, used:size, f:size->t when used <</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a partially filled varray with a default value computed by a function.
</p></div>
<pre>0042:    <a href="/share/lib/std/datatype/varray.flx#0042">ctor[t,N] varray[t] (x:array[t,N])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a full varray from an array.
</p></div>
<pre>0047:    <a href="/share/lib/std/datatype/varray.flx#0047">ctor[t] varray[t] (x:varray[t], maxlen:size)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a partially full varray from a varray.
</p></div>
<pre>0052:    <a href="/share/lib/std/datatype/varray.flx#0052">ctor[t] varray[t] (x:varray[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a full varray from a varray (copy constructor).
</p></div>
<pre>0057:    <a href="/share/lib/std/datatype/varray.flx#0057">ctor[t] varray[t] (x:list[t])</a></pre>
<pre>0066:    <a href="/share/lib/std/datatype/varray.flx#0066">ctor varray[char] (var x:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a varray from a string.
 Include a trailing nul byte.
</p></div>
<pre>0084:    <a href="/share/lib/std/datatype/varray.flx#0084">fun len: varray[v] -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Treat a varray as an ArrayValue.
 Length of a varray (used).
</p></div>
<pre>0089:    <a href="/share/lib/std/datatype/varray.flx#0089">fun unsafe_get: varray[v] * size -> v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Unsafe get value at position.
</p></div>
<pre>0096:    <a href="/share/lib/std/datatype/varray.flx#0096">proc unsafe_set: varray[v] * size * v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Treat a varray as an ArrayObject.
 Allows modifications.
 Store the given value at the given position.
</p></div>
<pre>0097:    <a href="/share/lib/std/datatype/varray.flx#0097">fun unsafe_get_ref: varray[v] * size -> &v</a></pre>
<pre>0103:    <a href="/share/lib/std/datatype/varray.flx#0103">fun stl_begin: varray[v] -> +v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Treat a varray as a ContiguousArrayObject.
 STL iterator to start of array.
</p></div>
<pre>0106:    <a href="/share/lib/std/datatype/varray.flx#0106">fun stl_end: varray[v] -> +v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> STL iterator to end of array.
</p></div>
<pre>0110:    <a href="/share/lib/std/datatype/varray.flx#0110">fun maxlen[t]: varray[t] -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the bound of a varray.
</p></div>
<pre>0121:    <a href="/share/lib/std/datatype/varray.flx#0121">proc push_back[t] : varray[t] * t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Append a new element to the end of a varray.
 Aborts if you go past the bound.
 Append a new element to the end of a varray.
 Aborts if you go past the bound.
</p></div>
<pre>0134:    <a href="/share/lib/std/datatype/varray.flx#0134">proc pop[t] : varray[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pop an element off the end of a varray.
 Aborts if the array is empty.
</p></div>
<pre>0148:    <a href="/share/lib/std/datatype/varray.flx#0148">proc erase[v] (a:varray[v], first:int, last:int)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Erase elements of array between and including first and last.
 Include first and last, intersect with array span.
 Cannot fail.
</p></div>
<pre>0168:    <a href="/share/lib/std/datatype/varray.flx#0168">proc erase[v] (a:varray[v], i:int)</a></pre>
<pre>0177:    <a href="/share/lib/std/datatype/varray.flx#0177">proc insert[t] (a:varray[t], i:int, v:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> insert (a,i,v) inserts v in a at position i
 that is, inserts before element i.
 If i is negative, position relative to end,
 that is, -1 is last element, so insert (a,-1,v)
 inserts before the last element (not after!)
 If i equals the length, element is appended.
 If the index is out of range, nothing happens.
</p></div>
<pre>0200:    <a href="/share/lib/std/datatype/varray.flx#0200">fun map[T, U] (_f:T->U) (x:varray[T]): varray[U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Traditional map varray to varray.
</p></div>
<pre>0214:    <a href="/share/lib/std/datatype/varray.flx#0214">fun str (xs:varray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert a varray[T] to a string.
 Requires Show[T]
</p></div>
<hr/><a href="/share/lib/std/db/__init__.flx">db/__init__.flx</a>
<hr/><a href="/share/lib/std/db/sqlite3/__init__.flx">db/sqlite3/__init__.flx</a>
<hr/><a href="/share/lib/std/db/sqlite3/sqlite3.flx">db/sqlite3/sqlite3.flx</a>

<pre>0039:  <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0039">class Sqlite3</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Core Sqlite3 functions and extensions to provide row iterator, simple statement execution, 
 statement preperation and access to sqlite_step statement execution.
</p><p> Iterator example:
 
</p><p><pre class='flxbg'>   <span class="big_keyword" title="Define a mutable variable">var</span> db : sqlite3_db_t;
   <span class="big_keyword" title="Define a mutable variable">var</span> stmt:sqlite3_stmt_t;
   <span class="big_keyword" title="Define a mutable variable">var</span> err = sqlite3_open(<span class="fstring">"multiple_sa.db"</span>, &amp;db);
   <span class="small_keyword" title="conditional">if</span> err != 0 <span class="small_keyword" title="imperative code begins">do</span>
     <span class="library" title="Print a string to standard output">print</span> <span class="fstring">"open DB error[abort] "</span>;
     <span class="library" title="Print a string to standard output with newline appended">println</span> $ sqlite3_errmsg db;
     <span class="small_keyword" title="jump to label">goto</span> finish;
   <span class="small_keyword" title="end of body">done</span>;
   err = sqlite3_prepare_v2(db, <span class="fstring">"select * from contact"</span>, 21, stmt, <span class="fstring">""</span>);
   <span class="small_keyword" title="conditional">if</span> not err == (caseno SQLITE_OK) <span class="small_keyword" title="conditional">then</span>
     { <span class="library" title="Print a string to standard output with newline appended">println</span> (<span class="fstring">"sql error "</span>+<span class="library" title="Convert a value to a string">str</span>(err)+<span class="fstring">":"</span>+sqlite3_errmsg(db));<span class="small_keyword" title="jump to label">goto</span> finish; }
   <span class="small_keyword" title="conditional">else</span> {
     <span class="big_keyword" title="Define a mutable variable">var</span> it = sqlite3_row_iterator (stmt);
     <span class="big_keyword" title="Define a mutable variable">var</span> row:ret_val[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[column_value]];
     <span class="small_keyword" title="while loop">while</span> (<span class="big_keyword" title="Define a function with no side-effects">fun</span> ():bool = { row = it();
                <span class="small_keyword" title="return">return</span> (<span class="small_keyword" title="match statement or expression">match</span> row <span class="small_keyword" title="type-class constraint">with</span> |end_of_results[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[column_value]] =&gt;false |_ =&gt; true
                <span class="small_keyword" title="end a match statement or expression">endmatch</span>); }) () <span class="small_keyword" title="imperative code begins">do</span>
     <span class="big_keyword" title="Define a mutable variable">var</span> t = <span class="small_keyword" title="match statement or expression">match</span> row <span class="small_keyword" title="type-class constraint">with</span> 
       | row ?a =&gt;  ((get_text_val(get(a,0))),(get_text_val(get(a,1))))
       | _ =&gt; (<span class="fstring">""</span>,<span class="fstring">""</span>)
     <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
     <span class="library" title="Print a string to standard output">print</span> t; endl;
     <span class="small_keyword" title="end of body">done</span>
   }
   finish:&gt;
     err = sqlite3_finalize(stmt);
     <span class="library" title="Print a string to standard output with newline appended">println</span>(<span class="library" title="Convert a value to a string">str</span>(err));
     sqlite3_close(db);
</pre></p></div>
<pre>0043:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0043">type sqlite3_db_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a database handle.
</p></div>
<pre>0046:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0046">gen sqlite3_open : string * &sqlite3_db_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Database open.
</p></div>
<pre>0051:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0051">proc sqlite3_close : sqlite3_db_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Database close.
</p></div>
<pre>0054:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0054">typedef sqlite3_exec_callback_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of an exec callback.
</p></div>
<pre>0069:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0069">gen sqlite3_exec : sqlite3_db_t * string * sqlite3_exec_callback_t * address * &(+char) -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Quick sql execution using callback.
 arg1: db_handle
 arg2: sql statement.
 arg3: callback function.
 arg4: client data pointer.
 arg5: pointer to error message array.
 result: error code.
</p></div>
<pre>0077:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0077">gen sqlite3_exec : sqlite3_db_t * string   * &(+char) -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> quick sql execution without data handler callback.
 arg1: db_handle
 arg2: sql statement.
 arg3: pointer to error message array.
</p></div>
<pre>0083:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0083">gen sqlite3_errmsg : sqlite3_db_t -> +char</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Error message extractor.
</p></div>
<pre>0088:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0088">type sqlite3_stmt_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of sql statement handle.
</p></div>
<pre>0125:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0125">fun to_sqlite3_result_code: int -> sqlite3_result_codes</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Sqlite3 return codes.
 Conversion from int result to named return codes.
</p></div>
<pre>0174:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0174">fun to_sqlite3_type: int -> sqlite3_types</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Tag names for Sqlite3 data types.
 Allow checking for specific return codes.
 Conversion from int type to named Sqlite3 data type.
</p></div>
<pre>0184:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0184">gen sqlite3_prepare_v2: sqlite3_db_t * string * int * sqlite3_stmt_t *string -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Prepare an sqlite3 statement for execution.
</p></div>
<pre>0188:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0188">noinline gen sqlite3_step: sqlite3_stmt_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Execute one step of the prepared statement.
</p></div>
<pre>0191:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0191">gen sqlite3_column_count: sqlite3_stmt_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Determine the number of columns (field) a statement will process.
</p></div>
<pre>0194:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0194">gen sqlite3_column_name: sqlite3_stmt_t*int -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Determine the name of the n'th column to be processed.
</p></div>
<pre>0197:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0197">gen sqlite3_column_type: sqlite3_stmt_t*int->int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Determine the type of the n'th column to be processed.
</p></div>
<pre>0200:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0200">gen sqlite3_column_text: sqlite3_stmt_t*int->string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the value of a text field.
</p></div>
<pre>0203:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0203">gen sqlite3_column_double: sqlite3_stmt_t*int->double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the value of a double field.
</p></div>
<pre>0206:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0206">gen sqlite3_column_int: sqlite3_stmt_t*int->int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the value of a int field.
</p></div>
<pre>0209:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0209">gen sqlite3_column_blob: sqlite3_stmt_t*int->&byte</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the value of a blob field.
</p></div>
<pre>0212:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0212">gen sqlite3_column_bytes: sqlite3_stmt_t*int -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the number of bytes of a field.
</p></div>
<pre>0217:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0217">gen sqlite3_finalize: sqlite3_stmt_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Finish up with stepping a statement.
 Releases associated resources.
 The statement handle becomes invalid afterwards.
</p></div>
<pre>0220:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0220">union column_value</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A unified type to fetch a field value.
</p></div>
<pre>0228:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0228">union ret_val[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A unified result of a statement.
</p></div>
<pre>0234:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0234">union result_code[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A unified result code.
</p></div>
<pre>0239:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0239">fun sqlite3_prepare_stmt (db:sqlite3_db_t,query:string):result_code[sqlite3_stmt_t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Unified preparation of a query.
</p></div>
<pre>0249:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0249">fun sqlite3_get_columns (stmt:sqlite3_stmt_t):darray[column_value]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch all the columns of a query at once.
 Return them in a darray.
</p></div>
<pre>0268:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0268">gen sqlite3_row_iterator (stmt:sqlite3_stmt_t) () :ret_val[darray[column_value]]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A stream iterator which returns successive rows of a table.
</p></div>
<pre>0285:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0285">fun get_int_val: column_value->int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the int value out of a int typed field.
 Throws match failure if the field isn't an int type.
</p></div>
<pre>0289:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0289">fun get_double_val:  column_value->double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the double value out of a double typed field.
 Throws match failure if the field isn't a double type.
</p></div>
<pre>0293:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0293">fun get_text_val:  column_value->string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the text value out of a text typed field.
 Throws match failure if the field isn't a text type.
</p></div>
<pre>0296:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0296">fun get_stmt: result_code[sqlite3_stmt_t]-> sqlite3_stmt_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the statement handle out of a return code.
</p></div>
<pre>0299:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0299">gen get_next ( iter:()->ret_val[darray[column_value]],row:&ret_val[darray[column_value]]):bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the next row from an row iterator.
</p></div>
<pre>0309:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0309">gen sqlite3_execute (stmt:sqlite3_stmt_t) :bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Execute an prepared statement.
</p></div>
<pre>0329:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0329">gen sqlite3_quote: string->string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Quote a string for use in a query.
</p></div>
<pre>0376:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0376">typename lpar number rpar |</a></pre>
<pre>0377:    <a href="/share/lib/std/db/sqlite3/sqlite3.flx#0377">typename lpar number , number rpar</a></pre>
<hr/><a href="/share/lib/std/db/sqlite3/sqlite3_pool.flx">db/sqlite3/sqlite3_pool.flx</a>

<pre>0003:  <a href="/share/lib/std/db/sqlite3/sqlite3_pool.flx#0003">class Sqlite3Pool</a></pre>
<pre>0010:    <a href="/share/lib/std/db/sqlite3/sqlite3_pool.flx#0010">fun sqlite3_pool(db_file:string):pool</a></pre>
<pre>0024:    <a href="/share/lib/std/db/sqlite3/sqlite3_pool.flx#0024">proc destroy_member (m:sqlite3_db_t)</a></pre>
<hr/><a href="/share/lib/std/debug.flx">debug.flx</a>
<pre>0003:    <a href="/share/lib/std/debug.flx#0003">type flx_location_t</a></pre>

<pre>0005:  <a href="/share/lib/std/debug.flx#0005">class Debug</a></pre>
<pre>0012:    <a href="/share/lib/std/debug.flx#0012">fun filename: flx_location_t -> +char</a></pre>
<pre>0013:    <a href="/share/lib/std/debug.flx#0013">fun startline: flx_location_t -> int</a></pre>
<pre>0014:    <a href="/share/lib/std/debug.flx#0014">fun startcol: flx_location_t -> int</a></pre>
<pre>0015:    <a href="/share/lib/std/debug.flx#0015">fun endline: flx_location_t -> int</a></pre>
<pre>0016:    <a href="/share/lib/std/debug.flx#0016">fun endcol: flx_location_t -> int</a></pre>
<pre>0019:    <a href="/share/lib/std/debug.flx#0019">fun str(var x:flx_location_t)</a></pre>
<pre>0030:    <a href="/share/lib/std/debug.flx#0030">fun repr_expr[t]: t -> string</a></pre>
<hr/><a href="/share/lib/std/felix/__init__.flx">felix/__init__.flx</a>
<hr/><a href="/share/lib/std/felix/cident.flx">felix/cident.flx</a>

<pre>0005:  <a href="/share/lib/std/felix/cident.flx#0005">class Cident</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> A function to convert a byte string into a
 legal C identifier in a canonical way.
 This routine should match the Ocaml function Flx_name.flxid_to_cid.
</p></div>
<pre>0010:    <a href="/share/lib/std/felix/cident.flx#0010">fun basename : string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Basename of a filename. Hacky, not the real thing.
 Enough for calculating module names hopefully.
 Treats / and \ as path separators.
</p></div>
<pre>0015:    <a href="/share/lib/std/felix/cident.flx#0015">fun chop_extension : string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Chop extension of a filename. Hacky, not the real thing.
 Enough for calculating module names hopefully.
 Treats / and \ as path separators.
</p></div>
<pre>0020:    <a href="/share/lib/std/felix/cident.flx#0020">fun flxid_to_cid : string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert a "normal enough" Felix identifier to a C identifier.
 Does canonical replacement of chars illegal in C identifiers.
 Hacky, only supports ASCII, doesn't support i18n.
</p></div>
<pre>0025:    <a href="/share/lib/std/felix/cident.flx#0025">fun filename_to_modulename : string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert a "normal enough" filename to a modulename.
 Uses all the above hacky stuff.
 Just please use sensible ASCII filenames!
</p></div>
<hr/><a href="/share/lib/std/felix/config.flx">felix/config.flx</a>

<pre>0006:  <a href="/share/lib/std/felix/config.flx#0006">class Config</a></pre>
<pre>0007:    <a href="/share/lib/std/felix/config.flx#0007">typedef config_type</a></pre>
<pre>0020:    <a href="/share/lib/std/felix/config.flx#0020">fun str (x:config_type) : string</a></pre>
<pre>0033:    <a href="/share/lib/std/felix/config.flx#0033">fun empty_config() :config_type</a></pre>
<pre>0047:    <a href="/share/lib/std/felix/config.flx#0047">proc cascade_FLX_INSTALL_DIR (x: &config_type)  (y: string)</a></pre>
<pre>0052:    <a href="/share/lib/std/felix/config.flx#0052">proc cascade_FLX_TARGET_DIR (x: &config_type)  (y: string)</a></pre>
<pre>0057:    <a href="/share/lib/std/felix/config.flx#0057">proc cascade_FLX_SHARE_DIR (x: &config_type)  (y: string)</a></pre>
<pre>0061:    <a href="/share/lib/std/felix/config.flx#0061">proc cascade_FLX_HOME_DIR (x: &config_type)  (y: string)</a></pre>
<pre>0068:    <a href="/share/lib/std/felix/config.flx#0068">proc process_config_text (cfg:&config_type) (text:string)</a></pre>
<pre>0110:    <a href="/share/lib/std/felix/config.flx#0110">fun config () : config_type</a></pre>
<pre>0148:    <a href="/share/lib/std/felix/config.flx#0148">process_config_text &cfg text</a></pre>
<hr/><a href="/share/lib/std/felix/flx/bootflx.flx">felix/flx/bootflx.flx</a>

<pre>0029:  <a href="/share/lib/std/felix/flx/bootflx.flx#0029">class BootFlx</a></pre>
<pre>0031:    <a href="/share/lib/std/felix/flx/bootflx.flx#0031">gen flx_processing</a></pre>
<pre>0124:    <a href="/share/lib/std/felix/flx/bootflx.flx#0124">gen runflx(args:list[string]) : int</a></pre>
<hr/><a href="/share/lib/std/felix/flx/flx.flx">felix/flx/flx.flx</a>

<pre>0021:  <a href="/share/lib/std/felix/flx/flx.flx#0021">class Flx</a></pre>
<pre>0023:    <a href="/share/lib/std/felix/flx/flx.flx#0023">gen flx_processing</a></pre>
<pre>0120:    <a href="/share/lib/std/felix/flx/flx.flx#0120">gen runflx(args:list[string]) : int</a></pre>
<hr/><a href="/share/lib/std/felix/flx/flx_cmdopt.flx">felix/flx/flx_cmdopt.flx</a>

<pre>0006:  <a href="/share/lib/std/felix/flx/flx_cmdopt.flx#0006">class FlxCmdOpt</a></pre>
<pre>0117:    <a href="/share/lib/std/felix/flx/flx_cmdopt.flx#0117">proc setup-from-file (debugln: string -> 0)</a></pre>
<pre>0185:    <a href="/share/lib/std/felix/flx/flx_cmdopt.flx#0185">proc debugln[T with Str[T]] (x:T)</a></pre>
<pre>0544:    <a href="/share/lib/std/felix/flx/flx_cmdopt.flx#0544">proc debugln[T with Str[T]] (x:T)</a></pre>
<pre>0626:    <a href="/share/lib/std/felix/flx/flx_cmdopt.flx#0626">noinline proc processing_stage1</a></pre>
<pre>0636:    <a href="/share/lib/std/felix/flx/flx_cmdopt.flx#0636">proc debugln[T with Str[T]] (x:T)</a></pre>
<pre>0728:    <a href="/share/lib/std/felix/flx/flx_cmdopt.flx#0728">fun link_strings ()</a></pre>
<pre>0750:    <a href="/share/lib/std/felix/flx/flx_cmdopt.flx#0750">fun mkrel (d:string, f:string)</a></pre>
<hr/><a href="/share/lib/std/felix/flx/flx_config.flx">felix/flx/flx_config.flx</a>

<pre>0003:  <a href="/share/lib/std/felix/flx/flx_config.flx#0003">class FlxConfig</a></pre>
<pre>0005:    <a href="/share/lib/std/felix/flx/flx_config.flx#0005">proc print_config(config:Config::config_type)</a></pre>
<hr/><a href="/share/lib/std/felix/flx/flx_control.flx">felix/flx/flx_control.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/flx/flx_control.flx#0001">class FlxControl</a></pre>
<pre>0003:    <a href="/share/lib/std/felix/flx/flx_control.flx#0003">proc print_options(control:control_type)</a></pre>
<pre>0038:    <a href="/share/lib/std/felix/flx/flx_control.flx#0038">fun init_loopctl ()</a></pre>
<pre>0048:    <a href="/share/lib/std/felix/flx/flx_control.flx#0048">typedef loopctl_type</a></pre>
<pre>0050:    <a href="/share/lib/std/felix/flx/flx_control.flx#0050">fun dflt_control (config:Config::config_type)</a></pre>
<pre>0138:    <a href="/share/lib/std/felix/flx/flx_control.flx#0138">typedef control_type</a></pre>
<hr/><a href="/share/lib/std/felix/flx/flx_depchk.flx">felix/flx/flx_depchk.flx</a>
<pre>0003:    <a href="/share/lib/std/felix/flx/flx_depchk.flx#0003">gen cxx_depcheck (tc: toolchain_t, src:string, dst:string) : bool</a></pre>
<pre>0018:    <a href="/share/lib/std/felix/flx/flx_depchk.flx#0018">fun maxf (t:double) (f:string)</a></pre>
<pre>0047:    <a href="/share/lib/std/felix/flx/flx_depchk.flx#0047">gen c_depcheck (tc: toolchain_t, src:string, dst:string) : bool</a></pre>
<pre>0062:    <a href="/share/lib/std/felix/flx/flx_depchk.flx#0062">fun maxf (t:double) (f:string)</a></pre>
<hr/><a href="/share/lib/std/felix/flx/flx_depvars.flx">felix/flx/flx_depvars.flx</a>

<pre>0003:  <a href="/share/lib/std/felix/flx/flx_depvars.flx#0003">class FlxDepvars</a></pre>
<pre>0005:    <a href="/share/lib/std/felix/flx/flx_depvars.flx#0005">typedef dvars_type</a></pre>
<pre>0021:    <a href="/share/lib/std/felix/flx/flx_depvars.flx#0021">gen cal_depvars(</a></pre>
<pre>0029:    <a href="/share/lib/std/felix/flx/flx_depvars.flx#0029">proc debugln[T with Str[T]] (x:T)</a></pre>
<hr/><a href="/share/lib/std/felix/flx/flx_plugin_client.flx">felix/flx/flx_plugin_client.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/flx/flx_plugin_client.flx#0001">class Flx_client</a></pre>
<pre>0003:    <a href="/share/lib/std/felix/flx/flx_plugin_client.flx#0003">proc setup ()</a></pre>
<hr/><a href="/share/lib/std/felix/flx/flx_run.flx">felix/flx/flx_run.flx</a>
<pre>0005:    <a href="/share/lib/std/felix/flx/flx_run.flx#0005">gen dxqt(DBG:bool) (cmd:string)</a></pre>
<pre>0027:    <a href="/share/lib/std/felix/flx/flx_run.flx#0027">proc xdebugln[T with Str[T]] (d:bool) (x:T)</a></pre>
<pre>0032:    <a href="/share/lib/std/felix/flx/flx_run.flx#0032">proc check_cache(</a></pre>
<pre>0058:    <a href="/share/lib/std/felix/flx/flx_run.flx#0058">proc debugln[T with Str[T]] (x:T)</a></pre>
<pre>0062:    <a href="/share/lib/std/felix/flx/flx_run.flx#0062">proc echoln[T with Str[T]] (x:T)</a></pre>
<pre>0076:    <a href="/share/lib/std/felix/flx/flx_run.flx#0076">proc showtime(msg:string, t0:double)</a></pre>
<pre>0106:    <a href="/share/lib/std/felix/flx/flx_run.flx#0106">proc calpackages</a></pre>
<pre>0137:    <a href="/share/lib/std/felix/flx/flx_run.flx#0137">fun cal_time_from_flxdepfile (debugln: string->0, df: string):double</a></pre>
<pre>0139:    <a href="/share/lib/std/felix/flx/flx_run.flx#0139">fun maxf (x: double) (f:string)</a></pre>
<pre>0151:    <a href="/share/lib/std/felix/flx/flx_run.flx#0151">fun cal_files_time (fs: list[string])</a></pre>
<pre>0164:    <a href="/share/lib/std/felix/flx/flx_run.flx#0164">fun cal_cxx_uptodate(debugln:string -> 0, OUTPUT_DIR:string, f:string)</a></pre>
<pre>0182:    <a href="/share/lib/std/felix/flx/flx_run.flx#0182">gen check_cxx_uptodate () : bool</a></pre>
<pre>0197:    <a href="/share/lib/std/felix/flx/flx_run.flx#0197">gen run_felix_compiler_if_required () : int</a></pre>
<pre>0264:    <a href="/share/lib/std/felix/flx/flx_run.flx#0264">gen cxx_compile_dynamic1(src:string, dst:string) : int</a></pre>
<pre>0288:    <a href="/share/lib/std/felix/flx/flx_run.flx#0288">gen cxx_compile_dynamic () : int</a></pre>
<pre>0311:    <a href="/share/lib/std/felix/flx/flx_run.flx#0311">gen cxx_compile_static () : int</a></pre>
<pre>0356:    <a href="/share/lib/std/felix/flx/flx_run.flx#0356">gen cxx_compile_static1 (src: string, dst: string) : int</a></pre>
<pre>0384:    <a href="/share/lib/std/felix/flx/flx_run.flx#0384">gen run_cxx_compiler_if_required () : int</a></pre>
<pre>0398:    <a href="/share/lib/std/felix/flx/flx_run.flx#0398">gen check_run_if_required_and_uptodate() : bool</a></pre>
<pre>0422:    <a href="/share/lib/std/felix/flx/flx_run.flx#0422">gen run_with_calpackages () : int</a></pre>
<pre>0436:    <a href="/share/lib/std/felix/flx/flx_run.flx#0436">gen cxx_link_dynamic () : int</a></pre>
<pre>0472:    <a href="/share/lib/std/felix/flx/flx_run.flx#0472">gen cxx_link_dynamic_with_calpackages () : int</a></pre>
<pre>0478:    <a href="/share/lib/std/felix/flx/flx_run.flx#0478">gen cxx_link_static () : int</a></pre>
<pre>0518:    <a href="/share/lib/std/felix/flx/flx_run.flx#0518">gen cxx_link_static_with_calpackages() :  int</a></pre>
<pre>0524:    <a href="/share/lib/std/felix/flx/flx_run.flx#0524">gen cxx_static_library () : int</a></pre>
<pre>0562:    <a href="/share/lib/std/felix/flx/flx_run.flx#0562">gen check_binary_uptodate () : bool</a></pre>
<pre>0564:    <a href="/share/lib/std/felix/flx/flx_run.flx#0564">fun maxf (t:double) (f:string)</a></pre>
<pre>0603:    <a href="/share/lib/std/felix/flx/flx_run.flx#0603">gen run_linker_if_required() : int</a></pre>
<pre>0648:    <a href="/share/lib/std/felix/flx/flx_run.flx#0648">gen run_program_dynamic () : int</a></pre>
<pre>0672:    <a href="/share/lib/std/felix/flx/flx_run.flx#0672">gen run_program_static () : int</a></pre>
<pre>0689:    <a href="/share/lib/std/felix/flx/flx_run.flx#0689">gen run_dynamic_with_calpackages () : int</a></pre>
<pre>0695:    <a href="/share/lib/std/felix/flx/flx_run.flx#0695">gen run_program_if_required () : int</a></pre>
<pre>0713:    <a href="/share/lib/std/felix/flx/flx_run.flx#0713">gen check_output_if_required () : int</a></pre>
<hr/><a href="/share/lib/std/felix/flx_cache.flx">felix/flx_cache.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/flx_cache.flx#0001">class FlxCache</a></pre>
<pre>0003:    <a href="/share/lib/std/felix/flx_cache.flx#0003">fun gramtime(debugln: string -> 0) (path:string, s:string) : double</a></pre>
<pre>0005:    <a href="/share/lib/std/felix/flx_cache.flx#0005">fun maxtime (x:double) (s:string)</a></pre>
<pre>0053:    <a href="/share/lib/std/felix/flx_cache.flx#0053">typedef cache_validation_spec_t</a></pre>
<pre>0095:    <a href="/share/lib/std/felix/flx_cache.flx#0095">gen validate_cache  (spec: cache_validation_spec_t) : int * double</a></pre>
<pre>0199:    <a href="/share/lib/std/felix/flx_cache.flx#0199">fun cache_join (c:string, var f:string)</a></pre>
<hr/><a href="/share/lib/std/felix/flx_cp.flx">felix/flx_cp.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/flx_cp.flx#0001">class CopyFiles</a></pre>
<pre>0002:    <a href="/share/lib/std/felix/flx_cp.flx#0002">proc processfiles</a></pre>
<pre>0013:    <a href="/share/lib/std/felix/flx_cp.flx#0013">proc addfile(f:string)</a></pre>
<pre>0040:    <a href="/share/lib/std/felix/flx_cp.flx#0040">proc rfi(dir: string)</a></pre>
<pre>0103:    <a href="/share/lib/std/felix/flx_cp.flx#0103">proc copyfiles(basedir:string, re:RE2, tpat:string, live:bool, verbose:bool)</a></pre>
<pre>0104:    <a href="/share/lib/std/felix/flx_cp.flx#0104">processfiles (FileSystem::filecopy) (basedir, re, tpat, live, verbose)</a></pre>
<pre>0107:    <a href="/share/lib/std/felix/flx_cp.flx#0107">proc copyfiles(basedir:string, re:string, tpat:string, live:bool, verbose:bool)</a></pre>
<hr/><a href="/share/lib/std/felix/flx_cxx.flx">felix/flx_cxx.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/flx_cxx.flx#0001">class CxxCompiler</a></pre>
<pre>0003:    <a href="/share/lib/std/felix/flx_cxx.flx#0003">typedef cxx_dep_spec_t</a></pre>
<pre>0012:    <a href="/share/lib/std/felix/flx_cxx.flx#0012">gen generic_cxx_gen_deps (spec: cxx_dep_spec_t) (src:string) : int * string</a></pre>
<pre>0032:    <a href="/share/lib/std/felix/flx_cxx.flx#0032">gen generic_dependency_parser (data:string) : list[string]</a></pre>
<pre>0042:    <a href="/share/lib/std/felix/flx_cxx.flx#0042">typedef cxx_dynamic_spec_t</a></pre>
<pre>0052:    <a href="/share/lib/std/felix/flx_cxx.flx#0052">gen generic_cxx_compile_for_dynamic (spec: cxx_dynamic_spec_t) (src:string, dst:string) : int</a></pre>
<pre>0073:    <a href="/share/lib/std/felix/flx_cxx.flx#0073">typedef link_dynamic_spec_t</a></pre>
<pre>0083:    <a href="/share/lib/std/felix/flx_cxx.flx#0083">gen generic_link_dynamic</a></pre>
<pre>0110:    <a href="/share/lib/std/felix/flx_cxx.flx#0110">typedef cxx_compile_static_t</a></pre>
<pre>0120:    <a href="/share/lib/std/felix/flx_cxx.flx#0120">gen generic_cxx_compile_for_static</a></pre>
<pre>0146:    <a href="/share/lib/std/felix/flx_cxx.flx#0146">typedef generic_link_static_t</a></pre>
<pre>0155:    <a href="/share/lib/std/felix/flx_cxx.flx#0155">gen generic_link_static</a></pre>
<pre>0175:    <a href="/share/lib/std/felix/flx_cxx.flx#0175">typedef generic_lib_static_t</a></pre>
<pre>0183:    <a href="/share/lib/std/felix/flx_cxx.flx#0183">gen generic_static_library</a></pre>
<hr/><a href="/share/lib/std/felix/flx_flxg.flx">felix/flx_flxg.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/flx_flxg.flx#0001">class Flxg</a></pre>
<pre>0003:    <a href="/share/lib/std/felix/flx_flxg.flx#0003">typedef flxg_spec_t</a></pre>
<pre>0027:    <a href="/share/lib/std/felix/flx_flxg.flx#0027">gen run_felix_compiler (spec:flxg_spec_t) : int</a></pre>
<hr/><a href="/share/lib/std/felix/flx_gc.fdoc">felix/flx_gc.fdoc</a>

<pre>0004:  <a href="/share/lib/std/felix/flx_gc.fdoc#0004">class Collector</a></pre>
<pre>0007:    <a href="/share/lib/std/felix/flx_gc.fdoc#0007">struct pointer_data_t</a></pre>
<pre>0021:    <a href="/share/lib/std/felix/flx_gc.fdoc#0021">fun get_pointer_data (p:address)</a></pre>
<pre>0023:    <a href="/share/lib/std/felix/flx_gc.fdoc#0023">fun is_felix_pointer (pd: pointer_data_t)</a></pre>
<pre>0024:    <a href="/share/lib/std/felix/flx_gc.fdoc#0024">fun is_head_pointer (pd: pointer_data_t)</a></pre>
<pre>0025:    <a href="/share/lib/std/felix/flx_gc.fdoc#0025">fun repeat_count (pd: pointer_data_t)</a></pre>
<pre>0026:    <a href="/share/lib/std/felix/flx_gc.fdoc#0026">fun allocated_bytes (pd: pointer_data_t)</a></pre>
<pre>0032:    <a href="/share/lib/std/felix/flx_gc.fdoc#0032">proc print_pointer_data (pd: pointer_data_t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Diagnostic routine, dump pointer data and
 computed values.
</p></div>
<pre>0053:    <a href="/share/lib/std/felix/flx_gc.fdoc#0053">proc print_pointer_data (p:address)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Diagnostic routine, print info about a pointer.
</p></div>
<pre>0058:    <a href="/share/lib/std/felix/flx_gc.fdoc#0058">proc print_pointer_data[T] (p:&T)</a></pre>
<pre>0059:    <a href="/share/lib/std/felix/flx_gc.fdoc#0059">proc print_pointer_data[T] (p:cptr[T])</a></pre>
<pre>0060:    <a href="/share/lib/std/felix/flx_gc.fdoc#0060">proc print_pointer_data[T] (p:+T)</a></pre>
<hr/><a href="/share/lib/std/felix/flx_pkg.flx">felix/flx_pkg.flx</a>

<pre>0003:  <a href="/share/lib/std/felix/flx_pkg.flx#0003">class FlxPkg</a></pre>
<pre>0005:    <a href="/share/lib/std/felix/flx_pkg.flx#0005">typedef pkgconfig_inspec_t</a></pre>
<pre>0017:    <a href="/share/lib/std/felix/flx_pkg.flx#0017">typedef pkgconfig_outspec_t</a></pre>
<pre>0025:    <a href="/share/lib/std/felix/flx_pkg.flx#0025">fun fix2word_flags (fs: list[string])</a></pre>
<pre>0041:    <a href="/share/lib/std/felix/flx_pkg.flx#0041">gen map_package_requirements(spec:pkgconfig_inspec_t) : pkgconfig_outspec_t</a></pre>
<pre>0050:    <a href="/share/lib/std/felix/flx_pkg.flx#0050">gen pkgconfl(args:list[string]) : list[string]</a></pre>
<pre>0060:    <a href="/share/lib/std/felix/flx_pkg.flx#0060">gen pkgconfs(args:list[string]) : string</a></pre>
<pre>0138:    <a href="/share/lib/std/felix/flx_pkg.flx#0138">proc write_include_file(path:string, INCLUDE_FILES:list[string])</a></pre>
<hr/><a href="/share/lib/std/felix/flx_pkgconfig.flx">felix/flx_pkgconfig.flx</a>

<pre>0005:  <a href="/share/lib/std/felix/flx_pkgconfig.flx#0005">class FlxPkgConfig</a></pre>
<hr/><a href="/share/lib/std/felix/flx_pkgconfig_core.flx">felix/flx_pkgconfig_core.flx</a>

<pre>0002:  <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0002">class FlxPkgConfig_core</a></pre>
<pre>0006:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0006">gen flx_pkgconfig (args:list[string]) : int * list[string]</a></pre>
<pre>0008:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0008">proc print_help</a></pre>
<pre>0035:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0035">proc pre_incr:&lex_iterator</a></pre>
<pre>0037:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0037">fun lexit(ini:lex_iterator, finish:lex_iterator): lex_iterator * string</a></pre>
<pre>0082:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0082">fun lexstr(s':string): list[string]</a></pre>
<pre>0123:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0123">fun is_prefix_of(p:string,w:string)</a></pre>
<pre>0125:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0125">fun xfind(flags: string, c: string)</a></pre>
<pre>0132:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0132">proc parse_args(args:list[string])</a></pre>
<pre>0138:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0138">fun prefix(x:string)</a></pre>
<pre>0211:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0211">fun reattach_drive_letters : list[string] -> list[string]</a></pre>
<pre>0227:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0227">fun check_id (s:string)</a></pre>
<pre>0233:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0233">fun get_field(line:string):string * string</a></pre>
<pre>0243:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0243">fun get_variable(line:string):string * string</a></pre>
<pre>0253:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0253">proc add_val(v:string)</a></pre>
<pre>0258:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0258">proc tail_val(v:string)</a></pre>
<pre>0263:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0263">proc keep_val (v:string)</a></pre>
<pre>0267:    <a href="/share/lib/std/felix/flx_pkgconfig_core.flx#0267">proc handle_pkg (pkg:string, trace:list[string])</a></pre>
<hr/><a href="/share/lib/std/felix/flx_pkgconfig_export.flx">felix/flx_pkgconfig_export.flx</a>
<pre>0015:    <a href="/share/lib/std/felix/flx_pkgconfig_export.flx#0015">gen mk_pkgconfig_query (a:FlxPkgConfigQuery_struct)</a></pre>
<hr/><a href="/share/lib/std/felix/flx_pkgconfig_query.flx">felix/flx_pkgconfig_query.flx</a>

<pre>0004:  <a href="/share/lib/std/felix/flx_pkgconfig_query.flx#0004">class FlxPkgConfig_query</a></pre>
<pre>0013:    <a href="/share/lib/std/felix/flx_pkgconfig_query.flx#0013">fun aux (lst:list[string]) (out:list[string])</a></pre>
<hr/><a href="/share/lib/std/felix/flx_pkgconfig_query_interface.flx">felix/flx_pkgconfig_query_interface.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/flx_pkgconfig_query_interface.flx#0001">class FlxPkgConfigQuery_interface</a></pre>
<hr/><a href="/share/lib/std/felix/flx_profile.flx">felix/flx_profile.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/flx_profile.flx#0001">class FlxProfile</a></pre>
<pre>0003:    <a href="/share/lib/std/felix/flx_profile.flx#0003">fun dflt_profile ()</a></pre>
<pre>0035:    <a href="/share/lib/std/felix/flx_profile.flx#0035">typedef profile_type</a></pre>
<hr/><a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx">felix/pkgtool/pkgtool_base.flx</a>
<pre>0119:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0119">union build_behavior</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> pkgtool_base.flx - PkgTool Core
 Author Mike Maul
 See README.md for more details
 #### Color output formatting
 #### Presentation Formatting
 Collection of functional display codes,
 with a display proc.
 Display for program activation of major section
 Display of current phast (e.g. build,test,install...)
 Header to indicate a group of related tasks  
 Task display
 Similar for task_group but for tests
 Identifies related tests
 Displays name of test
 Fatal or unhandlable problem, abort program
 Fatal or unhandlable problem, abort program
 Indicator of invalid options passed to program
 Indicator of invalid command passed to program
 Indication of successful completion of phase or task_group
 Convey a warning in test, task, task group or phase
</p></div>
<pre>0162:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0162">general_fail$ "HOME environment variable is not set.  Please set HOME before building."</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> ### Core definitions
</p></div>

<pre>0218:  <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0218">class PkgTool</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> ### Globals parameters
 Package parameters
 var names below should be keys in cfg strdict
 #### Options populated from command line
</p></div>
<pre>0221:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0221">fun join_list (strings:list[string],s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> ### Helpers
</p></div>
<pre>0224:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0224">fun join_list (strings:list[string])</a></pre>
<pre>0227:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0227">gen fopen_append: string -> ofile</a></pre>
<pre>0237:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0237">noinline  fun read_cfg(fn:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> #### Package configuration file processing
 Process package definition which should be package README.md
 Pull parameter definitions of matching format
   KEY: VALUE
 Ignoreing any lines not matching format and stopping at first occurance
 of line starting with 5 or more dashes
 returns strdict[string] with keys/values
</p></div>
<pre>0261:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0261">proc phase(label:string,step_p:unit->void)</a></pre>
<pre>0265:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0265">proc task(task_s:string,task_p:unit->void)</a></pre>
<pre>0269:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0269">proc task (s:string)</a></pre>
<pre>0271:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0271">proc warning (s:string)</a></pre>
<pre>0273:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0273">proc setup_fail(s:string)</a></pre>
<pre>0278:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0278">proc general_fail(s:string)</a></pre>
<pre>0285:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0285">proc test_result (status:bool)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Indication of test failure or success
</p></div>
<pre>0293:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0293">noinline  proc imply(name:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> #### Testing 
 Reachability test if executed implies success
</p></div>
<pre>0299:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0299">noinline  proc assert_true(result:bool,name:string,fail_message:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> if result argument true test is successful, fail message if present
 is output on failure 
</p></div>
<pre>0304:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0304">proc assert_true(result:bool,name:string)</a></pre>
<pre>0307:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0307">proc assert_true(result:bool)</a></pre>
<pre>0312:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0312">noinline proc run_test(name:string,noheader:bool)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test invocation
</p></div>
<pre>0316:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0316">noinline  proc run_test(name:string,noheader:bool,fail_not_fatal:bool)</a></pre>
<pre>0339:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0339">proc run_test(name:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> See run_test:string*bool
</p></div>
<pre>0344:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0344">proc test_fail(s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fatal or Sever test failure, aborts program
</p></div>
<pre>0349:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0349">gen realpath: string->string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> ### Utilities
</p></div>
<pre>0352:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0352">noinline  proc cp_root(s:string,p:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> See cp_root:string*string*string
</p></div>
<pre>0357:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0357">noinline  proc cp_root(s:string,p:string,dest:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Copy files using flx_cp
</p></div>
<pre>0371:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0371">noinline  proc check_pkgconfig_path (unit)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Ensure user has PKG_CONFIG_PATH ser
</p></div>
<pre>0387:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0387">fun WIFEXITED(x:process_status_t)</a></pre>
<pre>0388:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0388">fun WEXITSTATUS(x:process_status_t)</a></pre>
<pre>0392:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0392">fun run_cmd(cmd:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> See run_cmd:string*string*bool  
</p></div>
<pre>0397:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0397">fun run_cmd (cmd:string,on_error:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> See run_cmd:string*string*bool  
</p></div>
<pre>0400:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0400">noinline  fun run_cmd (cmd:string,on_error:string,echo:bool)</a></pre>
<pre>0406:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0406">noinline  fun run_cmd (cmd:string,on_error:string,echo:bool,fail_not_fatal:bool)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Execute command string specified in command in shell consuming
 output. Redirects output to log. Non-zero result codes call setup_fail
 output from command is returned.
</p></div>
<pre>0430:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0430">fun default_run_flx(file:string,on_error:string)</a></pre>
<pre>0434:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0434">virtual fun run_flx(file:string,on_error:string)</a></pre>
<pre>0444:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0444">noinline fun prompt(q:string,a:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Displays Question 'q' and acceptable single character answers 'a'
 of characters in a only alpha and numeric values will be considered
 a valid response and will be returned. If the first character of a 
 is an uppercase character it will be considered the default answer 
 and propmpt will return the first character in awnser if only a 
 newline is recieved.
</p></div>
<pre>0461:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0461">proc log(message:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> #### Logging and console output
 Write output to file specified in SETUP_LOG
</p></div>
<pre>0466:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0466">noinline  proc log(message:string,log_file:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write output to file specified in log_file argument
</p></div>
<pre>0477:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0477">proc display(message:string,log_file:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write to console and log
</p></div>
<pre>0481:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0481">proc display(message:string)</a></pre>
<pre>0492:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0492">noinline  fun redir_err (cmd:string,to_file:string):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wrap command in shell redirection to append output to
 file specified in to_file arg
 Wrap command in shell redirection to append STDERR to
 file specified in to_file arg
</p></div>
<pre>0506:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0506">noinline  fun find_path_to(name:string,paths:list[string])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> #### Felix Package Config Utilities
 Locates path to to 'name' given list of 'paths'
</p></div>
<pre>0519:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0519">noinline  proc create_fpc(name:string,description:string,ccflags:list[string],includes:list[string],</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Creates 'name'.fpc file with 'description', 'cflags' and
 list of dynamic libraries 'dlibs' and static libraries 'slibs'
</p></div>
<pre>0543:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0543">general_fail("Failed creating "+fpc_name)</a></pre>
<pre>0550:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0550">noinline  proc create_config(name:string,includes:list[string],libs:list[string],</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Determines proper configuration given package 'name', list of C/C++
 'includes' and list of C/C++ 'libs'. Then generates config/'name'.fpc
 Felix Package Config file
</p></div>
<pre>0558:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0558">noinline  proc create_config(name:string,includes:list[string],libs:list[string],</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Determines proper configuration given package 'name', list of C/C++
 'includes' and list of C/C++ 'libs'. Then generates config/'name'.fpc
 Felix Package Config file
</p></div>
<pre>0572:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0572">general_fail("Unable to find " + inc +</a></pre>
<pre>0605:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0605">noinline  proc test_config(name:string,reqs:list[string])</a></pre>
<pre>0636:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0636">noinline  fun is_installed(name:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> #### Package Utilities
 return opt version of package installed
</p></div>
<pre>0650:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0650">noinline  proc handle_dependency(dependency:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Handle dependency specification in package README.md
 If a dependency is declared in DEPENDENCIES in the package README.md
 then handle_dependency will invoke 'scoop install <required package>
 to satisfy the dependency
</p></div>
<pre>0662:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0662">general_fail(msg)</a></pre>
<pre>0674:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0674">noinline  proc git_get(dest:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Request clone or pull from git repo specified in PKG_URL
</p></div>
<pre>0682:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0682">noinline  proc git_get(url:string,dest:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Request clone or pull from git repo specified in PKG_URL
</p></div>
<pre>0714:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0714">noinline  proc check_dependencies()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Phases/Command Implementations
</p></div>
<pre>0730:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0730">noinline  proc default_build()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> implementaion of default build behavior see README.md for
 discussion of behavior
</p></div>
<pre>0794:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0794">virtual proc build()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> To preform custom build behaior create instance of build.
 In most cases default_build should be called in instance
</p></div>
<pre>0804:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0804">noinline  proc default_test()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> implementaion of default test behavior see README.md for
 discussion of behavior
 Executes files in test directory not starting with 'C' or 'D'
 The 'C' prefix is reserved for functionality tests that may be used.
 The 'D' prefix is reserved for datafiles during build phase
</p></div>
<pre>0834:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0834">virtual proc test()</a></pre>
<pre>0841:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0841">noinline  proc default_install()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> implementaion of default install behavior see README.md for
 discussion of behavior 
</p></div>
<pre>0879:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0879">virtual proc install()</a></pre>
<pre>0888:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0888">noinline  fun study_history()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Reads package installation history. History consists of a file
 in the pgktool config format (see read_cfg) where keys are
 <package name>-<felix INSTALL_ROOT>\t<package name>
 The general idea is to have a set of records of package installations
 to a given felix installation
</p></div>
<pre>0911:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0911">noinline  proc make_history (name:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Reads history, rewrites history and adds current install
 package to history
</p></div>
<pre>0919:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0919">noinline  proc rewrite_history (prior_knowledge:strdict[string])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Reads history, rewrites history and adds current install
 package to history
</p></div>
<pre>0935:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0935">noinline  fun dump_litterbox()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return list of packages in litterbox
</p></div>
<pre>0968:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0968">noinline  proc repeat_history()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Sometimes even those that study history are doomed to repeat it.
 Reinstalls package in history that do not exist in the felix
 installation. This is something that would be done after a new
 new felix installation
</p></div>
<pre>0989:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#0989">general_fail(msg)</a></pre>
<pre>1014:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1014">noinline  proc default_clean()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> implementaion of default clean behavior see README.md for
 discussion of behavior
</p></div>
<pre>1017:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1017">proc clean_flx(file:string)</a></pre>
<pre>1079:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1079">virtual proc clean()</a></pre>
<pre>1085:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1085">proc help()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Help Command implementations
</p></div>
<pre>1133:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1133">proc help_command (command:list[string])</a></pre>
<pre>1187:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1187">noinline  fun installed()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write list of installed packges to console
</p></div>
<pre>1209:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1209">noinline  proc degitify()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> See degitify:string
</p></div>
<pre>1214:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1214">noinline  proc degitify(dir:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Strip .git directory from directory specified in dir 
</p></div>
<pre>1225:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1225">gen handle_global_options(options:list[string])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Argument processing
</p></div>
<pre>1253:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1253">virtual proc run()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Implement instance for program run loop
</p></div>

<pre>1260:  <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1260">class SetupTool</a></pre>
<pre>1264:    <a href="/share/lib/std/felix/pkgtool/pkgtool_base.flx#1264">noinline  proc run()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Executes package phases 
</p></div>
<hr/><a href="/share/lib/std/felix/rtti.flx">felix/rtti.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/rtti.flx#0001">class Rtti</a></pre>
<pre>0004:    <a href="/share/lib/std/felix/rtti.flx#0004">type collector_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of the collector.
</p></div>
<pre>0007:    <a href="/share/lib/std/felix/rtti.flx#0007">type gc_shape_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of an RTTI record.
</p></div>
<pre>0008:    <a href="/share/lib/std/felix/rtti.flx#0008">fun isNULL: gc_shape_t -> bool</a></pre>
<pre>0009:    <a href="/share/lib/std/felix/rtti.flx#0009">typedef gc_shape_flags_t</a></pre>
<pre>0016:    <a href="/share/lib/std/felix/rtti.flx#0016">typedef gc_finaliser_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of a finalisation function.
</p></div>
<pre>0017:    <a href="/share/lib/std/felix/rtti.flx#0017">typedef gc_encoder_t</a></pre>
<pre>0018:    <a href="/share/lib/std/felix/rtti.flx#0018">typedef gc_decoder_t</a></pre>
<pre>0021:    <a href="/share/lib/std/felix/rtti.flx#0021">fun next_shape: gc_shape_t -> gc_shape_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Iterator to find the next shape after a given one.
</p></div>
<pre>0024:    <a href="/share/lib/std/felix/rtti.flx#0024">fun cname: gc_shape_t -> +char</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The C++ name of the Felix type.
</p></div>
<pre>0028:    <a href="/share/lib/std/felix/rtti.flx#0028">fun number_of_elements: gc_shape_t -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The static number of elements in an array type.
 Note this is not the size of a varray!
</p></div>
<pre>0031:    <a href="/share/lib/std/felix/rtti.flx#0031">fun bytes_per_element: gc_shape_t -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Number of bytes in one element.
</p></div>
<pre>0034:    <a href="/share/lib/std/felix/rtti.flx#0034">fun finaliser: gc_shape_t -> gc_finaliser_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The finaliser function.
</p></div>
<pre>0037:    <a href="/share/lib/std/felix/rtti.flx#0037">fun encoder : gc_shape_t -> gc_encoder_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The encoder function.
</p></div>
<pre>0040:    <a href="/share/lib/std/felix/rtti.flx#0040">fun decoder: gc_shape_t -> gc_decoder_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The decoder function.
</p></div>
<pre>0043:    <a href="/share/lib/std/felix/rtti.flx#0043">fun uses_offset_table : gc_shape_t -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check for offset data
</p></div>
<pre>0047:    <a href="/share/lib/std/felix/rtti.flx#0047">fun _unsafe_n_offsets: gc_shape_t -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The number of pointers in the base type.
 If the type is an array that's the element type.
</p></div>
<pre>0049:    <a href="/share/lib/std/felix/rtti.flx#0049">fun n_offsets (shape: gc_shape_t) : size</a></pre>
<pre>0054:    <a href="/share/lib/std/felix/rtti.flx#0054">fun _unsafe_offsets: gc_shape_t -> +size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pointer to the offset table.
</p></div>
<pre>0056:    <a href="/share/lib/std/felix/rtti.flx#0056">fun offsets (shape: gc_shape_t) : +size</a></pre>
<pre>0061:    <a href="/share/lib/std/felix/rtti.flx#0061">fun flags: gc_shape_t -> gc_shape_flags_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Flags.
</p></div>
<pre>0065:    <a href="/share/lib/std/felix/rtti.flx#0065">fun shape_list_head : unit -> gc_shape_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Global head of the compiled shape list.
 This is actually the first type, since they're linked together.
</p></div>
<pre>0068:    <a href="/share/lib/std/felix/rtti.flx#0068">type type_info</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ type_info for the type.
</p></div>
<pre>0071:    <a href="/share/lib/std/felix/rtti.flx#0071">fun name : type_info -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ source name of the type.
</p></div>
<pre>0088:    <a href="/share/lib/std/felix/rtti.flx#0088">fun gxx_demangle(s:string) :string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ Type_info of a type.
 For gcc only, the C++ name a mangled name represents.
</p></div>
<pre>0095:    <a href="/share/lib/std/felix/rtti.flx#0095">proc _link_shape[T]: &gc_shape_t</a></pre>
<pre>0120:    <a href="/share/lib/std/felix/rtti.flx#0120">gen link_shape[T]()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Put a new shape record into the global list.
 This routine constructs a new shape record on the heap.
 It fills in some of the data based on the type.
 It links the new record into the shape list.
 Then it stores the shape at the user specified address.
 Since the shape is represented in Felix by a pointer,
 subsequent modifications carry through to the linked shape object.
 This routine is only useful for adding a shape record for a statically
 known type: that's useful because not all statically known types get
 shape records: the compiler only generates them if the shape is
 required because an object of that type is allocated on the heap.
</p></div>
<hr/><a href="/share/lib/std/felix/serialise.fdoc">felix/serialise.fdoc</a>

<pre>0004:  <a href="/share/lib/std/felix/serialise.fdoc#0004">class Serialise</a></pre>
<pre>0011:    <a href="/share/lib/std/felix/serialise.fdoc#0011">fun blit[T] (p: &T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Encode binary image of a type, without length.
</p></div>
<pre>0012:    <a href="/share/lib/std/felix/serialise.fdoc#0012">fun ncode [T] (var v: T)</a></pre>
<pre>0015:    <a href="/share/lib/std/felix/serialise.fdoc#0015">gen unblit[T] (p: &T, s: +char, i:size) : size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Decode a type
</p></div>
<pre>0023:    <a href="/share/lib/std/felix/serialise.fdoc#0023">fun encode_varray (p:address) : string</a></pre>
<pre>0053:    <a href="/share/lib/std/felix/serialise.fdoc#0053">fun find_pointers (p:address) : list[address]</a></pre>
<pre>0083:    <a href="/share/lib/std/felix/serialise.fdoc#0083">struct pclosure</a></pre>
<pre>0085:    <a href="/share/lib/std/felix/serialise.fdoc#0085">processed: J1Array</a></pre>
<pre>0090:    <a href="/share/lib/std/felix/serialise.fdoc#0090">ctor pclosure ()</a></pre>
<pre>0094:    <a href="/share/lib/std/felix/serialise.fdoc#0094">proc add_pointer (self: &pclosure) (p:address)</a></pre>
<pre>0110:    <a href="/share/lib/std/felix/serialise.fdoc#0110">gen iterator (self: &pclosure) () : opt[address]</a></pre>
<pre>0125:    <a href="/share/lib/std/felix/serialise.fdoc#0125">fun find_closure (p:address) : list[address]</a></pre>
<pre>0152:    <a href="/share/lib/std/felix/serialise.fdoc#0152">fun encode_closure (alst:list[address]) : string</a></pre>
<pre>0159:    <a href="/share/lib/std/felix/serialise.fdoc#0159">fun encode_pointer_closure (p:address)</a></pre>
<pre>0163:    <a href="/share/lib/std/felix/serialise.fdoc#0163">gen create_empty_varray : gc_shape_t * size -> address</a></pre>
<pre>0168:    <a href="/share/lib/std/felix/serialise.fdoc#0168">proc set_used: address * size</a></pre>
<pre>0173:    <a href="/share/lib/std/felix/serialise.fdoc#0173">gen decode_varray (ss:string) : address</a></pre>
<pre>0197:    <a href="/share/lib/std/felix/serialise.fdoc#0197">gen decode_pointer_closure (ss:string) : address</a></pre>
<pre>0206:    <a href="/share/lib/std/felix/serialise.fdoc#0206">gen create_objects () : address</a></pre>
<pre>0237:    <a href="/share/lib/std/felix/serialise.fdoc#0237">proc adjust_pointer (pptr:&address)</a></pre>
<pre>0256:    <a href="/share/lib/std/felix/serialise.fdoc#0256">proc adjust_all_pointers (newhead:address)</a></pre>
<hr/><a href="/share/lib/std/felix/sync.flx">felix/sync.flx</a>

<pre>0001:  <a href="/share/lib/std/felix/sync.flx#0001">class SyncControl</a></pre>
<pre>0010:    <a href="/share/lib/std/felix/sync.flx#0010">fun str: fstate_t -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Model of synchronous control state value.
 terminated: Not used.
 blocked: out of fthreads to run.
 delegated: non synchronous service call, delegate to our caller.
</p></div>
<pre>0026:    <a href="/share/lib/std/felix/sync.flx#0026">type fthread_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fthread state model.
 next_fthread_pos: restart scheduler by grabbing a new fthread
 from the active list.
 next_request_pos: restart scheduler by handling the service
 request of the currently active fthread.
 The type of a list of active fthreads to schedule.
</p></div>
<pre>0029:    <a href="/share/lib/std/felix/sync.flx#0029">ctor fthread_list: 1</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct an empty fthread list.
</p></div>
<pre>0032:    <a href="/share/lib/std/felix/sync.flx#0032">proc delete : fthread_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Delete an fthread list.
</p></div>
<pre>0035:    <a href="/share/lib/std/felix/sync.flx#0035">proc push_back: fthread_list * fthread</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Push an fthread onto an fthread list.
</p></div>
<pre>0038:    <a href="/share/lib/std/felix/sync.flx#0038">ctor cont: (1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Upcast a procedure closure to a continuation.
</p></div>
<pre>0041:    <a href="/share/lib/std/felix/sync.flx#0041">ctor fthread: cont</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create an fthread from a continuation.
</p></div>
<pre>0044:    <a href="/share/lib/std/felix/sync.flx#0044">type scheduler</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a synchronous scheduler.
</p></div>
<pre>0049:    <a href="/share/lib/std/felix/sync.flx#0049">ctor scheduler : fthread_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Constructor for a synchronous scheduler.
 Accepts a list of fthreads to run.
 Uses the callers garbage collector.
</p></div>
<pre>0050:    <a href="/share/lib/std/felix/sync.flx#0050">proc delete: scheduler</a></pre>
<pre>0055:    <a href="/share/lib/std/felix/sync.flx#0055">proc run : scheduler</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke the scheduler and run until one of two
 events transpires: blocked, delegated.
</p></div>
<pre>0058:    <a href="/share/lib/std/felix/sync.flx#0058">fun get_scheduler_state : scheduler -> fstate_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> get the exit state of the scheduler after running.
</p></div>
<pre>0065:    <a href="/share/lib/std/felix/sync.flx#0065">proc run_proc (p: 1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Run a single procedure as a fibre on
 new scheduler. This scheduler acts like a subroutine,
 control doesn't return to the caller until the scheduler
 queue is empty. This call cannot handle async I/O,
 so any attempt to do it will cause the program to abort.
</p></div>
<hr/><a href="/share/lib/std/felix/toolchain/clang_iphoneos.flx">felix/toolchain/clang_iphoneos.flx</a>
<hr/><a href="/share/lib/std/felix/toolchain/clang_linux.flx">felix/toolchain/clang_linux.flx</a>
<hr/><a href="/share/lib/std/felix/toolchain/clang_osx.flx">felix/toolchain/clang_osx.flx</a>
<hr/><a href="/share/lib/std/felix/toolchain/gcc_linux.flx">felix/toolchain/gcc_linux.flx</a>
<hr/><a href="/share/lib/std/felix/toolchain/gcc_osx.flx">felix/toolchain/gcc_osx.flx</a>
<hr/><a href="/share/lib/std/felix/toolchain/msvc_win32.flx">felix/toolchain/msvc_win32.flx</a>
<hr/><a href="/share/lib/std/felix/toolchain_clang_config.flx">felix/toolchain_clang_config.flx</a>
<pre>0002:    <a href="/share/lib/std/felix/toolchain_clang_config.flx#0002">typedef clang_config_t</a></pre>
<hr/><a href="/share/lib/std/felix/toolchain_interface.flx">felix/toolchain_interface.flx</a>
<hr/><a href="/share/lib/std/flx_tclass.flx">flx_tclass.flx</a>
<pre>0003:    <a href="/share/lib/std/flx_tclass.flx#0003">typedef void</a></pre>
<pre>0004:    <a href="/share/lib/std/flx_tclass.flx#0004">typedef unit</a></pre>
<pre>0005:    <a href="/share/lib/std/flx_tclass.flx#0005">typedef bool</a></pre>

<pre>0009:  <a href="/share/lib/std/flx_tclass.flx#0009">class IStream[f,t]</a></pre>
<pre>0010:    <a href="/share/lib/std/flx_tclass.flx#0010">virtual gen read: f -> t</a></pre>

<pre>0013:  <a href="/share/lib/std/flx_tclass.flx#0013">class OStream[f,t]</a></pre>
<pre>0014:    <a href="/share/lib/std/flx_tclass.flx#0014">virtual proc write: f * t</a></pre>

<pre>0017:  <a href="/share/lib/std/flx_tclass.flx#0017">class IOStream[f,t]</a></pre>

<pre>0024:  <a href="/share/lib/std/flx_tclass.flx#0024">class IFile[f,t]</a></pre>

<pre>0028:  <a href="/share/lib/std/flx_tclass.flx#0028">class OFile[f,t]</a></pre>
<pre>0030:    <a href="/share/lib/std/flx_tclass.flx#0030">virtual proc close: f</a></pre>

<pre>0035:  <a href="/share/lib/std/flx_tclass.flx#0035">class IBuffer [f]</a></pre>
<pre>0036:    <a href="/share/lib/std/flx_tclass.flx#0036">virtual gen read: f -> address * int -> int * bool</a></pre>

<pre>0039:  <a href="/share/lib/std/flx_tclass.flx#0039">class OBuffer [f]</a></pre>
<pre>0040:    <a href="/share/lib/std/flx_tclass.flx#0040">virtual gen write : f -> address * int -> int * bool</a></pre>

<pre>0050:  <a href="/share/lib/std/flx_tclass.flx#0050">class Set[c,t]</a></pre>
<pre>0051:    <a href="/share/lib/std/flx_tclass.flx#0051">fun mem (elt:t, container:c):bool</a></pre>

<pre>0056:  <a href="/share/lib/std/flx_tclass.flx#0056">class Container [c,v]</a></pre>
<pre>0059:    <a href="/share/lib/std/flx_tclass.flx#0059">virtual fun len: c -> size</a></pre>
<pre>0060:    <a href="/share/lib/std/flx_tclass.flx#0060">virtual fun empty(x: c): bool</a></pre>

<pre>0065:  <a href="/share/lib/std/flx_tclass.flx#0065">class Monad [M: TYPE->TYPE]</a></pre>
<pre>0066:    <a href="/share/lib/std/flx_tclass.flx#0066">virtual fun bind[a,b]: M a * (a -> M b) -> M b</a></pre>
<pre>0067:    <a href="/share/lib/std/flx_tclass.flx#0067">virtual fun ret[a]: a -> M a</a></pre>

<pre>0072:  <a href="/share/lib/std/flx_tclass.flx#0072">class Str [T]</a></pre>
<pre>0073:    <a href="/share/lib/std/flx_tclass.flx#0073">virtual fun str: T -> string</a></pre>

<pre>0076:  <a href="/share/lib/std/flx_tclass.flx#0076">class Repr [T with Str[T]]</a></pre>
<pre>0077:    <a href="/share/lib/std/flx_tclass.flx#0077">virtual fun repr (t:T) : string</a></pre>

<pre>0080:  <a href="/share/lib/std/flx_tclass.flx#0080">class Show [T]</a></pre>
<pre>0088:    <a href="/share/lib/std/flx_tclass.flx#0088">fun str (x:void)</a></pre>
<pre>0095:    <a href="/share/lib/std/flx_tclass.flx#0095">fun str (x:unit)</a></pre>
<hr/><a href="/share/lib/std/gc.flx">gc.flx</a>

<pre>0004:  <a href="/share/lib/std/gc.flx#0004">open class Gc</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Generic garbage collector interface.
 This class provides a generic interface to the GC,
 that is, one that is independent of the GC representation.
</p></div>
<pre>0006:    <a href="/share/lib/std/gc.flx#0006">fun _collect: unit -> ulong</a></pre>
<pre>0010:    <a href="/share/lib/std/gc.flx#0010">proc collect()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke the garbage collector.
</p></div>
<pre>0021:    <a href="/share/lib/std/gc.flx#0021">fun gc_get_allocation_amt : unit -> ulong</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the total number of bytes currently allocated.
</p></div>
<pre>0025:    <a href="/share/lib/std/gc.flx#0025">fun gc_get_allocation_count : unit -> ulong</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the total number of objects currently allocated.
</p></div>
<pre>0029:    <a href="/share/lib/std/gc.flx#0029">fun gc_get_root_count : unit -> ulong</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the total number of roots.
</p></div>
<pre>0032:    <a href="/share/lib/std/gc.flx#0032">proc add_root: address</a></pre>
<pre>0035:    <a href="/share/lib/std/gc.flx#0035">proc remove_root: address</a></pre>
<hr/><a href="/share/lib/std/glob.flx">glob.flx</a>

<pre>0007:  <a href="/share/lib/std/glob.flx#0007">class glob</a></pre>
<pre>0018:    <a href="/share/lib/std/glob.flx#0018">gen glob: string * &glob_t -> bool</a></pre>
<pre>0019:    <a href="/share/lib/std/glob.flx#0019">proc globfree: &glob_t</a></pre>
<pre>0021:    <a href="/share/lib/std/glob.flx#0021">gen glob (pat:string): stl_vector[string]</a></pre>
<hr/><a href="/share/lib/std/io/__init__.flx">io/__init__.flx</a>
<hr/><a href="/share/lib/std/io/ansi_terminal.flx">io/ansi_terminal.flx</a>

<pre>0003:  <a href="/share/lib/std/io/ansi_terminal.flx#0003">class AnsiTerminal</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> #### Color output formatting for Ansi Terminals.
</p></div>
<pre>0006:    <a href="/share/lib/std/io/ansi_terminal.flx#0006">fun  NC_ ()</a></pre>
<pre>0007:    <a href="/share/lib/std/io/ansi_terminal.flx#0007">fun  NC_(s:string)</a></pre>
<pre>0008:    <a href="/share/lib/std/io/ansi_terminal.flx#0008">proc NC()</a></pre>
<pre>0009:    <a href="/share/lib/std/io/ansi_terminal.flx#0009">proc NC(s:string)</a></pre>
<pre>0010:    <a href="/share/lib/std/io/ansi_terminal.flx#0010">fun blue_()</a></pre>
<pre>0011:    <a href="/share/lib/std/io/ansi_terminal.flx#0011">fun blue_(s:string)</a></pre>
<pre>0012:    <a href="/share/lib/std/io/ansi_terminal.flx#0012">proc blue()</a></pre>
<pre>0013:    <a href="/share/lib/std/io/ansi_terminal.flx#0013">proc blue(s:string)</a></pre>
<pre>0014:    <a href="/share/lib/std/io/ansi_terminal.flx#0014">fun BLUE_()</a></pre>
<pre>0015:    <a href="/share/lib/std/io/ansi_terminal.flx#0015">fun BLUE_(s:string)</a></pre>
<pre>0016:    <a href="/share/lib/std/io/ansi_terminal.flx#0016">proc BLUE()</a></pre>
<pre>0017:    <a href="/share/lib/std/io/ansi_terminal.flx#0017">proc BLUE(s:string)</a></pre>
<pre>0018:    <a href="/share/lib/std/io/ansi_terminal.flx#0018">fun cyan_()</a></pre>
<pre>0019:    <a href="/share/lib/std/io/ansi_terminal.flx#0019">fun cyan_(s:string)</a></pre>
<pre>0020:    <a href="/share/lib/std/io/ansi_terminal.flx#0020">proc cyan()</a></pre>
<pre>0021:    <a href="/share/lib/std/io/ansi_terminal.flx#0021">proc cyan(s:string)</a></pre>
<pre>0022:    <a href="/share/lib/std/io/ansi_terminal.flx#0022">fun CYAN_()</a></pre>
<pre>0023:    <a href="/share/lib/std/io/ansi_terminal.flx#0023">fun CYAN_(s:string)</a></pre>
<pre>0024:    <a href="/share/lib/std/io/ansi_terminal.flx#0024">proc CYAN()</a></pre>
<pre>0025:    <a href="/share/lib/std/io/ansi_terminal.flx#0025">proc CYAN(s:string)</a></pre>
<pre>0026:    <a href="/share/lib/std/io/ansi_terminal.flx#0026">fun green_()</a></pre>
<pre>0027:    <a href="/share/lib/std/io/ansi_terminal.flx#0027">fun green_(s:string)</a></pre>
<pre>0028:    <a href="/share/lib/std/io/ansi_terminal.flx#0028">proc green()</a></pre>
<pre>0029:    <a href="/share/lib/std/io/ansi_terminal.flx#0029">proc green(s:string)</a></pre>
<pre>0030:    <a href="/share/lib/std/io/ansi_terminal.flx#0030">fun GREEN_()</a></pre>
<pre>0031:    <a href="/share/lib/std/io/ansi_terminal.flx#0031">fun GREEN_(s:string)</a></pre>
<pre>0032:    <a href="/share/lib/std/io/ansi_terminal.flx#0032">proc GREEN()</a></pre>
<pre>0033:    <a href="/share/lib/std/io/ansi_terminal.flx#0033">proc GREEN(s:string)</a></pre>
<pre>0034:    <a href="/share/lib/std/io/ansi_terminal.flx#0034">fun red_()</a></pre>
<pre>0035:    <a href="/share/lib/std/io/ansi_terminal.flx#0035">fun red_(s:string)</a></pre>
<pre>0036:    <a href="/share/lib/std/io/ansi_terminal.flx#0036">proc red()</a></pre>
<pre>0037:    <a href="/share/lib/std/io/ansi_terminal.flx#0037">proc red(s:string)</a></pre>
<pre>0038:    <a href="/share/lib/std/io/ansi_terminal.flx#0038">fun RED_()</a></pre>
<pre>0039:    <a href="/share/lib/std/io/ansi_terminal.flx#0039">fun RED_(s:string)</a></pre>
<pre>0040:    <a href="/share/lib/std/io/ansi_terminal.flx#0040">proc RED()</a></pre>
<pre>0041:    <a href="/share/lib/std/io/ansi_terminal.flx#0041">proc RED(s:string)</a></pre>
<pre>0042:    <a href="/share/lib/std/io/ansi_terminal.flx#0042">fun yellow_()</a></pre>
<pre>0043:    <a href="/share/lib/std/io/ansi_terminal.flx#0043">fun yellow_(s:string)</a></pre>
<pre>0044:    <a href="/share/lib/std/io/ansi_terminal.flx#0044">proc yellow()</a></pre>
<pre>0045:    <a href="/share/lib/std/io/ansi_terminal.flx#0045">proc yellow(s:string)</a></pre>
<pre>0046:    <a href="/share/lib/std/io/ansi_terminal.flx#0046">fun YELLOW_()</a></pre>
<pre>0047:    <a href="/share/lib/std/io/ansi_terminal.flx#0047">fun YELLOW_(s:string)</a></pre>
<pre>0048:    <a href="/share/lib/std/io/ansi_terminal.flx#0048">proc YELLOW()</a></pre>
<pre>0049:    <a href="/share/lib/std/io/ansi_terminal.flx#0049">proc YELLOW(s:string)</a></pre>
<hr/><a href="/share/lib/std/io/demux.flx">io/demux.flx</a>

<pre>0002:  <a href="/share/lib/std/io/demux.flx#0002">class Demux</a></pre>
<pre>0004:    <a href="/share/lib/std/io/demux.flx#0004">type demuxer</a></pre>
<pre>0007:    <a href="/share/lib/std/io/demux.flx#0007">gen mk_sys_demux: 1->demuxer</a></pre>
<hr/><a href="/share/lib/std/io/directory.flx">io/directory.flx</a>

<pre>0003:  <a href="/share/lib/std/io/directory.flx#0003">class Directory_class[os,mode_t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> File system directory services,
 Parametrised  by operating system and mode type.
</p></div>
<pre>0007:    <a href="/share/lib/std/io/directory.flx#0007">virtual gen mkdir: string * mode_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create a directory with specified mode.
 Returns 0 if successful.
</p></div>
<pre>0011:    <a href="/share/lib/std/io/directory.flx#0011">virtual gen mkdir: string -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create a directory with default mode.
 Returns 0 if successful.
</p></div>
<pre>0015:    <a href="/share/lib/std/io/directory.flx#0015">virtual proc mkdirs: string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Try to ensure all the directories in a path exist.
 Does not return any error indication.
</p></div>
<pre>0017:    <a href="/share/lib/std/io/directory.flx#0017">virtual gen unlink_empty_dir: string -> int</a></pre>
<pre>0023:    <a href="/share/lib/std/io/directory.flx#0023">virtual fun filesin:string -> opt[List::list[string]]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return an option list of all the regular files in a given directory.
 Returns None if the directory does not exist or isn't accessible.
 Returns Some ?files if the directory exists and is accessible.
 If the directory has no regular files, the list is Empty.
</p></div>
<pre>0026:    <a href="/share/lib/std/io/directory.flx#0026">virtual fun getcwd: 1 -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the absolute pathname of the current working directory.
</p></div>
<pre>0029:    <a href="/share/lib/std/io/directory.flx#0029">virtual fun mk_absolute_filename: string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert a relative filename to an absolute pathname. 
</p></div>

<pre>0034:  <a href="/share/lib/std/io/directory.flx#0034">class Directory</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Host file system directory services.
 Platform dependent.
</p></div>
<hr/><a href="/share/lib/std/io/faio.flx">io/faio.flx</a>

<pre>0001:  <a href="/share/lib/std/io/faio.flx#0001">class Faio</a></pre>
<pre>0007:    <a href="/share/lib/std/io/faio.flx#0007">proc faio_req[t](x:&t)</a></pre>
<pre>0012:    <a href="/share/lib/std/io/faio.flx#0012">proc get_thread(thread: &fthread)</a></pre>
<pre>0016:    <a href="/share/lib/std/io/faio.flx#0016">type sel_param</a></pre>
<pre>0017:    <a href="/share/lib/std/io/faio.flx#0017">type sel_param_ptr</a></pre>
<pre>0019:    <a href="/share/lib/std/io/faio.flx#0019">fun get_bytes_done : sel_param_ptr -> int</a></pre>
<pre>0020:    <a href="/share/lib/std/io/faio.flx#0020">proc init_pb : sel_param*address*int</a></pre>
<pre>0023:    <a href="/share/lib/std/io/faio.flx#0023">proc calc_eof(pb: sel_param_ptr, len: &int, eof: &bool)</a></pre>
<pre>0035:    <a href="/share/lib/std/io/faio.flx#0035">type sleep_request</a></pre>
<pre>0036:    <a href="/share/lib/std/io/faio.flx#0036">type alarm_clock</a></pre>
<pre>0038:    <a href="/share/lib/std/io/faio.flx#0038">fun mk_alarm_clock: 1 -> alarm_clock</a></pre>
<pre>0039:    <a href="/share/lib/std/io/faio.flx#0039">fun mk_sleep_request: alarm_clock * double -> sleep_request</a></pre>
<pre>0041:    <a href="/share/lib/std/io/faio.flx#0041">proc sleep(clock: alarm_clock, delta: double)</a></pre>
<hr/><a href="/share/lib/std/io/filename.flx">io/filename.flx</a>

<pre>0002:  <a href="/share/lib/std/io/filename.flx#0002">class Filename_class[os]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Operations on filenames.
</p></div>
<pre>0005:    <a href="/share/lib/std/io/filename.flx#0005">virtual fun sep: 1 -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The path separator.
</p></div>
<pre>0006:    <a href="/share/lib/std/io/filename.flx#0006">virtual fun is_absolute_filename : string -> bool</a></pre>
<pre>0008:    <a href="/share/lib/std/io/filename.flx#0008">virtual fun executable_extension : 1 -> string</a></pre>
<pre>0009:    <a href="/share/lib/std/io/filename.flx#0009">virtual fun static_object_extension: 1 -> string</a></pre>
<pre>0010:    <a href="/share/lib/std/io/filename.flx#0010">virtual fun dynamic_object_extension: 1 -> string</a></pre>
<pre>0011:    <a href="/share/lib/std/io/filename.flx#0011">virtual fun static_library_extension: 1 -> string</a></pre>
<pre>0012:    <a href="/share/lib/std/io/filename.flx#0012">virtual fun dynamic_library_extension: 1 -> string</a></pre>
<pre>0022:    <a href="/share/lib/std/io/filename.flx#0022">fun split1(s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> split1 returns a pair consisting of a directory name and basename
 with the separator between them lost except in the special case
 "/x" where the "/" is kept as the directory name.
 If there is no separator, the path is the basename and
 the directory name is the empty string (NOT . !!!)
</p></div>
<pre>0039:    <a href="/share/lib/std/io/filename.flx#0039">fun split(s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> split a filename into a list of components.
</p></div>
<pre>0048:    <a href="/share/lib/std/io/filename.flx#0048">fun join(p:string, b:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join two pathnames into a single pathname.
 split and join are logical inverses, however join is not
 not associative: join("x", join("","y")) = "x/y"
 whereas join(join("x",""),"y") = "x//y"
 since split pulls components off from the RHS we have to
 fold them back from the left
</p></div>
<pre>0057:    <a href="/share/lib/std/io/filename.flx#0057">fun basename(s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the basename of a path (last component).
</p></div>
<pre>0060:    <a href="/share/lib/std/io/filename.flx#0060">fun dirname(s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the directory name of a path (all but the last component).
</p></div>
<pre>0064:    <a href="/share/lib/std/io/filename.flx#0064">fun directories (s:string) : list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a list of all the directory names in a path.
 For example a/b/c gives "a", "a/b"
</p></div>
<pre>0072:    <a href="/share/lib/std/io/filename.flx#0072">fun join(a:string, b:string, c:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join 3 and 4 strings into a pathname.
</p></div>
<pre>0073:    <a href="/share/lib/std/io/filename.flx#0073">fun join(a:string, b:string, c:string,d:string)</a></pre>
<pre>0076:    <a href="/share/lib/std/io/filename.flx#0076">fun join(x:string) (y:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join 2 strings into a pathname (curried form).
</p></div>
<pre>0079:    <a href="/share/lib/std/io/filename.flx#0079">fun join(ps: List::list[string])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join all the strings in a list into a pathname.
</p></div>
<pre>0086:    <a href="/share/lib/std/io/filename.flx#0086">fun split_extension (s:string): string * string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Split off extension. Includes the dot. 
 Invariant: input = basename + extension.
 Works backwards until it hits a dot, path separator,
 or end of data. If a dot, strip it and the tail of the string,
 otherwise return the original string.
</p></div>
<pre>0099:    <a href="/share/lib/std/io/filename.flx#0099">fun strip_extension (s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Remove an extension from a filename if there is one.
</p></div>
<pre>0102:    <a href="/share/lib/std/io/filename.flx#0102">fun get_extension (s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get extension if there is one. Includes the dot.
</p></div>

<pre>0107:  <a href="/share/lib/std/io/filename.flx#0107">class Win32Filename</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Windows Filenames
</p></div>
<pre>0111:    <a href="/share/lib/std/io/filename.flx#0111">fun sep()</a></pre>
<pre>0112:    <a href="/share/lib/std/io/filename.flx#0112">fun executable_extension ()</a></pre>
<pre>0113:    <a href="/share/lib/std/io/filename.flx#0113">fun static_object_extension()</a></pre>
<pre>0114:    <a href="/share/lib/std/io/filename.flx#0114">fun dynamic_object_extension()</a></pre>
<pre>0115:    <a href="/share/lib/std/io/filename.flx#0115">fun static_library_extension()</a></pre>
<pre>0116:    <a href="/share/lib/std/io/filename.flx#0116">fun dynamic_library_extension()</a></pre>
<pre>0117:    <a href="/share/lib/std/io/filename.flx#0117">fun is_absolute_filename (f:string)</a></pre>

<pre>0126:  <a href="/share/lib/std/io/filename.flx#0126">class OsxFilename</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> OSX Filenames
</p></div>
<pre>0130:    <a href="/share/lib/std/io/filename.flx#0130">fun sep()</a></pre>
<pre>0131:    <a href="/share/lib/std/io/filename.flx#0131">fun executable_extension ()</a></pre>
<pre>0132:    <a href="/share/lib/std/io/filename.flx#0132">fun static_object_extension()</a></pre>
<pre>0133:    <a href="/share/lib/std/io/filename.flx#0133">fun dynamic_object_extension()</a></pre>
<pre>0134:    <a href="/share/lib/std/io/filename.flx#0134">fun static_library_extension()</a></pre>
<pre>0135:    <a href="/share/lib/std/io/filename.flx#0135">fun dynamic_library_extension()</a></pre>
<pre>0136:    <a href="/share/lib/std/io/filename.flx#0136">fun is_absolute_filename (f:string)</a></pre>

<pre>0142:  <a href="/share/lib/std/io/filename.flx#0142">class PosixFilename</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Posix Filenames
</p></div>
<pre>0146:    <a href="/share/lib/std/io/filename.flx#0146">fun sep()</a></pre>
<pre>0147:    <a href="/share/lib/std/io/filename.flx#0147">fun executable_extension ()</a></pre>
<pre>0148:    <a href="/share/lib/std/io/filename.flx#0148">fun static_object_extension()</a></pre>
<pre>0149:    <a href="/share/lib/std/io/filename.flx#0149">fun dynamic_object_extension()</a></pre>
<pre>0150:    <a href="/share/lib/std/io/filename.flx#0150">fun static_library_extension()</a></pre>
<pre>0151:    <a href="/share/lib/std/io/filename.flx#0151">fun dynamic_library_extension()</a></pre>
<pre>0152:    <a href="/share/lib/std/io/filename.flx#0152">fun is_absolute_filename (f:string)</a></pre>

<pre>0157:  <a href="/share/lib/std/io/filename.flx#0157">class Filename</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Host Filenames.
</p></div>
<hr/><a href="/share/lib/std/io/filestat.flx">io/filestat.flx</a>

<pre>0003:  <a href="/share/lib/std/io/filestat.flx#0003">class FileStat_class[OS,stat_t, mode_t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Filesystem file kind query functions parametrised
 by operating system, status type and mode type.
</p></div>
<pre>0007:    <a href="/share/lib/std/io/filestat.flx#0007">virtual proc stat: string * &stat_t * &int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get information about a file into a status buffer.
 Sets error code at argument 3 pointer.
</p></div>
<pre>0012:    <a href="/share/lib/std/io/filestat.flx#0012">virtual proc utime: string * double * double * &int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> set access and modification time of a file.
 Sets error code at argument 4 pointer.
 Times are in seconds, nominally from Epoch (Jan 1 1970).
</p></div>
<pre>0018:    <a href="/share/lib/std/io/filestat.flx#0018">virtual gen chmod: string * mode_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Change read,write permissions for group, owner etc.
 Return 0 on success.
 On Windows this function may silently fail to obey
 unsupported operations.
</p></div>
<pre>0023:    <a href="/share/lib/std/io/filestat.flx#0023">virtual gen umask: mode_t -> mode_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> set mask for subsequent permissions.
 On Windows this function may silently fail to obey
 unsupported operations.
</p></div>
<pre>0026:    <a href="/share/lib/std/io/filestat.flx#0026">union file_type_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Abstracted platform independent file type taxonomy.
</p></div>
<pre>0040:    <a href="/share/lib/std/io/filestat.flx#0040">virtual fun file_type: &stat_t -> file_type_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the file type from a file stat buffer.
</p></div>
<pre>0043:    <a href="/share/lib/std/io/filestat.flx#0043">gen stat(file: string, statbuf:&stat_t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fill a stat buffer with information about a file.
</p></div>
<pre>0051:    <a href="/share/lib/std/io/filestat.flx#0051">fun mtime: &stat_t -> double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get a file last modification time from a stat buffer.
 Time is in seconds.
</p></div>
<pre>0056:    <a href="/share/lib/std/io/filestat.flx#0056">fun ctime: &stat_t -> double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get a file creation time from a stat buffer.
 Note: not available on Unix.
 Time is in seconds.
</p></div>
<pre>0060:    <a href="/share/lib/std/io/filestat.flx#0060">fun filetime(f:string):double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get modification time of a file by name.
 Time is in seconds.
</p></div>
<pre>0069:    <a href="/share/lib/std/io/filestat.flx#0069">gen utime(f:string, a:double, m:double): bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Set the last access and modification time of a file by name.
</p></div>
<pre>0077:    <a href="/share/lib/std/io/filestat.flx#0077">gen utime(f:string, t:double)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Set the last access and modification time of a file by name,
 where the two times are given by a single argument.
</p></div>
<pre>0080:    <a href="/share/lib/std/io/filestat.flx#0080">fun fileexists(f:string):bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if a file exists.
</p></div>
<pre>0083:    <a href="/share/lib/std/io/filestat.flx#0083">fun filetype(f:string):file_type_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find the type of a file.
</p></div>
<pre>0097:    <a href="/share/lib/std/io/filestat.flx#0097">fun past_time ()</a></pre>
<pre>0098:    <a href="/share/lib/std/io/filestat.flx#0098">fun future_time ()</a></pre>
<pre>0100:    <a href="/share/lib/std/io/filestat.flx#0100">fun strfiletime0 (x:double)</a></pre>
<pre>0109:    <a href="/share/lib/std/io/filestat.flx#0109">fun strfiletime (x:double)</a></pre>
<pre>0114:    <a href="/share/lib/std/io/filestat.flx#0114">fun dfiletime(var f:string, dflt:double)</a></pre>

<pre>0126:  <a href="/share/lib/std/io/filestat.flx#0126">class FileStat</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Platform dependent operations for host file system.
</p></div>
<hr/><a href="/share/lib/std/io/filesystem.flx">io/filesystem.flx</a>

<pre>0003:  <a href="/share/lib/std/io/filesystem.flx#0003">class FileSystem_class[os]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Filesystem operations parametrised by operating system.
 YET TO BE DONE.
</p></div>

<pre>0008:  <a href="/share/lib/std/io/filesystem.flx#0008">class FileSystem</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Platform dependent filesystem operations for host file system.
</p></div>
<pre>0015:    <a href="/share/lib/std/io/filesystem.flx#0015">proc unlink(f:string)</a></pre>
<pre>0017:    <a href="/share/lib/std/io/filesystem.flx#0017">proc aux (d:string) (b:string)</a></pre>
<pre>0045:    <a href="/share/lib/std/io/filesystem.flx#0045">proc rm (f:string)</a></pre>
<pre>0048:    <a href="/share/lib/std/io/filesystem.flx#0048">fun find_in_path(x:string, path:list[string]):opt[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find a file in a list of directories.
</p></div>
<pre>0070:    <a href="/share/lib/std/io/filesystem.flx#0070">fun regfilesin(dname:string, re:string): list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find all the files matching an RE2-regular expression
 in a given directory. 
 NOTE: this search finds files in descendant directories too.
 The search is recursive, but the whole pathname within
 the specified directory must match the regexp.
 For example to find all *.flx files in src use:
   regfilesin("src", ".*[.]flx")
 To find the files only in the given directory, on Unix use instead
   regfilesin("src", "[^/]*[.]flx")
 to exclude files in child directories.
</p></div>
<pre>0073:    <a href="/share/lib/std/io/filesystem.flx#0073">fun regfilesin(dname:string, re:RE2): list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find all the files matching a compiled RE2-regular expression.
</p></div>
<pre>0077:    <a href="/share/lib/std/io/filesystem.flx#0077">proc rfi(dname2: string)</a></pre>
<hr/><a href="/share/lib/std/io/manymouse.flx">io/manymouse.flx</a>

<pre>0001:  <a href="/share/lib/std/io/manymouse.flx#0001">class ManyMouse</a></pre>
<pre>0014:    <a href="/share/lib/std/io/manymouse.flx#0014">struct ManyMouseEvent</a></pre>
<pre>0024:    <a href="/share/lib/std/io/manymouse.flx#0024">gen  ManyMouse_Init: 1 -> int</a></pre>
<pre>0025:    <a href="/share/lib/std/io/manymouse.flx#0025">fun  ManyMouse_DriverName: 1 -> string</a></pre>
<pre>0028:    <a href="/share/lib/std/io/manymouse.flx#0028">proc ManyMouse_Quit: 1</a></pre>
<pre>0029:    <a href="/share/lib/std/io/manymouse.flx#0029">fun  ManyMouse_DeviceName: uint -> string</a></pre>
<pre>0032:    <a href="/share/lib/std/io/manymouse.flx#0032">gen  ManyMouse_PollEvent: &ManyMouseEvent -> int</a></pre>
<hr/><a href="/share/lib/std/io/socket.flx">io/socket.flx</a>

<pre>0001:  <a href="/share/lib/std/io/socket.flx#0001">class Socket</a></pre>
<pre>0005:    <a href="/share/lib/std/io/socket.flx#0005">typedef socket_t</a></pre>
<pre>0007:    <a href="/share/lib/std/io/socket.flx#0007">typedef socket_t</a></pre>
<pre>0010:    <a href="/share/lib/std/io/socket.flx#0010">proc mk_listener(l: &socket_t, port: &int, qlen: int)</a></pre>
<pre>0019:    <a href="/share/lib/std/io/socket.flx#0019">proc accept(l: socket_t, s: &socket_t)</a></pre>
<pre>0033:    <a href="/share/lib/std/io/socket.flx#0033">proc shutdown(s: socket_t, how: int)</a></pre>
<pre>0042:    <a href="/share/lib/std/io/socket.flx#0042">proc connect(s: &socket_t, addr: +char, port: int, err: &int)</a></pre>
<pre>0058:    <a href="/share/lib/std/io/socket.flx#0058">proc read(s: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0061:    <a href="/share/lib/std/io/socket.flx#0061">proc read(s: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0069:    <a href="/share/lib/std/io/socket.flx#0069">proc write(s: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0076:    <a href="/share/lib/std/io/socket.flx#0076">proc write(s: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0086:    <a href="/share/lib/std/io/socket.flx#0086">proc iclose (s:socket_t)</a></pre>
<pre>0089:    <a href="/share/lib/std/io/socket.flx#0089">proc iclose (s:socket_t)</a></pre>
<pre>0097:    <a href="/share/lib/std/io/socket.flx#0097">proc oclose (s:socket_t)</a></pre>
<pre>0100:    <a href="/share/lib/std/io/socket.flx#0100">proc oclose (s:socket_t)</a></pre>
<pre>0108:    <a href="/share/lib/std/io/socket.flx#0108">proc ioclose (s:socket_t)</a></pre>
<pre>0124:    <a href="/share/lib/std/io/socket.flx#0124">proc ioclose (s:socket_t)</a></pre>
<hr/><a href="/share/lib/std/io/stream.flx">io/stream.flx</a>

<pre>0001:  <a href="/share/lib/std/io/stream.flx#0001">class Stream</a></pre>
<pre>0009:    <a href="/share/lib/std/io/stream.flx#0009">typedef fd_t</a></pre>
<pre>0012:    <a href="/share/lib/std/io/stream.flx#0012">typedef fd_t</a></pre>

<pre>0018:  <a href="/share/lib/std/io/stream.flx#0018">class IByteStream[T]</a></pre>

<pre>0024:  <a href="/share/lib/std/io/stream.flx#0024">class OByteStream[T]</a></pre>

<pre>0030:  <a href="/share/lib/std/io/stream.flx#0030">class IOByteStream[T]</a></pre>

<pre>0036:  <a href="/share/lib/std/io/stream.flx#0036">class TerminalIByteStream[T]</a></pre>

<pre>0044:  <a href="/share/lib/std/io/stream.flx#0044">class TerminalOByteStream[T]</a></pre>

<pre>0052:  <a href="/share/lib/std/io/stream.flx#0052">class TerminalIOByteStream[T]</a></pre>
<pre>0062:    <a href="/share/lib/std/io/stream.flx#0062">union devnull_t</a></pre>
<pre>0067:    <a href="/share/lib/std/io/stream.flx#0067">proc read(strm: devnull_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0075:    <a href="/share/lib/std/io/stream.flx#0075">proc write(strm: devnull_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0090:    <a href="/share/lib/std/io/stream.flx#0090">proc read(fd: fd_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0101:    <a href="/share/lib/std/io/stream.flx#0101">proc write(fd: fd_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0114:    <a href="/share/lib/std/io/stream.flx#0114">proc iclose (fd: fd_t)</a></pre>
<pre>0125:    <a href="/share/lib/std/io/stream.flx#0125">proc oclose (fd: fd_t)</a></pre>
<pre>0136:    <a href="/share/lib/std/io/stream.flx#0136">proc ioclose (fd: fd_t)</a></pre>
<pre>0148:    <a href="/share/lib/std/io/stream.flx#0148">proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]] (</a></pre>
<pre>0167:    <a href="/share/lib/std/io/stream.flx#0167">proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]] (</a></pre>
<pre>0181:    <a href="/share/lib/std/io/stream.flx#0181">proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]] (</a></pre>
<pre>0193:    <a href="/share/lib/std/io/stream.flx#0193">proc stream_cmp[istr1,istr2 with IByteStream[istr1], IByteStream[istr2]] (</a></pre>
<pre>0240:    <a href="/share/lib/std/io/stream.flx#0240">proc cmp[istr1, istr2 with IByteStream[istr1], IByteStream[istr2]] (</a></pre>
<pre>0254:    <a href="/share/lib/std/io/stream.flx#0254">proc echo[iostr with IOByteStream[iostr]] (</a></pre>
<pre>0264:    <a href="/share/lib/std/io/stream.flx#0264">proc tee[istr,ostr with IByteStream[istr], OByteStream[ostr]] (</a></pre>
<pre>0289:    <a href="/share/lib/std/io/stream.flx#0289">noinline proc get_line[istr with IByteStream[istr]] (</a></pre>
<pre>0316:    <a href="/share/lib/std/io/stream.flx#0316">proc write_string[ostr with OByteStream[ostr]] (</a></pre>
<hr/><a href="/share/lib/std/io/textio.flx">io/textio.flx</a>

<pre>0007:  <a href="/share/lib/std/io/textio.flx#0007">class Input_text_file[input_text_file]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> These classes provide simple I/O for text, primarily intended for
 naive use, debugging etc. This is because there is no error
 handling. This simplifies usage at the expense of correctness,
 and so these routines should not be used in production code.
 Abstract input file.
</p></div>
<pre>0010:    <a href="/share/lib/std/io/textio.flx#0010">virtual gen fopen_input: string -> input_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Open file for reading.
</p></div>
<pre>0013:    <a href="/share/lib/std/io/textio.flx#0013">virtual gen valid : input_text_file -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if the file was opened correctly.
</p></div>
<pre>0016:    <a href="/share/lib/std/io/textio.flx#0016">virtual proc fclose: input_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Close file.
</p></div>
<pre>0019:    <a href="/share/lib/std/io/textio.flx#0019">virtual gen load: input_text_file -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Load the rest of an open file.
</p></div>
<pre>0023:    <a href="/share/lib/std/io/textio.flx#0023">virtual gen readln: input_text_file -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Read one line with the trailing end-line mark included.
 Empty string indicates end of file.
</p></div>
<pre>0026:    <a href="/share/lib/std/io/textio.flx#0026">virtual gen feof : input_text_file -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check for end of file.
</p></div>

<pre>0030:  <a href="/share/lib/std/io/textio.flx#0030">class Output_text_file[output_text_file]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Abstract output file.
</p></div>
<pre>0033:    <a href="/share/lib/std/io/textio.flx#0033">virtual gen fopen_output: string -> output_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Open file for writing.
</p></div>
<pre>0036:    <a href="/share/lib/std/io/textio.flx#0036">virtual gen valid : output_text_file -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if the file was opened correctly.
</p></div>
<pre>0039:    <a href="/share/lib/std/io/textio.flx#0039">virtual proc fclose: output_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Close file.
</p></div>
<pre>0042:    <a href="/share/lib/std/io/textio.flx#0042">virtual proc writeln : output_text_file * string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write one line adding the trailing end line mark.
</p></div>
<pre>0045:    <a href="/share/lib/std/io/textio.flx#0045">virtual proc write : output_text_file * string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write a string.
</p></div>
<pre>0048:    <a href="/share/lib/std/io/textio.flx#0048">virtual proc write : output_text_file * utiny</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write a byte.
</p></div>
<pre>0051:    <a href="/share/lib/std/io/textio.flx#0051">virtual proc write : output_text_file * char</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write a char.
</p></div>
<pre>0054:    <a href="/share/lib/std/io/textio.flx#0054">virtual proc fflush: output_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Flush the buffers.
</p></div>
<pre>0057:    <a href="/share/lib/std/io/textio.flx#0057">proc save (fn:string, d:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Save string to file
</p></div>
<pre>0066:    <a href="/share/lib/std/io/textio.flx#0066">proc save (fn:string, lines:list[string])</a></pre>
<pre>0074:    <a href="/share/lib/std/io/textio.flx#0074">proc space (s:output_text_file)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write a space.
</p></div>
<pre>0077:    <a href="/share/lib/std/io/textio.flx#0077">proc endl (s:output_text_file)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write end of line mark.
</p></div>
<pre>0080:    <a href="/share/lib/std/io/textio.flx#0080">proc fprint[T with Str[T]] (s:output_text_file, x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write data with conversion using Str::str.
</p></div>
<pre>0083:    <a href="/share/lib/std/io/textio.flx#0083">proc fprintln[T with Str[T]] (s:output_text_file, x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write data with conversion using Str::str and end line mark.
</p></div>

<pre>0087:  <a href="/share/lib/std/io/textio.flx#0087">open class Cstdio</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> C standard IO with FILE*.
</p></div>
<pre>0090:    <a href="/share/lib/std/io/textio.flx#0090">type FILE</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C file type.
</p></div>
<pre>0092:    <a href="/share/lib/std/io/textio.flx#0092">pod type ifile</a></pre>
<pre>0093:    <a href="/share/lib/std/io/textio.flx#0093">pod type ofile</a></pre>
<pre>0097:    <a href="/share/lib/std/io/textio.flx#0097">fun load: string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Load file from filename.
 Note: loaded in binary mode not text mode!
</p></div>
<pre>0122:    <a href="/share/lib/std/io/textio.flx#0122">gen fopen_input: string -> ifile</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Standard input, can be redirected by flx_run.
 Standard output, can be redirected by flx_run.
 Standard error, can be redirected by flx_run.
 Standard input, redirected by shell.
 Standard output, redirected by shell.
 Standard error, redirected by shell.
 C standard IO as instance of Input_text_file.
</p></div>
<pre>0123:    <a href="/share/lib/std/io/textio.flx#0123">gen valid : ifile -> bool</a></pre>
<pre>0124:    <a href="/share/lib/std/io/textio.flx#0124">proc fclose: ifile</a></pre>
<pre>0125:    <a href="/share/lib/std/io/textio.flx#0125">gen load: ifile -> string</a></pre>
<pre>0126:    <a href="/share/lib/std/io/textio.flx#0126">gen readln: ifile -> string</a></pre>
<pre>0127:    <a href="/share/lib/std/io/textio.flx#0127">gen feof : ifile -> bool</a></pre>
<pre>0133:    <a href="/share/lib/std/io/textio.flx#0133">gen fopen_output: string -> ofile</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C standard IO as instance of Output_text_file.
</p></div>
<pre>0134:    <a href="/share/lib/std/io/textio.flx#0134">gen valid : ofile -> bool</a></pre>
<pre>0135:    <a href="/share/lib/std/io/textio.flx#0135">proc fclose: ofile</a></pre>
<pre>0136:    <a href="/share/lib/std/io/textio.flx#0136">proc writeln : ofile * string</a></pre>
<pre>0137:    <a href="/share/lib/std/io/textio.flx#0137">proc write : ofile * string</a></pre>
<pre>0138:    <a href="/share/lib/std/io/textio.flx#0138">proc write : ofile * utiny</a></pre>
<pre>0139:    <a href="/share/lib/std/io/textio.flx#0139">proc write : ofile * char</a></pre>
<pre>0140:    <a href="/share/lib/std/io/textio.flx#0140">proc fflush: ofile</a></pre>

<pre>0148:  <a href="/share/lib/std/io/textio.flx#0148">open class Iostream</a></pre>
<pre>0151:    <a href="/share/lib/std/io/textio.flx#0151">pod type istream</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> istream type.
</p></div>
<pre>0154:    <a href="/share/lib/std/io/textio.flx#0154">pod type ostream</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> ostream type.
</p></div>
<pre>0171:    <a href="/share/lib/std/io/textio.flx#0171">gen fopen_input: string -> istream</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Standard input, redirected by shell.
 Standard output, redirected by shell.
 Standard error, redirected by shell.
 Standard log, redirected by shell.
 C++ istream as instance of Input_text_file.
</p></div>
<pre>0172:    <a href="/share/lib/std/io/textio.flx#0172">gen valid : istream -> bool</a></pre>
<pre>0173:    <a href="/share/lib/std/io/textio.flx#0173">proc fclose: istream</a></pre>
<pre>0174:    <a href="/share/lib/std/io/textio.flx#0174">gen load: istream -> string</a></pre>
<pre>0175:    <a href="/share/lib/std/io/textio.flx#0175">gen readln: istream -> string</a></pre>
<pre>0176:    <a href="/share/lib/std/io/textio.flx#0176">gen feof : istream -> bool</a></pre>
<pre>0182:    <a href="/share/lib/std/io/textio.flx#0182">gen fopen_output: string -> ostream</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ ostream as instance of Output_text_file.
</p></div>
<pre>0183:    <a href="/share/lib/std/io/textio.flx#0183">gen valid : ostream -> bool</a></pre>
<pre>0184:    <a href="/share/lib/std/io/textio.flx#0184">proc fclose: ostream</a></pre>
<pre>0185:    <a href="/share/lib/std/io/textio.flx#0185">proc writeln : ostream * string</a></pre>
<pre>0186:    <a href="/share/lib/std/io/textio.flx#0186">proc write : ostream * string</a></pre>
<pre>0187:    <a href="/share/lib/std/io/textio.flx#0187">proc write : ostream * utiny</a></pre>
<pre>0188:    <a href="/share/lib/std/io/textio.flx#0188">proc write : ostream * char</a></pre>
<pre>0189:    <a href="/share/lib/std/io/textio.flx#0189">proc fflush: ostream</a></pre>
<pre>0204:    <a href="/share/lib/std/io/textio.flx#0204">proc print  [T with Str[T]] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> DEBUG OUTPUT UTILITIES! 
 DO NOT REQUIRE THREAD FRAME.
 NOT REDIRECTABLE BY DRIVER.
 (can be redirected by OS if OS can do it)
 Write string to output.
</p></div>
<pre>0207:    <a href="/share/lib/std/io/textio.flx#0207">proc println[T with Str[T]] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write string to output with end of line.
</p></div>
<pre>0210:    <a href="/share/lib/std/io/textio.flx#0210">proc endl()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write end of line on output.
</p></div>
<pre>0213:    <a href="/share/lib/std/io/textio.flx#0213">proc space()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write space on cout.
</p></div>
<pre>0216:    <a href="/share/lib/std/io/textio.flx#0216">proc fflush()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> flush buffers of cout.
</p></div>
<pre>0219:    <a href="/share/lib/std/io/textio.flx#0219">proc eprint  [T with Str[T]] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write string to cerr.
</p></div>
<pre>0222:    <a href="/share/lib/std/io/textio.flx#0222">proc eprintln[T with Str[T]] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write string to cerr with end of line.
</p></div>
<pre>0225:    <a href="/share/lib/std/io/textio.flx#0225">proc eendl()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write end of line on cerr.
</p></div>
<pre>0228:    <a href="/share/lib/std/io/textio.flx#0228">proc espace()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write space on cerr.
</p></div>
<hr/><a href="/share/lib/std/io/zmq.flx">io/zmq.flx</a>

<pre>0006:  <a href="/share/lib/std/io/zmq.flx#0006">class ZeroMQ</a></pre>
<pre>0016:    <a href="/share/lib/std/io/zmq.flx#0016">proc zmq_version: &int * &int * &int</a></pre>
<pre>0017:    <a href="/share/lib/std/io/zmq.flx#0017">fun zmq_version()</a></pre>
<pre>0034:    <a href="/share/lib/std/io/zmq.flx#0034">fun zmq_errno : 1-> errno_t</a></pre>
<pre>0035:    <a href="/share/lib/std/io/zmq.flx#0035">fun zmq_strerror : errno_t -> string</a></pre>
<pre>0037:    <a href="/share/lib/std/io/zmq.flx#0037">gen ewrap(var x:int)</a></pre>
<pre>0039:    <a href="/share/lib/std/io/zmq.flx#0039">proc zmq_validate (msg:string) (var retcode: int)</a></pre>
<pre>0045:    <a href="/share/lib/std/io/zmq.flx#0045">proc zmq_validate (var retcode: int)</a></pre>
<pre>0047:    <a href="/share/lib/std/io/zmq.flx#0047">fun zmq_check (msg:string) (var retcode:int)</a></pre>
<pre>0054:    <a href="/share/lib/std/io/zmq.flx#0054">fun zmq_check(var retcode: int)</a></pre>
<pre>0060:    <a href="/share/lib/std/io/zmq.flx#0060">typedef zmq_free_fn</a></pre>
<pre>0066:    <a href="/share/lib/std/io/zmq.flx#0066">gen make_zmq_msg_t : 1 -> zmq_msg_t</a></pre>
<pre>0069:    <a href="/share/lib/std/io/zmq.flx#0069">gen zmq_msg_init: zmq_msg_t->int</a></pre>
<pre>0070:    <a href="/share/lib/std/io/zmq.flx#0070">gen zmq_msg_init_size: zmq_msg_t * size -> int</a></pre>
<pre>0071:    <a href="/share/lib/std/io/zmq.flx#0071">gen zmq_msg_init_data: zmq_msg_t * address * size * zmq_free_fn * address -> int</a></pre>
<pre>0072:    <a href="/share/lib/std/io/zmq.flx#0072">gen zmq_msg_close: zmq_msg_t -> int</a></pre>
<pre>0074:    <a href="/share/lib/std/io/zmq.flx#0074">gen zmq_msg_move: zmq_msg_t * zmq_msg_t -> int</a></pre>
<pre>0075:    <a href="/share/lib/std/io/zmq.flx#0075">gen zmq_msg_copy: zmq_msg_t * zmq_msg_t -> int</a></pre>
<pre>0076:    <a href="/share/lib/std/io/zmq.flx#0076">fun zmq_msg_data: zmq_msg_t -> address</a></pre>
<pre>0077:    <a href="/share/lib/std/io/zmq.flx#0077">fun zmq_msg_size : zmq_msg_t -> size</a></pre>
<pre>0080:    <a href="/share/lib/std/io/zmq.flx#0080">pod type zmq_message_option_code_t</a></pre>
<pre>0083:    <a href="/share/lib/std/io/zmq.flx#0083">fun zmq_getmsgopt: zmq_msg_t * zmq_message_option_code_t * address * &size -> int</a></pre>
<pre>0089:    <a href="/share/lib/std/io/zmq.flx#0089">pod type zmq_context</a></pre>
<pre>0092:    <a href="/share/lib/std/io/zmq.flx#0092">gen zmq_init : int  -> zmq_context</a></pre>
<pre>0093:    <a href="/share/lib/std/io/zmq.flx#0093">gen zmq_term : zmq_context -> int</a></pre>
<pre>0099:    <a href="/share/lib/std/io/zmq.flx#0099">pod type zmq_socket</a></pre>
<pre>0101:    <a href="/share/lib/std/io/zmq.flx#0101">ctor zmq_socket : zmq_context * zmq_socket_type_t</a></pre>
<pre>0102:    <a href="/share/lib/std/io/zmq.flx#0102">gen zmq_close: zmq_socket -> int</a></pre>
<pre>0103:    <a href="/share/lib/std/io/zmq.flx#0103">gen zmq_bind : zmq_socket * string -> int</a></pre>
<pre>0104:    <a href="/share/lib/std/io/zmq.flx#0104">gen zmq_connect : zmq_socket * string -> int</a></pre>
<pre>0105:    <a href="/share/lib/std/io/zmq.flx#0105">fun valid: zmq_socket->bool</a></pre>
<pre>0118:    <a href="/share/lib/std/io/zmq.flx#0118">fun str: zmq_socket_type_t -> string</a></pre>
<pre>0148:    <a href="/share/lib/std/io/zmq.flx#0148">fun str:zmq_sockopts_tag-> string</a></pre>
<pre>0176:    <a href="/share/lib/std/io/zmq.flx#0176">union zmq_socket_options</a></pre>
<pre>0203:    <a href="/share/lib/std/io/zmq.flx#0203">fun str: zmq_socket_options -> string</a></pre>
<pre>0249:    <a href="/share/lib/std/io/zmq.flx#0249">gen set_sockopt(s: zmq_socket) (o: zmq_socket_options)</a></pre>
<pre>0275:    <a href="/share/lib/std/io/zmq.flx#0275">proc get_sockopt[T:blobkind](s:zmq_socket, o:zmq_sockopts_tag, pd:&T, ps: &size)</a></pre>
<pre>0301:    <a href="/share/lib/std/io/zmq.flx#0301">gen getsockopt(s: zmq_socket, o: zmq_sockopts_tag) : zmq_socket_options</a></pre>
<pre>0338:    <a href="/share/lib/std/io/zmq.flx#0338">gen zmq_send : zmq_socket * address * size * zmq_xmit_options_t -> int</a></pre>
<pre>0339:    <a href="/share/lib/std/io/zmq.flx#0339">gen zmq_recv : zmq_socket * address * size * zmq_xmit_options_t -> int</a></pre>
<pre>0340:    <a href="/share/lib/std/io/zmq.flx#0340">gen zmq_sendmsg : zmq_socket * zmq_msg_t * zmq_xmit_options_t  -> int</a></pre>
<pre>0341:    <a href="/share/lib/std/io/zmq.flx#0341">gen zmq_recvmsg : zmq_socket * zmq_msg_t * zmq_xmit_options_t -> int</a></pre>
<pre>0346:    <a href="/share/lib/std/io/zmq.flx#0346">type zmq_pollitem_flag_t</a></pre>
<pre>0350:    <a href="/share/lib/std/io/zmq.flx#0350">ctor short: zmq_pollitem_flag_t</a></pre>
<pre>0353:    <a href="/share/lib/std/io/zmq.flx#0353">fun str(x:zmq_pollitem_flag_t)</a></pre>
<pre>0363:    <a href="/share/lib/std/io/zmq.flx#0363">type zmq_poll_item</a></pre>
<pre>0364:    <a href="/share/lib/std/io/zmq.flx#0364">ctor zmq_poll_item: zmq_socket * zmq_pollitem_flag_t</a></pre>
<pre>0365:    <a href="/share/lib/std/io/zmq.flx#0365">fun revents: zmq_poll_item -> zmq_pollitem_flag_t</a></pre>
<pre>0367:    <a href="/share/lib/std/io/zmq.flx#0367">gen zmq_poll: carray[zmq_poll_item] * int * long -> int</a></pre>
<pre>0369:    <a href="/share/lib/std/io/zmq.flx#0369">gen zmq_poll(pits : varray[zmq_poll_item], t:double)</a></pre>

<pre>0380:  <a href="/share/lib/std/io/zmq.flx#0380">class Checked_ZeroMQ[T]</a></pre>
<pre>0384:    <a href="/share/lib/std/io/zmq.flx#0384">proc init_size (x:zmq_msg_t) (n:size)</a></pre>
<pre>0385:    <a href="/share/lib/std/io/zmq.flx#0385">proc init (x:zmq_msg_t)</a></pre>
<pre>0386:    <a href="/share/lib/std/io/zmq.flx#0386">proc close (x:zmq_msg_t)</a></pre>
<pre>0388:    <a href="/share/lib/std/io/zmq.flx#0388">fun _ctor_zmq_msg_t ()</a></pre>
<pre>0390:    <a href="/share/lib/std/io/zmq.flx#0390">proc init_string (x:zmq_msg_t) (s:string)</a></pre>
<pre>0397:    <a href="/share/lib/std/io/zmq.flx#0397">ctor string: zmq_msg_t</a></pre>
<pre>0399:    <a href="/share/lib/std/io/zmq.flx#0399">fun zmq_more(m:zmq_msg_t):bool</a></pre>
<pre>0408:    <a href="/share/lib/std/io/zmq.flx#0408">fun zmq_more (s:zmq_socket)</a></pre>
<pre>0414:    <a href="/share/lib/std/io/zmq.flx#0414">proc send_msg (s:zmq_socket) (m:zmq_msg_t)</a></pre>
<pre>0415:    <a href="/share/lib/std/io/zmq.flx#0415">proc send_string (s:zmq_socket) (m:string)</a></pre>
<pre>0416:    <a href="/share/lib/std/io/zmq.flx#0416">proc send_string_part (s:zmq_socket) (m:string)</a></pre>
<pre>0417:    <a href="/share/lib/std/io/zmq.flx#0417">proc recv_msg (s:zmq_socket) (m:zmq_msg_t)</a></pre>
<pre>0418:    <a href="/share/lib/std/io/zmq.flx#0418">proc recv_msg_dontwait (s:zmq_socket) (m:zmq_msg_t)</a></pre>
<pre>0419:    <a href="/share/lib/std/io/zmq.flx#0419">gen recv_string (s:zmq_socket)</a></pre>
<pre>0428:    <a href="/share/lib/std/io/zmq.flx#0428">gen recv_string_dontwait (s:zmq_socket)</a></pre>
<pre>0437:    <a href="/share/lib/std/io/zmq.flx#0437">ctor zmq_context : int</a></pre>
<pre>0438:    <a href="/share/lib/std/io/zmq.flx#0438">proc term (x:zmq_context)</a></pre>
<pre>0440:    <a href="/share/lib/std/io/zmq.flx#0440">fun check_socket(var x:zmq_socket)</a></pre>
<pre>0441:    <a href="/share/lib/std/io/zmq.flx#0441">gen mk_socket (c: zmq_context) (t:zmq_socket_type_t)</a></pre>
<pre>0442:    <a href="/share/lib/std/io/zmq.flx#0442">proc set_opt(s: zmq_socket) (o: zmq_socket_options)</a></pre>
<pre>0443:    <a href="/share/lib/std/io/zmq.flx#0443">fun get_opt(s: zmq_socket) (o: zmq_sockopts_tag) : zmq_socket_options</a></pre>
<pre>0445:    <a href="/share/lib/std/io/zmq.flx#0445">proc bind(x:zmq_socket) (a:string)</a></pre>
<pre>0446:    <a href="/share/lib/std/io/zmq.flx#0446">proc connect(x:zmq_socket) (a:string)</a></pre>
<pre>0447:    <a href="/share/lib/std/io/zmq.flx#0447">proc close (s:zmq_socket)</a></pre>
<pre>0449:    <a href="/share/lib/std/io/zmq.flx#0449">gen poll(pits:varray[zmq_poll_item], timeout:double)</a></pre>
<pre>0452:    <a href="/share/lib/std/io/zmq.flx#0452">proc send_strings (s:zmq_socket) (ss:varray[string])</a></pre>
<pre>0462:    <a href="/share/lib/std/io/zmq.flx#0462">proc send_strings (s:zmq_socket) (ss:list[string])</a></pre>
<pre>0466:    <a href="/share/lib/std/io/zmq.flx#0466">gen recv_strings (s:zmq_socket) : varray[string]</a></pre>
<pre>0479:    <a href="/share/lib/std/io/zmq.flx#0479">type zmq_ehandler_t</a></pre>
<pre>0482:    <a href="/share/lib/std/io/zmq.flx#0482">fun ehandler():any</a></pre>

<pre>0489:  <a href="/share/lib/std/io/zmq.flx#0489">class ZMQ</a></pre>
<hr/><a href="/share/lib/std/linux/linux.flx">linux/linux.flx</a>
<pre>0004:    <a href="/share/lib/std/linux/linux.flx#0004">fun get_cpu_nr: 1 -> int</a></pre>
<hr/><a href="/share/lib/std/linux/smaps.flx">linux/smaps.flx</a>

<pre>0017:  <a href="/share/lib/std/linux/smaps.flx#0017">class Smaps</a></pre>
<pre>0019:    <a href="/share/lib/std/linux/smaps.flx#0019">struct smaps_metric</a></pre>
<pre>0036:    <a href="/share/lib/std/linux/smaps.flx#0036">fun getpid: ()->Process::pid_t</a></pre>
<pre>0038:    <a href="/share/lib/std/linux/smaps.flx#0038">fun pid_touint: Process::pid_t->uint</a></pre>
<pre>0040:    <a href="/share/lib/std/linux/smaps.flx#0040">fun uint_topid: uint->Process::pid_t</a></pre>
<pre>0042:    <a href="/share/lib/std/linux/smaps.flx#0042">fun min_whitespace(s:string)</a></pre>
<pre>0060:    <a href="/share/lib/std/linux/smaps.flx#0060">fun smaps_total(p:Process::pid_t,path:string):smaps_metric</a></pre>
<hr/><a href="/share/lib/std/order.flx">order.flx</a>

<pre>0003:  <a href="/share/lib/std/order.flx#0003">class Eq[t]</a></pre>
<pre>0011:    <a href="/share/lib/std/order.flx#0011">fun eq(x:t, y:t)</a></pre>
<pre>0012:    <a href="/share/lib/std/order.flx#0012">fun ne(x:t, y:t)</a></pre>

<pre>0016:  <a href="/share/lib/std/order.flx#0016">class Pord[t]</a></pre>

<pre>0028:  <a href="/share/lib/std/order.flx#0028">class Tord[t]</a></pre>
<pre>0043:    <a href="/share/lib/std/order.flx#0043">fun lt (x:t,y:t): bool</a></pre>
<pre>0044:    <a href="/share/lib/std/order.flx#0044">fun gt(x:t,y:t):bool</a></pre>
<pre>0045:    <a href="/share/lib/std/order.flx#0045">fun le (x:t,y:t):bool</a></pre>
<pre>0046:    <a href="/share/lib/std/order.flx#0046">fun ge (x:t,y:t):bool</a></pre>
<pre>0047:    <a href="/share/lib/std/order.flx#0047">fun max(x:t,y:t):t</a></pre>
<pre>0048:    <a href="/share/lib/std/order.flx#0048">fun min(x:t,y:t):t</a></pre>

<pre>0052:  <a href="/share/lib/std/order.flx#0052">class Forward[t]</a></pre>
<pre>0053:    <a href="/share/lib/std/order.flx#0053">virtual fun succ: t -> t</a></pre>
<pre>0054:    <a href="/share/lib/std/order.flx#0054">virtual proc pre_incr: &t</a></pre>
<pre>0055:    <a href="/share/lib/std/order.flx#0055">virtual proc post_incr: &t</a></pre>

<pre>0058:  <a href="/share/lib/std/order.flx#0058">class Bidirectional[t]</a></pre>
<pre>0060:    <a href="/share/lib/std/order.flx#0060">virtual fun pred: t -> t</a></pre>
<pre>0061:    <a href="/share/lib/std/order.flx#0061">virtual proc pre_decr: &t</a></pre>
<pre>0062:    <a href="/share/lib/std/order.flx#0062">virtual proc post_decr: &t</a></pre>
<hr/><a href="/share/lib/std/osx/__init__.flx">osx/__init__.flx</a>
<pre>0001:    <a href="/share/lib/std/osx/__init__.flx#0001">struct Osx</a></pre>
<hr/><a href="/share/lib/std/posix/__init__.flx">posix/__init__.flx</a>
<pre>0001:    <a href="/share/lib/std/posix/__init__.flx#0001">struct Posix</a></pre>
<hr/><a href="/share/lib/std/posix/directory.flx">posix/directory.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/directory.flx#0001">class PosixDirectory</a></pre>
<pre>0004:    <a href="/share/lib/std/posix/directory.flx#0004">type dirent_t</a></pre>
<pre>0005:    <a href="/share/lib/std/posix/directory.flx#0005">type DIR_t</a></pre>
<pre>0006:    <a href="/share/lib/std/posix/directory.flx#0006">proc opendir: string * &DIR_t</a></pre>
<pre>0007:    <a href="/share/lib/std/posix/directory.flx#0007">fun isNULL: DIR_t -> bool</a></pre>
<pre>0008:    <a href="/share/lib/std/posix/directory.flx#0008">fun isNULL: dirent_t -> bool</a></pre>
<pre>0009:    <a href="/share/lib/std/posix/directory.flx#0009">proc readdir: DIR_t * dirent_t * &dirent_t * &int</a></pre>
<pre>0010:    <a href="/share/lib/std/posix/directory.flx#0010">proc closedir: DIR_t</a></pre>
<pre>0011:    <a href="/share/lib/std/posix/directory.flx#0011">fun filename: dirent_t -> string</a></pre>
<pre>0019:    <a href="/share/lib/std/posix/directory.flx#0019">gen mkdir: string * PosixFileStat::mode_t -> int</a></pre>
<pre>0020:    <a href="/share/lib/std/posix/directory.flx#0020">gen mkdir: string  -> int</a></pre>
<pre>0021:    <a href="/share/lib/std/posix/directory.flx#0021">proc mkdirs (s:string)</a></pre>
<pre>0031:    <a href="/share/lib/std/posix/directory.flx#0031">gen unlink_empty_dir : string -> int</a></pre>
<pre>0034:    <a href="/share/lib/std/posix/directory.flx#0034">fun getcwd():string</a></pre>
<pre>0039:    <a href="/share/lib/std/posix/directory.flx#0039">fun mk_absolute_filename(s:string)</a></pre>
<pre>0043:    <a href="/share/lib/std/posix/directory.flx#0043">fun filesin(dname:string): opt[List::list[string]]</a></pre>
<hr/><a href="/share/lib/std/posix/errno.flx">posix/errno.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/errno.flx#0001">open class Errno</a></pre>
<pre>0003:    <a href="/share/lib/std/posix/errno.flx#0003">pod type errno_t</a></pre>
<pre>0004:    <a href="/share/lib/std/posix/errno.flx#0004">ctor int : errno_t</a></pre>
<pre>0005:    <a href="/share/lib/std/posix/errno.flx#0005">ctor errno_t : int</a></pre>
<pre>0021:    <a href="/share/lib/std/posix/errno.flx#0021">proc maybe_exit(var n:int)</a></pre>
<pre>0022:    <a href="/share/lib/std/posix/errno.flx#0022">proc maybe_exit(var n:errno_t)</a></pre>
<pre>0023:    <a href="/share/lib/std/posix/errno.flx#0023">proc maybe_exit()</a></pre>
<pre>0028:    <a href="/share/lib/std/posix/errno.flx#0028">proc strerror_r: errno_t *  carray[char] * size</a></pre>
<pre>0032:    <a href="/share/lib/std/posix/errno.flx#0032">proc strerror_r: errno_t * carray[char] * size</a></pre>
<pre>0036:    <a href="/share/lib/std/posix/errno.flx#0036">fun strerror(e:errno_t) : string</a></pre>
<pre>0048:    <a href="/share/lib/std/posix/errno.flx#0048">gen strerror()</a></pre>

<pre>0054:  <a href="/share/lib/std/posix/errno.flx#0054">class Check[T]</a></pre>
<pre>0056:    <a href="/share/lib/std/posix/errno.flx#0056">proc int_to_proc (var x:int)</a></pre>
<pre>0057:    <a href="/share/lib/std/posix/errno.flx#0057">fun int_to_int (var x:int)</a></pre>
<pre>0058:    <a href="/share/lib/std/posix/errno.flx#0058">fun pointer_to_pointer[U] (var p:&U)</a></pre>
<pre>0062:    <a href="/share/lib/std/posix/errno.flx#0062">type check_ignore</a></pre>
<pre>0065:    <a href="/share/lib/std/posix/errno.flx#0065">fun ehandler ():any</a></pre>
<pre>0067:    <a href="/share/lib/std/posix/errno.flx#0067">type check_throw</a></pre>
<pre>0070:    <a href="/share/lib/std/posix/errno.flx#0070">fun ehandler ():any</a></pre>
<hr/><a href="/share/lib/std/posix/faio_posix.flx">posix/faio_posix.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/faio_posix.flx#0001">class Faio_posix</a></pre>
<pre>0014:    <a href="/share/lib/std/posix/faio_posix.flx#0014">fun sys_job_queue_qbound()</a></pre>
<pre>0015:    <a href="/share/lib/std/posix/faio_posix.flx#0015">fun sys_job_queue_nthreads()</a></pre>
<pre>0019:    <a href="/share/lib/std/posix/faio_posix.flx#0019">typedef fd_t</a></pre>
<pre>0022:    <a href="/share/lib/std/posix/faio_posix.flx#0022">type socket_t</a></pre>
<pre>0026:    <a href="/share/lib/std/posix/faio_posix.flx#0026">type socklen_t</a></pre>
<pre>0027:    <a href="/share/lib/std/posix/faio_posix.flx#0027">ctor socklen_t : int</a></pre>
<pre>0028:    <a href="/share/lib/std/posix/faio_posix.flx#0028">ctor int : socklen_t</a></pre>
<pre>0039:    <a href="/share/lib/std/posix/faio_posix.flx#0039">type sa_family_t</a></pre>
<pre>0042:    <a href="/share/lib/std/posix/faio_posix.flx#0042">type in_port_t</a></pre>
<pre>0049:    <a href="/share/lib/std/posix/faio_posix.flx#0049">type sockaddr_storage_t</a></pre>
<pre>0050:    <a href="/share/lib/std/posix/faio_posix.flx#0050">fun ss_family : &sockaddr_storage_t -> sa_family_t</a></pre>
<pre>0053:    <a href="/share/lib/std/posix/faio_posix.flx#0053">type sockaddr_t</a></pre>
<pre>0054:    <a href="/share/lib/std/posix/faio_posix.flx#0054">fun sa_family : &sockaddr_t -> sa_family_t</a></pre>
<pre>0057:    <a href="/share/lib/std/posix/faio_posix.flx#0057">fun sockaddr_p : &sockaddr_storage_t -> &sockaddr_t</a></pre>
<pre>0063:    <a href="/share/lib/std/posix/faio_posix.flx#0063">type in_addr_t</a></pre>
<pre>0064:    <a href="/share/lib/std/posix/faio_posix.flx#0064">type struct_in_addr</a></pre>
<pre>0065:    <a href="/share/lib/std/posix/faio_posix.flx#0065">fun s_addr: struct_in_addr -> in_addr_t</a></pre>
<pre>0068:    <a href="/share/lib/std/posix/faio_posix.flx#0068">type sockaddr_in_t</a></pre>
<pre>0069:    <a href="/share/lib/std/posix/faio_posix.flx#0069">fun sin_family: sockaddr_in_t -> sa_family_t</a></pre>
<pre>0070:    <a href="/share/lib/std/posix/faio_posix.flx#0070">fun sin_port : sockaddr_in_t -> in_port_t</a></pre>
<pre>0071:    <a href="/share/lib/std/posix/faio_posix.flx#0071">fun sin_addr : sockaddr_in_t -> struct_in_addr</a></pre>
<pre>0072:    <a href="/share/lib/std/posix/faio_posix.flx#0072">fun sin_addr : &sockaddr_in_t -> &struct_in_addr</a></pre>
<pre>0078:    <a href="/share/lib/std/posix/faio_posix.flx#0078">type struct_in6_addr</a></pre>
<pre>0079:    <a href="/share/lib/std/posix/faio_posix.flx#0079">typedef ipv6_addr</a></pre>
<pre>0080:    <a href="/share/lib/std/posix/faio_posix.flx#0080">fun s6_addr: struct_in6_addr -> &ipv6_addr</a></pre>
<pre>0083:    <a href="/share/lib/std/posix/faio_posix.flx#0083">type sockaddr_in6_t</a></pre>
<pre>0084:    <a href="/share/lib/std/posix/faio_posix.flx#0084">fun sin6_family: sockaddr_in6_t -> sa_family_t</a></pre>
<pre>0085:    <a href="/share/lib/std/posix/faio_posix.flx#0085">fun sin6_port : sockaddr_in6_t -> in_port_t</a></pre>
<pre>0086:    <a href="/share/lib/std/posix/faio_posix.flx#0086">fun sin6_addr : sockaddr_in6_t -> struct_in6_addr</a></pre>
<pre>0087:    <a href="/share/lib/std/posix/faio_posix.flx#0087">fun sin6_addr : &sockaddr_in6_t -> &struct_in6_addr</a></pre>
<pre>0095:    <a href="/share/lib/std/posix/faio_posix.flx#0095">fun inet_ntop: sa_family_t * address * +char * socklen_t -> +char requires arpa_inet_h;</a></pre>
<pre>0102:    <a href="/share/lib/std/posix/faio_posix.flx#0102">fun str: FileSystem::posix_file -> string</a></pre>
<pre>0106:    <a href="/share/lib/std/posix/faio_posix.flx#0106">fun str: socket_t -> string</a></pre>
<pre>0109:    <a href="/share/lib/std/posix/faio_posix.flx#0109">fun getpeername: socket_t * &sockaddr_t * &socklen_t -> int</a></pre>
<pre>0111:    <a href="/share/lib/std/posix/faio_posix.flx#0111">fun getpeername (s: socket_t) : string</a></pre>
<pre>0173:    <a href="/share/lib/std/posix/faio_posix.flx#0173">proc close: socket_t</a></pre>
<pre>0174:    <a href="/share/lib/std/posix/faio_posix.flx#0174">proc shutdown: socket_t*int</a></pre>
<pre>0175:    <a href="/share/lib/std/posix/faio_posix.flx#0175">fun bad_socket : socket_t -> bool</a></pre>
<pre>0179:    <a href="/share/lib/std/posix/faio_posix.flx#0179">gen aio_ropen: string -> FileSystem::posix_file</a></pre>
<pre>0181:    <a href="/share/lib/std/posix/faio_posix.flx#0181">gen aio_wopen: string -> FileSystem::posix_file</a></pre>
<pre>0183:    <a href="/share/lib/std/posix/faio_posix.flx#0183">gen aio_rwopen: string -> FileSystem::posix_file</a></pre>
<pre>0185:    <a href="/share/lib/std/posix/faio_posix.flx#0185">gen aio_creat: string * posix_permissions-> FileSystem::posix_file</a></pre>
<pre>0190:    <a href="/share/lib/std/posix/faio_posix.flx#0190">type socketio_request</a></pre>
<pre>0192:    <a href="/share/lib/std/posix/faio_posix.flx#0192">gen mk_socketio_request: demuxer * socket_t*address*int*bool -> socketio_request</a></pre>
<pre>0195:    <a href="/share/lib/std/posix/faio_posix.flx#0195">fun get_pb: socketio_request -> sel_param_ptr</a></pre>
<pre>0198:    <a href="/share/lib/std/posix/faio_posix.flx#0198">proc async_rw(fd: socket_t, len: &int, buf: address, eof: &bool, read_flag: bool)</a></pre>
<pre>0209:    <a href="/share/lib/std/posix/faio_posix.flx#0209">proc async_read(fd: socket_t, len: &int, buf: address,</a></pre>
<pre>0215:    <a href="/share/lib/std/posix/faio_posix.flx#0215">proc async_write(fd: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0222:    <a href="/share/lib/std/posix/faio_posix.flx#0222">type flxfileio_request</a></pre>
<pre>0225:    <a href="/share/lib/std/posix/faio_posix.flx#0225">type async_connect</a></pre>
<pre>0227:    <a href="/share/lib/std/posix/faio_posix.flx#0227">fun mk_async_connect: demuxer * +char *int-> async_connect</a></pre>
<pre>0228:    <a href="/share/lib/std/posix/faio_posix.flx#0228">fun get_socket: async_connect -> socket_t</a></pre>
<pre>0229:    <a href="/share/lib/std/posix/faio_posix.flx#0229">fun get_err: async_connect -> int</a></pre>
<pre>0232:    <a href="/share/lib/std/posix/faio_posix.flx#0232">proc connect(s: &socket_t, addr: +char, port: int, err: &int)</a></pre>
<pre>0240:    <a href="/share/lib/std/posix/faio_posix.flx#0240">type accept_request</a></pre>
<pre>0242:    <a href="/share/lib/std/posix/faio_posix.flx#0242">fun mk_accept: demuxer * socket_t -> accept_request</a></pre>
<pre>0243:    <a href="/share/lib/std/posix/faio_posix.flx#0243">fun get_socket: accept_request -> socket_t</a></pre>
<pre>0246:    <a href="/share/lib/std/posix/faio_posix.flx#0246">proc mk_listener: &socket_t* &int *int</a></pre>
<pre>0249:    <a href="/share/lib/std/posix/faio_posix.flx#0249">proc accept(s: &socket_t, listener: socket_t)</a></pre>
<pre>0259:    <a href="/share/lib/std/posix/faio_posix.flx#0259">fun mk_faio: job_queue * FileSystem::posix_file *address*int*int*bool -> flxfileio_request</a></pre>
<pre>0261:    <a href="/share/lib/std/posix/faio_posix.flx#0261">fun get_pb: flxfileio_request -> sel_param_ptr</a></pre>
<pre>0263:    <a href="/share/lib/std/posix/faio_posix.flx#0263">proc faio_rw(q:job_queue, fd: FileSystem::posix_file, len: &int, buf: address, eof: &bool, read_flag: bool)</a></pre>
<pre>0271:    <a href="/share/lib/std/posix/faio_posix.flx#0271">proc faio_read(fd: FileSystem::posix_file, len: &int, buf: address,</a></pre>
<pre>0279:    <a href="/share/lib/std/posix/faio_posix.flx#0279">proc faio_write(fd: FileSystem::posix_file, len: &int, buf: address, eof: &bool)</a></pre>
<hr/><a href="/share/lib/std/posix/filestat.flx">posix/filestat.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/filestat.flx#0001">class PosixFileStat</a></pre>
<pre>0003:    <a href="/share/lib/std/posix/filestat.flx#0003">pod type stat_t</a></pre>
<pre>0005:    <a href="/share/lib/std/posix/filestat.flx#0005">pod type mode_t</a></pre>
<pre>0046:    <a href="/share/lib/std/posix/filestat.flx#0046">fun raw_mode: &stat_t -> mode_t</a></pre>
<pre>0047:    <a href="/share/lib/std/posix/filestat.flx#0047">fun file_type(m:mode_t)</a></pre>
<pre>0048:    <a href="/share/lib/std/posix/filestat.flx#0048">fun file_perm(m:mode_t)</a></pre>
<pre>0050:    <a href="/share/lib/std/posix/filestat.flx#0050">ctor uint: mode_t</a></pre>
<pre>0057:    <a href="/share/lib/std/posix/filestat.flx#0057">proc stat: string * &stat_t * &int</a></pre>
<pre>0059:    <a href="/share/lib/std/posix/filestat.flx#0059">proc utime: string * double * double * &int</a></pre>
<pre>0071:    <a href="/share/lib/std/posix/filestat.flx#0071">gen chmod: string * mode_t -> int</a></pre>
<pre>0072:    <a href="/share/lib/std/posix/filestat.flx#0072">gen umask: mode_t -> mode_t</a></pre>
<pre>0074:    <a href="/share/lib/std/posix/filestat.flx#0074">fun file_type (s:&stat_t): file_type_t</a></pre>
<hr/><a href="/share/lib/std/posix/filesystem.flx">posix/filesystem.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/filesystem.flx#0001">class PosixFileSystem</a></pre>
<pre>0006:    <a href="/share/lib/std/posix/filesystem.flx#0006">pod type file_perm_t</a></pre>
<pre>0026:    <a href="/share/lib/std/posix/filesystem.flx#0026">pod type posix_file</a></pre>
<pre>0027:    <a href="/share/lib/std/posix/filesystem.flx#0027">fun valid: posix_file -> bool</a></pre>
<pre>0028:    <a href="/share/lib/std/posix/filesystem.flx#0028">ctor int : posix_file</a></pre>
<pre>0033:    <a href="/share/lib/std/posix/filesystem.flx#0033">gen open: string * file_perm_t * PosixFileStat::mode_t -> posix_file</a></pre>
<pre>0034:    <a href="/share/lib/std/posix/filesystem.flx#0034">gen open: string * file_perm_t -> posix_file</a></pre>
<pre>0036:    <a href="/share/lib/std/posix/filesystem.flx#0036">gen ropen: string -> posix_file</a></pre>
<pre>0037:    <a href="/share/lib/std/posix/filesystem.flx#0037">gen wopen: string -> posix_file</a></pre>
<pre>0038:    <a href="/share/lib/std/posix/filesystem.flx#0038">gen rwopen: string -> posix_file</a></pre>
<pre>0039:    <a href="/share/lib/std/posix/filesystem.flx#0039">gen creat: string * PosixFileStat::mode_t-> posix_file</a></pre>
<pre>0041:    <a href="/share/lib/std/posix/filesystem.flx#0041">gen close: posix_file -> int</a></pre>
<pre>0042:    <a href="/share/lib/std/posix/filesystem.flx#0042">gen read: posix_file * &char * size -> size</a></pre>
<pre>0043:    <a href="/share/lib/std/posix/filesystem.flx#0043">gen write: posix_file * &char * size -> size</a></pre>
<pre>0045:    <a href="/share/lib/std/posix/filesystem.flx#0045">gen dup: posix_file -> posix_file</a></pre>
<pre>0046:    <a href="/share/lib/std/posix/filesystem.flx#0046">gen dup2: posix_file * posix_file -> posix_file</a></pre>
<pre>0048:    <a href="/share/lib/std/posix/filesystem.flx#0048">struct _piper_hack</a></pre>
<pre>0060:    <a href="/share/lib/std/posix/filesystem.flx#0060">gen pipe ()</a></pre>
<pre>0062:    <a href="/share/lib/std/posix/filesystem.flx#0062">gen fdopen_input: posix_file ->  ifile</a></pre>
<pre>0063:    <a href="/share/lib/std/posix/filesystem.flx#0063">gen fdopen_output: posix_file ->  ofile</a></pre>
<pre>0068:    <a href="/share/lib/std/posix/filesystem.flx#0068">gen unlink_file: string -> int</a></pre>
<pre>0074:    <a href="/share/lib/std/posix/filesystem.flx#0074">gen rename_file: string * string -> int</a></pre>
<pre>0081:    <a href="/share/lib/std/posix/filesystem.flx#0081">gen filecopy(src: string, dst: string) :  bool</a></pre>
<pre>0149:    <a href="/share/lib/std/posix/filesystem.flx#0149">gen tmp_filename: 1 -> string</a></pre>
<hr/><a href="/share/lib/std/posix/mmap.flx">posix/mmap.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/mmap.flx#0001">class Mmap</a></pre>
<pre>0012:    <a href="/share/lib/std/posix/mmap.flx#0012">typedef off_t</a></pre>
<pre>0014:    <a href="/share/lib/std/posix/mmap.flx#0014">type mmap_prot</a></pre>
<pre>0024:    <a href="/share/lib/std/posix/mmap.flx#0024">type mmap_flags</a></pre>
<pre>0073:    <a href="/share/lib/std/posix/mmap.flx#0073">fun mmap:</a></pre>
<pre>0083:    <a href="/share/lib/std/posix/mmap.flx#0083">fun munmap: address * size -> int</a></pre>
<pre>0086:    <a href="/share/lib/std/posix/mmap.flx#0086">fun msync: address * size * int -> int</a></pre>
<hr/><a href="/share/lib/std/posix/posix_headers.flx">posix/posix_headers.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/posix_headers.flx#0001">class Posix_headers</a></pre>
<hr/><a href="/share/lib/std/posix/process.flx">posix/process.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/process.flx#0001">class PosixProcess</a></pre>
<pre>0006:    <a href="/share/lib/std/posix/process.flx#0006">gen popen_in: string -> Cstdio::ifile</a></pre>
<pre>0007:    <a href="/share/lib/std/posix/process.flx#0007">gen pclose: Cstdio::ifile -> process_status_t</a></pre>
<pre>0011:    <a href="/share/lib/std/posix/process.flx#0011">type process_status_t</a></pre>
<pre>0012:    <a href="/share/lib/std/posix/process.flx#0012">ctor int:process_status_t</a></pre>
<pre>0013:    <a href="/share/lib/std/posix/process.flx#0013">ctor process_status_t : int</a></pre>
<pre>0014:    <a href="/share/lib/std/posix/process.flx#0014">fun int_of_process_status_t: process_status_t -> int</a></pre>
<pre>0016:    <a href="/share/lib/std/posix/process.flx#0016">fun WIFCONTINUED: process_status_t -> bool</a></pre>
<pre>0017:    <a href="/share/lib/std/posix/process.flx#0017">fun WIFEXITED: process_status_t -> bool</a></pre>
<pre>0018:    <a href="/share/lib/std/posix/process.flx#0018">fun WIFSIGNALED: process_status_t -> bool</a></pre>
<pre>0019:    <a href="/share/lib/std/posix/process.flx#0019">fun WIFSTOPPED: process_status_t -> bool</a></pre>
<pre>0021:    <a href="/share/lib/std/posix/process.flx#0021">fun WEXITSTATUS: process_status_t -> int</a></pre>
<pre>0022:    <a href="/share/lib/std/posix/process.flx#0022">fun WTERMSIG: process_status_t -> signal_t</a></pre>
<pre>0023:    <a href="/share/lib/std/posix/process.flx#0023">fun WSTOPSIG: process_status_t -> signal_t</a></pre>
<pre>0026:    <a href="/share/lib/std/posix/process.flx#0026">fun  WCOREDUMP: process_status_t -> int</a></pre>
<pre>0029:    <a href="/share/lib/std/posix/process.flx#0029">fun str(x:process_status_t)</a></pre>
<pre>0043:    <a href="/share/lib/std/posix/process.flx#0043">type exec_result_t</a></pre>
<pre>0047:    <a href="/share/lib/std/posix/process.flx#0047">gen execv:+char *  + +char -> exec_result_t</a></pre>
<pre>0048:    <a href="/share/lib/std/posix/process.flx#0048">gen execvp:+char *  + +char -> exec_result_t</a></pre>
<pre>0049:    <a href="/share/lib/std/posix/process.flx#0049">gen execve:+char *  + +char * + +char -> exec_result_t</a></pre>
<pre>0054:    <a href="/share/lib/std/posix/process.flx#0054">type pid_t</a></pre>
<pre>0057:    <a href="/share/lib/std/posix/process.flx#0057">fun str: pid_t -> string</a></pre>
<pre>0060:    <a href="/share/lib/std/posix/process.flx#0060">ctor int: pid_t</a></pre>
<pre>0065:    <a href="/share/lib/std/posix/process.flx#0065">gen fork: unit -> pid_t</a></pre>
<pre>0067:    <a href="/share/lib/std/posix/process.flx#0067">union spawn_result_t</a></pre>
<pre>0077:    <a href="/share/lib/std/posix/process.flx#0077">gen spawnv(file: string, argv:+ +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0097:    <a href="/share/lib/std/posix/process.flx#0097">gen spawnvp(file: string, argv:+ +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0117:    <a href="/share/lib/std/posix/process.flx#0117">gen spawnve(file: string, argv:+ +char, env: + +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0137:    <a href="/share/lib/std/posix/process.flx#0137">type process_status_options_t</a></pre>
<pre>0144:    <a href="/share/lib/std/posix/process.flx#0144">gen waitpid: pid_t * &process_status_t * process_status_options_t -> pid_t requires Posix_headers::sys_wait_h</a></pre>
<pre>0146:    <a href="/share/lib/std/posix/process.flx#0146">gen waitpid(pid:pid_t)</a></pre>
<pre>0157:    <a href="/share/lib/std/posix/process.flx#0157">union ProcesStatus</a></pre>
<pre>0159:    <a href="/share/lib/std/posix/process.flx#0159">gen checkpid(pid:pid_t)</a></pre>
<pre>0172:    <a href="/share/lib/std/posix/process.flx#0172">gen kill: pid_t * signal_t -> int</a></pre>
<hr/><a href="/share/lib/std/posix/shell.flx">posix/shell.flx</a>

<pre>0064:  <a href="/share/lib/std/posix/shell.flx#0064">class Bash</a></pre>
<pre>0071:    <a href="/share/lib/std/posix/shell.flx#0071">fun quote_arg(s:string):string</a></pre>
<pre>0082:    <a href="/share/lib/std/posix/shell.flx#0082">fun quote_line_for_system (s:string)</a></pre>
<pre>0083:    <a href="/share/lib/std/posix/shell.flx#0083">fun quote_line_for_popen (s:string)</a></pre>
<pre>0085:    <a href="/share/lib/std/posix/shell.flx#0085">gen raw_get_stdout(x:string)</a></pre>
<pre>0099:    <a href="/share/lib/std/posix/shell.flx#0099">fun parse (s:string) : list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Parse a bash command line into words.
</p></div>
<pre>0103:    <a href="/share/lib/std/posix/shell.flx#0103">union mode_t</a></pre>
<hr/><a href="/share/lib/std/posix/signal.flx">posix/signal.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/signal.flx#0001">class PosixSignal</a></pre>
<pre>0003:    <a href="/share/lib/std/posix/signal.flx#0003">type signal_t</a></pre>
<pre>0004:    <a href="/share/lib/std/posix/signal.flx#0004">ctor signal_t: int</a></pre>
<pre>0005:    <a href="/share/lib/std/posix/signal.flx#0005">ctor int: signal_t</a></pre>
<pre>0007:    <a href="/share/lib/std/posix/signal.flx#0007">type sig_t</a></pre>
<pre>0008:    <a href="/share/lib/std/posix/signal.flx#0008">gen signal: signal_t * sig_t -> sig_t</a></pre>
<pre>0022:    <a href="/share/lib/std/posix/signal.flx#0022">fun str: signal_t -> string</a></pre>
<pre>0058:    <a href="/share/lib/std/posix/signal.flx#0058">proc ignore_signal(s:signal_t)</a></pre>
<pre>0064:    <a href="/share/lib/std/posix/signal.flx#0064">struct sigaction sa</a></pre>
<pre>0075:    <a href="/share/lib/std/posix/signal.flx#0075">proc trap_ctrl_c: unit requires ctrl_c_handling</a></pre>
<hr/><a href="/share/lib/std/posix/time.flx">posix/time.flx</a>

<pre>0001:  <a href="/share/lib/std/posix/time.flx#0001">class PosixTime</a></pre>
<pre>0021:    <a href="/share/lib/std/posix/time.flx#0021">gen time () : double</a></pre>
<hr/><a href="/share/lib/std/program/__init__.flx">program/__init__.flx</a>
<hr/><a href="/share/lib/std/program/cmdopt.flx">program/cmdopt.flx</a>

<pre>0001:  <a href="/share/lib/std/program/cmdopt.flx#0001">open class CmdOpt</a></pre>
<pre>0005:    <a href="/share/lib/std/program/cmdopt.flx#0005">noinline fun cvt-key-arg (keys: list[string * string]) (x:list[string])</a></pre>
<pre>0027:    <a href="/share/lib/std/program/cmdopt.flx#0027">noinline gen parse-key-multi-value (keys:list[string]) (d:strdict[list[string]]) (x:list[string])</a></pre>
<pre>0052:    <a href="/share/lib/std/program/cmdopt.flx#0052">noinline gen parse-key-single-value (keys:list[string]) (d:strdict[string]) (x:list[string])</a></pre>
<pre>0080:    <a href="/share/lib/std/program/cmdopt.flx#0080">noinline gen parse-key (keys:list[string]) (d:strdict[int]) (x:list[string])</a></pre>
<pre>0106:    <a href="/share/lib/std/program/cmdopt.flx#0106">noinline gen parse-switches (switchmap: list[char * string] ) (d:strdict[int]) (x:list[string])</a></pre>
<pre>0129:    <a href="/share/lib/std/program/cmdopt.flx#0129">typedef cmdspec_t</a></pre>
<pre>0137:    <a href="/share/lib/std/program/cmdopt.flx#0137">typedef cmdopt-parse-result_t</a></pre>
<pre>0144:    <a href="/share/lib/std/program/cmdopt.flx#0144">ctor cmdopt-parse-result_t ()</a></pre>
<pre>0152:    <a href="/share/lib/std/program/cmdopt.flx#0152">noinline gen parse-cmdline (spec:cmdspec_t) (x:list[string]) : cmdopt-parse-result_t</a></pre>
<hr/><a href="/share/lib/std/program/dynlink.fdoc">program/dynlink.fdoc</a>

<pre>0058:  <a href="/share/lib/std/program/dynlink.fdoc#0058">class Dynlink</a></pre>
<pre>0072:    <a href="/share/lib/std/program/dynlink.fdoc#0072">type flx_link_failure_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Exception thrown if dynamic linkage fails.
</p></div>
<pre>0075:    <a href="/share/lib/std/program/dynlink.fdoc#0075">ctor flx_link_failure_t : string * string * string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Constructor for dynamic linkage exception.
</p></div>
<pre>0078:    <a href="/share/lib/std/program/dynlink.fdoc#0078">fun filename : flx_link_failure_t -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Extractors.
</p></div>
<pre>0079:    <a href="/share/lib/std/program/dynlink.fdoc#0079">fun operation : flx_link_failure_t -> string</a></pre>
<pre>0080:    <a href="/share/lib/std/program/dynlink.fdoc#0080">fun what : flx_link_failure_t -> string</a></pre>
<pre>0083:    <a href="/share/lib/std/program/dynlink.fdoc#0083">proc delete : cptr[flx_link_failure_t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Delete returned exception.
</p></div>
<pre>0086:    <a href="/share/lib/std/program/dynlink.fdoc#0086">fun get_debug_driver_flag : 1 -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> This doesn't belong here but it will do for now
</p></div>
<pre>0102:    <a href="/share/lib/std/program/dynlink.fdoc#0102">fun create_library_handle: bool ->flx_library</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a DLL (dynamic link library) object.
 Create a fresh DLL object.
</p></div>
<pre>0111:    <a href="/share/lib/std/program/dynlink.fdoc#0111">proc dlopen:flx_library * string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Link a DLL using given filename.
 May throw flx_link_failure_t.
</p></div>
<pre>0115:    <a href="/share/lib/std/program/dynlink.fdoc#0115">proc modopen:flx_library * string * string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Link a DLL using given filename and modulename.
 May throw flx_link_failure_t.
</p></div>
<pre>0120:    <a href="/share/lib/std/program/dynlink.fdoc#0120">proc set_entry_points : flx_library * string * address * address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Link static 
</p></div>
<pre>0127:    <a href="/share/lib/std/program/dynlink.fdoc#0127">typedef module_dictionary_t</a></pre>
<pre>0128:    <a href="/share/lib/std/program/dynlink.fdoc#0128">typedef registry_t</a></pre>
<pre>0129:    <a href="/share/lib/std/program/dynlink.fdoc#0129">fun get_module_registry_address_address: 1 -> &&registry_t</a></pre>
<pre>0137:    <a href="/share/lib/std/program/dynlink.fdoc#0137">gen get_module_registry  () :registry_t</a></pre>
<pre>0148:    <a href="/share/lib/std/program/dynlink.fdoc#0148">noinline proc regopen (registry:registry_t) (lib:flx_library, modulename:string)</a></pre>
<pre>0175:    <a href="/share/lib/std/program/dynlink.fdoc#0175">fun filename : flx_library -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the filename of a DLL.
</p></div>
<pre>0178:    <a href="/share/lib/std/program/dynlink.fdoc#0178">fun modulename : flx_library -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the modulename of a DLL.
</p></div>
<pre>0181:    <a href="/share/lib/std/program/dynlink.fdoc#0181">fun get_thread_frame_creator_as_address: flx_library -> address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the threadframe creator function
</p></div>
<pre>0184:    <a href="/share/lib/std/program/dynlink.fdoc#0184">fun get_start_as_address: flx_library -> address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get start function
</p></div>
<pre>0186:    <a href="/share/lib/std/program/dynlink.fdoc#0186">noinline proc add_symbol  (modulename:string, symbolname:string, adr:address)</a></pre>
<pre>0221:    <a href="/share/lib/std/program/dynlink.fdoc#0221">generation, it is very hard to ensure there are no references</a></pre>
<pre>0229:    <a href="/share/lib/std/program/dynlink.fdoc#0229">proc dlclose:flx_library</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Unlink a DLL.
 Unsafe! Use with extreme caution.
 May cause pointers into the DLL code segment to dangle.
</p></div>
<pre>0250:    <a href="/share/lib/std/program/dynlink.fdoc#0250">fun raw_dlsym:flx_library * string->address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find raw address of a symbol in a DLL.
 This function now ALWAYS does a dlsym
 (or Windows equivalent)
 even for static linkage: after all 
 statically linked executables can still
 load DLLs at run time.
</p></div>
<pre>0253:    <a href="/share/lib/std/program/dynlink.fdoc#0253">noinline fun find_sym(lib:flx_library, sym:string) : address</a></pre>
<pre>0287:    <a href="/share/lib/std/program/dynlink.fdoc#0287">fun create_instance_handle: bool->flx_instance</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a DLL (dynamic link library) instance.
 Conceptually this is a pair consisting of
 a library object and a global data frame object.
 Create a fresh DLL instance object.
</p></div>
<pre>0300:    <a href="/share/lib/std/program/dynlink.fdoc#0300">proc create: flx_library * flx_instance</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create a DLL instance from a DLL.
 This is a procedure, so maybe the caller is too
 which means the thread frame must be available.
</p></div>
<pre>0305:    <a href="/share/lib/std/program/dynlink.fdoc#0305">proc create_with_args: flx_library * flx_instance * int * + +char</a></pre>
<pre>0310:    <a href="/share/lib/std/program/dynlink.fdoc#0310">proc create_with_args (lib:flx_library, inst:flx_instance, args:list[string])</a></pre>
<pre>0316:    <a href="/share/lib/std/program/dynlink.fdoc#0316">gen myget(i:size)</a></pre>
<pre>0325:    <a href="/share/lib/std/program/dynlink.fdoc#0325">fun filename : flx_instance -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the filename of a DLL from an instance of it.
</p></div>
<pre>0340:    <a href="/share/lib/std/program/dynlink.fdoc#0340">procedure.</a></pre>
<pre>0351:    <a href="/share/lib/std/program/dynlink.fdoc#0351">fun get_init: flx_instance -> cont</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the initialisation continuation of an instance.
</p></div>
<pre>0356:    <a href="/share/lib/std/program/dynlink.fdoc#0356">fun get_library: flx_instance -> flx_library</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the DLL associated with an instance.
</p></div>
<pre>0363:    <a href="/share/lib/std/program/dynlink.fdoc#0363">fun get_thread_frame: flx_instance -> address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the thread frame (global data object) of an instance.
</p></div>
<pre>0377:    <a href="/share/lib/std/program/dynlink.fdoc#0377">noinline gen prepare_lib(modulename:string):flx_instance</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create, link, and prepare a DLL instance from a modulename.
 NOTE: libraries created here do not need to be roots
</p></div>
<pre>0387:    <a href="/share/lib/std/program/dynlink.fdoc#0387">noinline gen prepare_lib_with_args(modulename:string, args:list[string]):flx_instance</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create, link, and prepare a DLL instance from a modulename.
</p></div>
<pre>0398:    <a href="/share/lib/std/program/dynlink.fdoc#0398">noinline gen init_lib(modulename:string):flx_instance</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create, link, and initialise a  DLL instance from a modulename.
</p></div>
<pre>0406:    <a href="/share/lib/std/program/dynlink.fdoc#0406">noinline gen init_lib_with_args(modulename:string, args:list[string]):flx_instance</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create, link, and initialise a  DLL instance from a modulename.
</p></div>
<pre>0418:    <a href="/share/lib/std/program/dynlink.fdoc#0418">proc run_lib(modulename:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Run a Felix program from a filename.
</p></div>
<pre>0425:    <a href="/share/lib/std/program/dynlink.fdoc#0425">proc run_program(args:list[string])</a></pre>
<pre>0444:    <a href="/share/lib/std/program/dynlink.fdoc#0444">noinline fun flx_dlsym[T] (linst: flx_instance, sym:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find typed address of a symbol in a DLL.
</p></div>
<pre>0480:    <a href="/share/lib/std/program/dynlink.fdoc#0480">noinline fun func0[R] (linst: flx_instance, sym:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a closure representing a symbol in a DLL instance
 of a function of no arguments.
</p></div>
<pre>0487:    <a href="/share/lib/std/program/dynlink.fdoc#0487">noinline fun func1[R,A0] (linst: flx_instance, sym:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a closure representing a symbol in a DLL instance
 of a function of one argument.
</p></div>
<pre>0494:    <a href="/share/lib/std/program/dynlink.fdoc#0494">noinline fun func2[R,A0,A1] (linst: flx_instance, sym:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a closure representing a symbol in a DLL instance
 of a function of two arguments.
</p></div>
<pre>0501:    <a href="/share/lib/std/program/dynlink.fdoc#0501">noinline fun proc0 (linst: flx_instance, sym:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a closure representing a symbol in a DLL instance
 of a procedure of no arguments.
</p></div>
<pre>0508:    <a href="/share/lib/std/program/dynlink.fdoc#0508">noinline fun proc1[A0] (linst: flx_instance, sym:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a closure representing a symbol in a DLL instance
 of a procedure of one argument.
</p></div>
<pre>0515:    <a href="/share/lib/std/program/dynlink.fdoc#0515">noinline fun proc2[A0,A1] (linst: flx_instance, sym:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a closure representing a symbol in a DLL instance
 of a procedure of two arguments.
</p></div>
<pre>0562:    <a href="/share/lib/std/program/dynlink.fdoc#0562">noinline gen  load-plugin-func0[iftype] (</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Specialised routine(s) to load stylised plugin.
 Two entry points:
</p><p> setup: string -> int
</p><p> is called to initialise the instance globals.
</p><p> entry-point: arg -> iftype
</p><p> is the primary entry point, typically an object factory, 
 when called with an argument
 of type arg_t it returns //$ an object of type iftype.
</p><p> This function returns the object factory.
 setup is called automatically with the supplied string.
</p><p> There are 3 variants where the factory function accepts
 0, 1 and 2 arguments.
</p></div>
<pre>0576:    <a href="/share/lib/std/program/dynlink.fdoc#0576">noinline gen  load-plugin-func1[iftype, arg_t] (</a></pre>
<pre>0590:    <a href="/share/lib/std/program/dynlink.fdoc#0590">noinline gen  load-plugin-func2[iftype, arg1_t, arg2_t] (</a></pre>
<pre>0614:    <a href="/share/lib/std/program/dynlink.fdoc#0614">fun bind_proc: flx_instance * address * address -> cont</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Execute an address representing a top
 level exported felix procedure's C wrapper,
 this creates a 'read to run' continuation object
 by both constructing the object using the thread
 frame of the instance as an argument, and calling
 it to fix a null return address and an arbitrary
 client data pointer as arguments to the call method.
</p></div>
<pre>0619:    <a href="/share/lib/std/program/dynlink.fdoc#0619">fun dlib_of : flx_library -> address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the OS dependent handle representing a loaded DLL.
 Return as an address. 
</p></div>
<pre>0623:    <a href="/share/lib/std/program/dynlink.fdoc#0623">proc dlsym_err:flx_library*string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Throw an exception indicating the failure to 
 find a symbol in a DLL.
</p></div>
<pre>0629:    <a href="/share/lib/std/program/dynlink.fdoc#0629">noinline proc run_proc (linstance:flx_instance, p: string, data: address)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Run a procedure represented by a string name with
 given thread frame.
</p></div>
<hr/><a href="/share/lib/std/program/env.flx">program/env.flx</a>

<pre>0002:  <a href="/share/lib/std/program/env.flx#0002">class Env_class[os]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Access environment variables.
</p></div>
<pre>0005:    <a href="/share/lib/std/program/env.flx#0005">virtual fun pathsep: 1 -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Separator for filename lists
</p></div>
<pre>0009:    <a href="/share/lib/std/program/env.flx#0009">fun getenv:string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the value of a given variable.
 Returns empty string if the variable doesn't exist.
</p></div>
<pre>0015:    <a href="/share/lib/std/program/env.flx#0015">fun getenv(name:string,dflt:string):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the value of a given variable.
 Returns specified default if the variable doesn't exist.
</p></div>
<pre>0019:    <a href="/share/lib/std/program/env.flx#0019">fun getenvlist (name:string) : list[string]</a></pre>

<pre>0027:  <a href="/share/lib/std/program/env.flx#0027">class Env</a></pre>
<hr/><a href="/share/lib/std/program/process.flx">program/process.flx</a>

<pre>0003:  <a href="/share/lib/std/program/process.flx#0003">class Process_class[os, process_status_t]</a></pre>
<pre>0005:    <a href="/share/lib/std/program/process.flx#0005">virtual gen popen_in : string -> Cstdio::ifile</a></pre>
<pre>0006:    <a href="/share/lib/std/program/process.flx#0006">virtual gen pclose: Cstdio::ifile -> process_status_t</a></pre>

<pre>0009:  <a href="/share/lib/std/program/process.flx#0009">class Process</a></pre>
<hr/><a href="/share/lib/std/program/shell.flx">program/shell.flx</a>

<pre>0004:  <a href="/share/lib/std/program/shell.flx#0004">class Shell_class[OS, process_status_t]</a></pre>
<pre>0008:    <a href="/share/lib/std/program/shell.flx#0008">virtual fun quote_arg:string->string</a></pre>
<pre>0011:    <a href="/share/lib/std/program/shell.flx#0011">virtual fun quote_line_for_system: string->string</a></pre>
<pre>0012:    <a href="/share/lib/std/program/shell.flx#0012">virtual fun quote_line_for_popen: string -> string</a></pre>
<pre>0014:    <a href="/share/lib/std/program/shell.flx#0014">virtual fun parse: string -> list[string]</a></pre>
<pre>0017:    <a href="/share/lib/std/program/shell.flx#0017">gen raw_system: string -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> System command is ISO C and C++ standard.
</p></div>
<pre>0022:    <a href="/share/lib/std/program/shell.flx#0022">virtual gen raw_get_stdout : string -> int * string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> get_stdout is a synchronous version of popen_in/pclose pair.
</p></div>
<pre>0025:    <a href="/share/lib/std/program/shell.flx#0025">fun create_system_command (s:list[string]) : string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> create prototype command strings from arg list.
</p></div>
<pre>0028:    <a href="/share/lib/std/program/shell.flx#0028">fun create_popen_command (s:list[string]) : string</a></pre>
<pre>0033:    <a href="/share/lib/std/program/shell.flx#0033">gen basic_system (cmd: string) :int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> basic command with line quoting.
</p></div>
<pre>0036:    <a href="/share/lib/std/program/shell.flx#0036">gen basic_get_stdout (cmd: string) : int * string</a></pre>
<pre>0041:    <a href="/share/lib/std/program/shell.flx#0041">gen system (cmd:string)</a></pre>
<pre>0048:    <a href="/share/lib/std/program/shell.flx#0048">gen get_stdout (cmd:string) : int * string</a></pre>
<pre>0056:    <a href="/share/lib/std/program/shell.flx#0056">gen system (args:list[string]) : int</a></pre>
<pre>0060:    <a href="/share/lib/std/program/shell.flx#0060">gen system[T with Streamable[T,string]] (args:T) : int</a></pre>
<pre>0071:    <a href="/share/lib/std/program/shell.flx#0071">gen get_stdout (args:list[string]) : int * string</a></pre>
<pre>0075:    <a href="/share/lib/std/program/shell.flx#0075">gen get_stdout[T with Streamable[T,string]] (args:T) : int * string</a></pre>

<pre>0086:  <a href="/share/lib/std/program/shell.flx#0086">class Shell</a></pre>
<hr/><a href="/share/lib/std/program/signal.flx">program/signal.flx</a>

<pre>0008:  <a href="/share/lib/std/program/signal.flx#0008">class Signal_class [os]</a></pre>
<pre>0009:    <a href="/share/lib/std/program/signal.flx#0009">gen get_ctrl_c_flag: 1 -> bool requires ctrl_c_flag</a></pre>
<pre>0010:    <a href="/share/lib/std/program/signal.flx#0010">proc set_ctrl_c_flag: int requires ctrl_c_flag</a></pre>
<pre>0011:    <a href="/share/lib/std/program/signal.flx#0011">virtual proc trap_ctrl_c: 1</a></pre>

<pre>0015:  <a href="/share/lib/std/program/signal.flx#0015">class Signal</a></pre>
<hr/><a href="/share/lib/std/program/system.flx">program/system.flx</a>

<pre>0001:  <a href="/share/lib/std/program/system.flx#0001">class System</a></pre>
<pre>0006:    <a href="/share/lib/std/program/system.flx#0006">fun argv:int -> string</a></pre>
<pre>0007:    <a href="/share/lib/std/program/system.flx#0007">fun argv_dflt (x:int) (y:string)</a></pre>
<pre>0009:    <a href="/share/lib/std/program/system.flx#0009">fun args ()</a></pre>
<pre>0011:    <a href="/share/lib/std/program/system.flx#0011">proc setargs : + +char * size</a></pre>
<pre>0012:    <a href="/share/lib/std/program/system.flx#0012">proc setargs[N] (a:string^N)</a></pre>
<pre>0014:    <a href="/share/lib/std/program/system.flx#0014">gen myget(i:size)</a></pre>
<pre>0019:    <a href="/share/lib/std/program/system.flx#0019">gen system (cmd:string) : int</a></pre>
<pre>0020:    <a href="/share/lib/std/program/system.flx#0020">gen exit: int -> any</a></pre>
<pre>0021:    <a href="/share/lib/std/program/system.flx#0021">gen abort: 1 -> any</a></pre>
<pre>0039:    <a href="/share/lib/std/program/system.flx#0039">proc pexit(e:int)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> pexit examines the return code from a system call.
 If the code is 0 it exists with 0.
 On Windows:
    if the code is -1, it exits with errno.
    otherwise code 3
 On Unix:
   if the code is non-zero then
     if the callout aborted, return its abort code.
     if the callout died due to a signal, exit with code 2
     otherwise exit with code 3
 In both these cases a non-zero return causes a message
 to be printed on stderr.
</p></div>
<pre>0054:    <a href="/share/lib/std/program/system.flx#0054">proc pexit(e:int)</a></pre>
<pre>0074:    <a href="/share/lib/std/program/system.flx#0074">gen get_stdout(x:string) : int * string</a></pre>
<hr/><a href="/share/lib/std/rawc.flx">rawc.flx</a>

<pre>0017:  <a href="/share/lib/std/rawc.flx#0017">class Raw_C</a></pre>
<pre>0020:    <a href="/share/lib/std/rawc.flx#0020">typedef ntbs</a></pre>
<pre>0023:    <a href="/share/lib/std/rawc.flx#0023">gen malloc:size -> address</a></pre>
<pre>0024:    <a href="/share/lib/std/rawc.flx#0024">proc free:address</a></pre>
<pre>0025:    <a href="/share/lib/std/rawc.flx#0025">gen realloc:address * size -> address</a></pre>
<pre>0026:    <a href="/share/lib/std/rawc.flx#0026">proc calloc:size</a></pre>
<pre>0029:    <a href="/share/lib/std/rawc.flx#0029">gen memset:address * int * size -> address</a></pre>
<pre>0030:    <a href="/share/lib/std/rawc.flx#0030">gen memcpy:address * address * size -> address</a></pre>
<pre>0031:    <a href="/share/lib/std/rawc.flx#0031">gen memmove:address * address * size -> address</a></pre>
<pre>0034:    <a href="/share/lib/std/rawc.flx#0034">gen strlen: ntbs -> size</a></pre>
<pre>0035:    <a href="/share/lib/std/rawc.flx#0035">gen strcpy:ntbs * ntbs -> ntbs</a></pre>
<pre>0036:    <a href="/share/lib/std/rawc.flx#0036">gen strncpy:ntbs * ntbs * size -> ntbs</a></pre>
<pre>0037:    <a href="/share/lib/std/rawc.flx#0037">gen strdup:ntbs -> ntbs</a></pre>
<pre>0038:    <a href="/share/lib/std/rawc.flx#0038">gen strcat:ntbs * ntbs -> ntbs</a></pre>
<pre>0039:    <a href="/share/lib/std/rawc.flx#0039">gen strchr:ntbs * int -> ntbs</a></pre>
<pre>0040:    <a href="/share/lib/std/rawc.flx#0040">gen strcmp:ntbs * ntbs-> int</a></pre>
<hr/><a href="/share/lib/std/scalar/__init__.flx">scalar/__init__.flx</a>
<hr/><a href="/share/lib/std/scalar/address.flx">scalar/address.flx</a>

<pre>0002:  <a href="/share/lib/std/scalar/address.flx#0002">open class Address</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Core operations on addresses.
</p></div>
<pre>0004:    <a href="/share/lib/std/scalar/address.flx#0004">ctor[T] address: &T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct from Felix object pointer.
</p></div>
<pre>0007:    <a href="/share/lib/std/scalar/address.flx#0007">ctor[T] address: cptr[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct from possibly NULL pointer.
</p></div>
<pre>0010:    <a href="/share/lib/std/scalar/address.flx#0010">ctor[T] address: +T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct from possibly array element pointer.
</p></div>
<pre>0013:    <a href="/share/lib/std/scalar/address.flx#0013">ctor[D,C] address: D --> C</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct from C function
</p></div>
<pre>0017:    <a href="/share/lib/std/scalar/address.flx#0017">fun isNULL: address -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check is an address is NULL.
</p></div>
<pre>0029:    <a href="/share/lib/std/scalar/address.flx#0029">fun str (t:T) : string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Define NULL address.
</p></div>
<hr/><a href="/share/lib/std/scalar/bool.flx">scalar/bool.flx</a>

<pre>0004:  <a href="/share/lib/std/scalar/bool.flx#0004">open class Bool</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Standard operations on boolean type.
 Note bool = 2 defined in std/flx_tclass.flx.
 Literals true and false defined in grammer/expressions.flxh.
</p></div>
<pre>0007:    <a href="/share/lib/std/scalar/bool.flx#0007">fun land: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Disjunction: logical and.
</p></div>
<pre>0010:    <a href="/share/lib/std/scalar/bool.flx#0010">fun nand: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Negated and.
</p></div>
<pre>0013:    <a href="/share/lib/std/scalar/bool.flx#0013">fun lor: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Conjunction: logical or.
</p></div>
<pre>0016:    <a href="/share/lib/std/scalar/bool.flx#0016">fun nor: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Negated or.
</p></div>
<pre>0019:    <a href="/share/lib/std/scalar/bool.flx#0019">fun xor: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Logical exclusive or.
</p></div>
<pre>0022:    <a href="/share/lib/std/scalar/bool.flx#0022">fun lnot: bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Logical negation.
</p></div>
<pre>0025:    <a href="/share/lib/std/scalar/bool.flx#0025">fun implies: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Logical implication.
</p></div>
<pre>0044:    <a href="/share/lib/std/scalar/bool.flx#0044">fun zero ()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutating or.
 Mutating and.
</p></div>
<pre>0052:    <a href="/share/lib/std/scalar/bool.flx#0052">fun str (b:bool) : string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert bool to string.
</p></div>
<hr/><a href="/share/lib/std/scalar/char.flx">scalar/char.flx</a>

<pre>0002:  <a href="/share/lib/std/scalar/char.flx#0002">open class Char</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Standard C operations on C character set.
</p></div>
<pre>0005:    <a href="/share/lib/std/scalar/char.flx#0005">fun ord: char -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Ordinal value as int.
</p></div>
<pre>0011:    <a href="/share/lib/std/scalar/char.flx#0011">fun toupper : char -> char requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Constructor from any integer type.
 Convert to upper case.
</p></div>
<pre>0014:    <a href="/share/lib/std/scalar/char.flx#0014">fun tolower : char -> char requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert to lower case.
</p></div>
<pre>0017:    <a href="/share/lib/std/scalar/char.flx#0017">fun isupper : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if upper case [A-Z].
</p></div>
<pre>0020:    <a href="/share/lib/std/scalar/char.flx#0020">fun islower : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if lower case [a-z].
</p></div>
<pre>0023:    <a href="/share/lib/std/scalar/char.flx#0023">fun isalnum : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if alphanumeric [A-Za-z0-9].
</p></div>
<pre>0026:    <a href="/share/lib/std/scalar/char.flx#0026">fun isalpha : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if alphabetic [A-Za-z]
</p></div>
<pre>0029:    <a href="/share/lib/std/scalar/char.flx#0029">fun isdigit : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if digit [0-9].
</p></div>
<pre>0032:    <a href="/share/lib/std/scalar/char.flx#0032">fun isxdigit : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if hex digit [0-9A-Fa-f].
</p></div>
<pre>0035:    <a href="/share/lib/std/scalar/char.flx#0035">fun iscntrl : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if control character 0x0 - 0x20, 0x7F
</p></div>
<pre>0038:    <a href="/share/lib/std/scalar/char.flx#0038">fun isspace : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if space x020.
</p></div>
<pre>0041:    <a href="/share/lib/std/scalar/char.flx#0041">fun isblank : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if space 0x20 or tab 0x09
</p></div>
<pre>0044:    <a href="/share/lib/std/scalar/char.flx#0044">fun isprint : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if printable 0x20-0x7e
</p></div>
<pre>0047:    <a href="/share/lib/std/scalar/char.flx#0047">fun ispunct : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if punctuation character.
</p></div>
<pre>0058:    <a href="/share/lib/std/scalar/char.flx#0058">fun isidstart(x:char)</a></pre>
<pre>0059:    <a href="/share/lib/std/scalar/char.flx#0059">fun iscamlidcont(x:char)</a></pre>
<pre>0060:    <a href="/share/lib/std/scalar/char.flx#0060">fun isidcont(x:char)</a></pre>
<pre>0061:    <a href="/share/lib/std/scalar/char.flx#0061">fun isnumeric(x:char)</a></pre>
<pre>0062:    <a href="/share/lib/std/scalar/char.flx#0062">fun isalphanum(x:char)</a></pre>
<pre>0063:    <a href="/share/lib/std/scalar/char.flx#0063">fun isletter (x:char)</a></pre>
<pre>0065:    <a href="/share/lib/std/scalar/char.flx#0065">fun issq(x:char)</a></pre>
<pre>0066:    <a href="/share/lib/std/scalar/char.flx#0066">fun isdq(x:char)</a></pre>
<pre>0067:    <a href="/share/lib/std/scalar/char.flx#0067">fun isslosh(x:char)</a></pre>
<pre>0068:    <a href="/share/lib/std/scalar/char.flx#0068">fun isnull(x:char)</a></pre>
<pre>0069:    <a href="/share/lib/std/scalar/char.flx#0069">fun iseol(x:char)</a></pre>
<pre>0074:    <a href="/share/lib/std/scalar/char.flx#0074">fun str: T -> string</a></pre>
<pre>0078:    <a href="/share/lib/std/scalar/char.flx#0078">fun repr[with Str[T]] (c:T) : string</a></pre>
<hr/><a href="/share/lib/std/scalar/ctypedefs.flx">scalar/ctypedefs.flx</a>
<pre>0001:    <a href="/share/lib/std/scalar/ctypedefs.flx#0001">pod type byte</a></pre>
<pre>0005:    <a href="/share/lib/std/scalar/ctypedefs.flx#0005">pod type char</a></pre>
<pre>0007:    <a href="/share/lib/std/scalar/ctypedefs.flx#0007">pod type tiny</a></pre>
<pre>0008:    <a href="/share/lib/std/scalar/ctypedefs.flx#0008">pod type short</a></pre>
<pre>0009:    <a href="/share/lib/std/scalar/ctypedefs.flx#0009">pod type int</a></pre>
<pre>0010:    <a href="/share/lib/std/scalar/ctypedefs.flx#0010">pod type long</a></pre>
<pre>0011:    <a href="/share/lib/std/scalar/ctypedefs.flx#0011">pod type vlong</a></pre>
<pre>0012:    <a href="/share/lib/std/scalar/ctypedefs.flx#0012">pod type utiny</a></pre>
<pre>0013:    <a href="/share/lib/std/scalar/ctypedefs.flx#0013">pod type ushort</a></pre>
<pre>0014:    <a href="/share/lib/std/scalar/ctypedefs.flx#0014">pod type uint</a></pre>
<pre>0015:    <a href="/share/lib/std/scalar/ctypedefs.flx#0015">pod type ulong</a></pre>
<pre>0016:    <a href="/share/lib/std/scalar/ctypedefs.flx#0016">pod type uvlong</a></pre>
<pre>0018:    <a href="/share/lib/std/scalar/ctypedefs.flx#0018">pod type float</a></pre>
<pre>0019:    <a href="/share/lib/std/scalar/ctypedefs.flx#0019">pod type double</a></pre>
<pre>0020:    <a href="/share/lib/std/scalar/ctypedefs.flx#0020">pod type ldouble</a></pre>
<pre>0021:    <a href="/share/lib/std/scalar/ctypedefs.flx#0021">pod type fcomplex</a></pre>
<pre>0022:    <a href="/share/lib/std/scalar/ctypedefs.flx#0022">pod type dcomplex</a></pre>
<pre>0023:    <a href="/share/lib/std/scalar/ctypedefs.flx#0023">pod type lcomplex</a></pre>
<pre>0031:    <a href="/share/lib/std/scalar/ctypedefs.flx#0031">pod type ptrdiff</a></pre>
<pre>0032:    <a href="/share/lib/std/scalar/ctypedefs.flx#0032">pod type size</a></pre>
<pre>0033:    <a href="/share/lib/std/scalar/ctypedefs.flx#0033">pod type ssize</a></pre>
<pre>0035:    <a href="/share/lib/std/scalar/ctypedefs.flx#0035">pod type intmax</a></pre>
<pre>0036:    <a href="/share/lib/std/scalar/ctypedefs.flx#0036">pod type uintmax</a></pre>
<pre>0037:    <a href="/share/lib/std/scalar/ctypedefs.flx#0037">pod type intptr</a></pre>
<pre>0038:    <a href="/share/lib/std/scalar/ctypedefs.flx#0038">pod type uintptr</a></pre>
<pre>0039:    <a href="/share/lib/std/scalar/ctypedefs.flx#0039">pod type int8</a></pre>
<pre>0040:    <a href="/share/lib/std/scalar/ctypedefs.flx#0040">pod type int16</a></pre>
<pre>0041:    <a href="/share/lib/std/scalar/ctypedefs.flx#0041">pod type int32</a></pre>
<pre>0042:    <a href="/share/lib/std/scalar/ctypedefs.flx#0042">pod type int64</a></pre>
<pre>0043:    <a href="/share/lib/std/scalar/ctypedefs.flx#0043">pod type uint8</a></pre>
<pre>0044:    <a href="/share/lib/std/scalar/ctypedefs.flx#0044">pod type uint16</a></pre>
<pre>0045:    <a href="/share/lib/std/scalar/ctypedefs.flx#0045">pod type uint32</a></pre>
<pre>0046:    <a href="/share/lib/std/scalar/ctypedefs.flx#0046">pod type uint64</a></pre>
<pre>0050:    <a href="/share/lib/std/scalar/ctypedefs.flx#0050">typedef addressing</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Types associated with raw address calculations.
</p></div>
<pre>0056:    <a href="/share/lib/std/scalar/ctypedefs.flx#0056">typedef chars</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Character types.
</p></div>
<pre>0060:    <a href="/share/lib/std/scalar/ctypedefs.flx#0060">typedef fast_sints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> "natural" sized signed integer types.
 These correspond to C/C++ core types.
</p></div>
<pre>0065:    <a href="/share/lib/std/scalar/ctypedefs.flx#0065">typedef exact_sints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Exact sized signed integer types.
 In C these are typedefs.
 In Felix they're distinct types.
</p></div>
<pre>0069:    <a href="/share/lib/std/scalar/ctypedefs.flx#0069">typedef fast_uints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> "natural" sized unsigned integer types.
 These correspond to C/C++ core types.
</p></div>
<pre>0074:    <a href="/share/lib/std/scalar/ctypedefs.flx#0074">typedef exact_uints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Exact sized unsigned integer types.
 In C these are typedefs.
 In Felix they're distinct types.
</p></div>
<pre>0078:    <a href="/share/lib/std/scalar/ctypedefs.flx#0078">typedef weird_sints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Weirdo signed integers types corresponding to
 typedefs in C.
</p></div>
<pre>0082:    <a href="/share/lib/std/scalar/ctypedefs.flx#0082">typedef weird_uints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Weirdo unsigned integers types corresponding to
 typedefs in C.
</p></div>
<pre>0085:    <a href="/share/lib/std/scalar/ctypedefs.flx#0085">typedef sints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the signed integers.
</p></div>
<pre>0088:    <a href="/share/lib/std/scalar/ctypedefs.flx#0088">typedef uints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the usigned integers.
</p></div>
<pre>0091:    <a href="/share/lib/std/scalar/ctypedefs.flx#0091">typedef fast_ints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the fast integers.
</p></div>
<pre>0094:    <a href="/share/lib/std/scalar/ctypedefs.flx#0094">typedef exact_ints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the exact integers.
</p></div>
<pre>0097:    <a href="/share/lib/std/scalar/ctypedefs.flx#0097">typedef ints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the integers.
</p></div>
<pre>0100:    <a href="/share/lib/std/scalar/ctypedefs.flx#0100">typedef floats</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the core floating point types.
</p></div>
<pre>0103:    <a href="/share/lib/std/scalar/ctypedefs.flx#0103">typedef reals</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the core approximations to real types.
</p></div>
<pre>0106:    <a href="/share/lib/std/scalar/ctypedefs.flx#0106">typedef complexes</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the core approximations to complex types.
</p></div>
<pre>0109:    <a href="/share/lib/std/scalar/ctypedefs.flx#0109">typedef numbers</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the core approximations to numbers.
</p></div>
<pre>0112:    <a href="/share/lib/std/scalar/ctypedefs.flx#0112">typedef basic_types</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the basic scalar types.
</p></div>
<hr/><a href="/share/lib/std/scalar/float_format.flx">scalar/float_format.flx</a>

<pre>0002:  <a href="/share/lib/std/scalar/float_format.flx#0002">open class float_format</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Functions to format floating point numbers.
</p></div>
<pre>0008:    <a href="/share/lib/std/scalar/float_format.flx#0008">union mode</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Style of formatting.
 default (w,d)    : like C "w.dG" format
 fixed (w,d)      : like C "w.dF" format
 scientific (w,d) : like C "w.dE" format
</p></div>
<pre>0015:    <a href="/share/lib/std/scalar/float_format.flx#0015">fun fmt[t in reals] (v:t, m: mode)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format a real number v with format m.
</p></div>
<pre>0025:    <a href="/share/lib/std/scalar/float_format.flx#0025">fun fmt[t,r with Complex[t,r]] (v:t, m: mode)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format a complex number v in x + iy form,
 with format m for x and y.
</p></div>
<pre>0034:    <a href="/share/lib/std/scalar/float_format.flx#0034">fun fmt_default[t] : t * int * int -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format default.
</p></div>
<pre>0037:    <a href="/share/lib/std/scalar/float_format.flx#0037">fun fmt_fixed[t] : t * int * int -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format fixed.
</p></div>
<pre>0040:    <a href="/share/lib/std/scalar/float_format.flx#0040">fun fmt_scientific[t] : t * int * int -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format scientfic.
</p></div>
<pre>0044:    <a href="/share/lib/std/scalar/float_format.flx#0044">fun xstr: float -> string</a></pre>
<pre>0047:    <a href="/share/lib/std/scalar/float_format.flx#0047">fun str(x:float):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Default format float, also supports nan, +inf, -inf.
</p></div>
<pre>0057:    <a href="/share/lib/std/scalar/float_format.flx#0057">fun xstr: double -> string</a></pre>
<pre>0060:    <a href="/share/lib/std/scalar/float_format.flx#0060">fun str(x:double):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Default format double, also supports nan, +inf, -inf.
</p></div>
<pre>0070:    <a href="/share/lib/std/scalar/float_format.flx#0070">fun xstr: ldouble -> string</a></pre>
<pre>0073:    <a href="/share/lib/std/scalar/float_format.flx#0073">fun str(x:ldouble):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Default format long double, also supports nan, +inf, -inf.
</p></div>
<hr/><a href="/share/lib/std/scalar/float_math.flx">scalar/float_math.flx</a>

<pre>0006:  <a href="/share/lib/std/scalar/float_math.flx#0006">open class Fcomplex</a></pre>
<pre>0011:    <a href="/share/lib/std/scalar/float_math.flx#0011">fun str (z:fcomplex)</a></pre>

<pre>0015:  <a href="/share/lib/std/scalar/float_math.flx#0015">open class Dcomplex</a></pre>
<pre>0020:    <a href="/share/lib/std/scalar/float_math.flx#0020">fun str (z:dcomplex)</a></pre>

<pre>0024:  <a href="/share/lib/std/scalar/float_math.flx#0024">open class Lcomplex</a></pre>
<pre>0029:    <a href="/share/lib/std/scalar/float_math.flx#0029">fun str (z:lcomplex)</a></pre>
<pre>0034:    <a href="/share/lib/std/scalar/float_math.flx#0034">fun real : complex[t] -> t</a></pre>
<pre>0035:    <a href="/share/lib/std/scalar/float_math.flx#0035">fun imag : complex[t] -> t</a></pre>
<pre>0036:    <a href="/share/lib/std/scalar/float_math.flx#0036">fun abs: complex[t] -> t</a></pre>
<pre>0037:    <a href="/share/lib/std/scalar/float_math.flx#0037">fun arg : complex[t] -> t</a></pre>
<pre>0051:    <a href="/share/lib/std/scalar/float_math.flx#0051">fun zero: 1 -> complex[t]</a></pre>
<pre>0052:    <a href="/share/lib/std/scalar/float_math.flx#0052">fun one: 1 -> complex[t]</a></pre>
<pre>0057:    <a href="/share/lib/std/scalar/float_math.flx#0057">fun sin: t -> t</a></pre>
<pre>0058:    <a href="/share/lib/std/scalar/float_math.flx#0058">fun cos: t -> t</a></pre>
<pre>0059:    <a href="/share/lib/std/scalar/float_math.flx#0059">fun tan: t -> t</a></pre>
<pre>0060:    <a href="/share/lib/std/scalar/float_math.flx#0060">fun asin: t -> t</a></pre>
<pre>0061:    <a href="/share/lib/std/scalar/float_math.flx#0061">fun acos: t -> t</a></pre>
<pre>0062:    <a href="/share/lib/std/scalar/float_math.flx#0062">fun atan: t -> t</a></pre>
<pre>0063:    <a href="/share/lib/std/scalar/float_math.flx#0063">fun sinh: t -> t</a></pre>
<pre>0064:    <a href="/share/lib/std/scalar/float_math.flx#0064">fun cosh: t -> t</a></pre>
<pre>0065:    <a href="/share/lib/std/scalar/float_math.flx#0065">fun tanh: t -> t</a></pre>
<pre>0066:    <a href="/share/lib/std/scalar/float_math.flx#0066">fun asinh: t -> t</a></pre>
<pre>0067:    <a href="/share/lib/std/scalar/float_math.flx#0067">fun acosh: t -> t</a></pre>
<pre>0068:    <a href="/share/lib/std/scalar/float_math.flx#0068">fun atanh: t -> t</a></pre>
<pre>0069:    <a href="/share/lib/std/scalar/float_math.flx#0069">fun exp: t -> t</a></pre>
<pre>0070:    <a href="/share/lib/std/scalar/float_math.flx#0070">fun log: t -> t</a></pre>
<pre>0071:    <a href="/share/lib/std/scalar/float_math.flx#0071">fun pow: t * t -> t</a></pre>
<pre>0076:    <a href="/share/lib/std/scalar/float_math.flx#0076">fun abs: t -> t</a></pre>
<pre>0077:    <a href="/share/lib/std/scalar/float_math.flx#0077">fun log10: t -> t</a></pre>
<pre>0078:    <a href="/share/lib/std/scalar/float_math.flx#0078">fun sqrt: t -> t</a></pre>
<pre>0079:    <a href="/share/lib/std/scalar/float_math.flx#0079">fun ceil: t -> t</a></pre>
<pre>0080:    <a href="/share/lib/std/scalar/float_math.flx#0080">fun floor: t -> t</a></pre>
<pre>0081:    <a href="/share/lib/std/scalar/float_math.flx#0081">fun trunc: t -> t</a></pre>
<pre>0082:    <a href="/share/lib/std/scalar/float_math.flx#0082">fun embed: int -> t</a></pre>

<pre>0085:  <a href="/share/lib/std/scalar/float_math.flx#0085">class CartComplex[r]</a></pre>
<pre>0086:    <a href="/share/lib/std/scalar/float_math.flx#0086">typedef t</a></pre>
<pre>0090:    <a href="/share/lib/std/scalar/float_math.flx#0090">typedef complex[t in floats]</a></pre>
<pre>0097:    <a href="/share/lib/std/scalar/float_math.flx#0097">ctor complex[float] (x:float, y:float)</a></pre>
<pre>0098:    <a href="/share/lib/std/scalar/float_math.flx#0098">ctor complex[double] (x:double, y:double)</a></pre>
<pre>0099:    <a href="/share/lib/std/scalar/float_math.flx#0099">ctor complex[ldouble] (x:ldouble, y:ldouble)</a></pre>
<pre>0101:    <a href="/share/lib/std/scalar/float_math.flx#0101">ctor complex[float] (x:float)</a></pre>
<pre>0102:    <a href="/share/lib/std/scalar/float_math.flx#0102">ctor complex[double] (x:double)</a></pre>
<pre>0103:    <a href="/share/lib/std/scalar/float_math.flx#0103">ctor complex[ldouble] (x:ldouble)</a></pre>
<pre>0105:    <a href="/share/lib/std/scalar/float_math.flx#0105">typedef polar[t in floats]</a></pre>
<hr/><a href="/share/lib/std/scalar/int.flx">scalar/int.flx</a>
<pre>0001:    <a href="/share/lib/std/scalar/int.flx#0001">typedef fun integral_promotion: TYPE -> TYPE</a></pre>

<pre>0014:  <a href="/share/lib/std/scalar/int.flx#0014">open class Tiny</a></pre>
<pre>0016:    <a href="/share/lib/std/scalar/int.flx#0016">ctor tiny: string</a></pre>

<pre>0020:  <a href="/share/lib/std/scalar/int.flx#0020">open class Short</a></pre>
<pre>0022:    <a href="/share/lib/std/scalar/int.flx#0022">ctor short: string</a></pre>

<pre>0026:  <a href="/share/lib/std/scalar/int.flx#0026">open class Int</a></pre>
<pre>0028:    <a href="/share/lib/std/scalar/int.flx#0028">ctor int: string</a></pre>
<pre>0030:    <a href="/share/lib/std/scalar/int.flx#0030">ctor int : int</a></pre>
<pre>0032:    <a href="/share/lib/std/scalar/int.flx#0032">ctor int(x:bool)</a></pre>

<pre>0035:  <a href="/share/lib/std/scalar/int.flx#0035">open class Long</a></pre>
<pre>0037:    <a href="/share/lib/std/scalar/int.flx#0037">ctor long: string</a></pre>

<pre>0041:  <a href="/share/lib/std/scalar/int.flx#0041">open class Vlong</a></pre>
<pre>0043:    <a href="/share/lib/std/scalar/int.flx#0043">ctor vlong: string</a></pre>

<pre>0047:  <a href="/share/lib/std/scalar/int.flx#0047">open class Utiny</a></pre>
<pre>0049:    <a href="/share/lib/std/scalar/int.flx#0049">ctor utiny: string</a></pre>

<pre>0053:  <a href="/share/lib/std/scalar/int.flx#0053">open class Ushort</a></pre>
<pre>0055:    <a href="/share/lib/std/scalar/int.flx#0055">ctor ushort: string</a></pre>

<pre>0059:  <a href="/share/lib/std/scalar/int.flx#0059">open class Uint</a></pre>
<pre>0061:    <a href="/share/lib/std/scalar/int.flx#0061">ctor uint: string</a></pre>

<pre>0065:  <a href="/share/lib/std/scalar/int.flx#0065">open class Ulong</a></pre>
<pre>0067:    <a href="/share/lib/std/scalar/int.flx#0067">ctor ulong: string</a></pre>

<pre>0071:  <a href="/share/lib/std/scalar/int.flx#0071">open class Uvlong</a></pre>
<pre>0073:    <a href="/share/lib/std/scalar/int.flx#0073">ctor uvlong: string</a></pre>

<pre>0077:  <a href="/share/lib/std/scalar/int.flx#0077">open class Int8</a></pre>
<pre>0079:    <a href="/share/lib/std/scalar/int.flx#0079">ctor int8: string</a></pre>

<pre>0083:  <a href="/share/lib/std/scalar/int.flx#0083">open class Int16</a></pre>
<pre>0085:    <a href="/share/lib/std/scalar/int.flx#0085">ctor int16: string</a></pre>

<pre>0089:  <a href="/share/lib/std/scalar/int.flx#0089">open class Int32</a></pre>
<pre>0091:    <a href="/share/lib/std/scalar/int.flx#0091">ctor int32: string</a></pre>

<pre>0095:  <a href="/share/lib/std/scalar/int.flx#0095">open class Int64</a></pre>
<pre>0097:    <a href="/share/lib/std/scalar/int.flx#0097">ctor int64: string</a></pre>

<pre>0101:  <a href="/share/lib/std/scalar/int.flx#0101">open class Uint8</a></pre>
<pre>0103:    <a href="/share/lib/std/scalar/int.flx#0103">ctor uint8: string</a></pre>

<pre>0107:  <a href="/share/lib/std/scalar/int.flx#0107">open class Uint16</a></pre>
<pre>0109:    <a href="/share/lib/std/scalar/int.flx#0109">ctor uint16: string</a></pre>

<pre>0113:  <a href="/share/lib/std/scalar/int.flx#0113">open class Uint32</a></pre>
<pre>0115:    <a href="/share/lib/std/scalar/int.flx#0115">ctor uint32: string</a></pre>

<pre>0119:  <a href="/share/lib/std/scalar/int.flx#0119">open class Uint64</a></pre>
<pre>0121:    <a href="/share/lib/std/scalar/int.flx#0121">ctor uint64: string</a></pre>

<pre>0125:  <a href="/share/lib/std/scalar/int.flx#0125">open class Size</a></pre>
<pre>0127:    <a href="/share/lib/std/scalar/int.flx#0127">ctor size: string</a></pre>
<pre>0129:    <a href="/share/lib/std/scalar/int.flx#0129">ctor size: size</a></pre>

<pre>0136:  <a href="/share/lib/std/scalar/int.flx#0136">open class Ptrdiff</a></pre>
<pre>0138:    <a href="/share/lib/std/scalar/int.flx#0138">ctor ptrdiff: string</a></pre>

<pre>0142:  <a href="/share/lib/std/scalar/int.flx#0142">open class Intptr</a></pre>
<pre>0144:    <a href="/share/lib/std/scalar/int.flx#0144">ctor intptr: string</a></pre>

<pre>0148:  <a href="/share/lib/std/scalar/int.flx#0148">open class Uintptr</a></pre>
<pre>0150:    <a href="/share/lib/std/scalar/int.flx#0150">ctor uintptr: string</a></pre>

<pre>0154:  <a href="/share/lib/std/scalar/int.flx#0154">open class Intmax</a></pre>
<pre>0156:    <a href="/share/lib/std/scalar/int.flx#0156">ctor intmax: string</a></pre>

<pre>0160:  <a href="/share/lib/std/scalar/int.flx#0160">open class Uintmax</a></pre>
<pre>0162:    <a href="/share/lib/std/scalar/int.flx#0162">ctor uintmax: string</a></pre>
<pre>0168:    <a href="/share/lib/std/scalar/int.flx#0168">fun str: tiny -> string</a></pre>
<pre>0172:    <a href="/share/lib/std/scalar/int.flx#0172">fun str: utiny -> string</a></pre>
<pre>0183:    <a href="/share/lib/std/scalar/int.flx#0183">fun str: T -> string</a></pre>
<pre>0231:    <a href="/share/lib/std/scalar/int.flx#0231">fun succ: t -> t</a></pre>
<pre>0232:    <a href="/share/lib/std/scalar/int.flx#0232">proc pre_incr: &t</a></pre>
<pre>0233:    <a href="/share/lib/std/scalar/int.flx#0233">proc post_incr: &t</a></pre>
<pre>0237:    <a href="/share/lib/std/scalar/int.flx#0237">fun pred: t -> t</a></pre>
<pre>0238:    <a href="/share/lib/std/scalar/int.flx#0238">proc pre_decr: &t</a></pre>
<pre>0239:    <a href="/share/lib/std/scalar/int.flx#0239">proc post_decr: &t</a></pre>
<pre>0248:    <a href="/share/lib/std/scalar/int.flx#0248">fun sgn: t -> int</a></pre>
<pre>0249:    <a href="/share/lib/std/scalar/int.flx#0249">fun abs: t -> t</a></pre>
<hr/><a href="/share/lib/std/scalar/number.flx">scalar/number.flx</a>
<pre>0003:    <a href="/share/lib/std/scalar/number.flx#0003">fun zero: unit -> t</a></pre>
<pre>0012:    <a href="/share/lib/std/scalar/number.flx#0012">fun one: unit -> t</a></pre>
<hr/><a href="/share/lib/std/scalar/quaternion.flx">scalar/quaternion.flx</a>

<pre>0001:  <a href="/share/lib/std/scalar/quaternion.flx#0001">class Quaternion</a></pre>
<pre>0003:    <a href="/share/lib/std/scalar/quaternion.flx#0003">type quaternion</a></pre>
<pre>0004:    <a href="/share/lib/std/scalar/quaternion.flx#0004">ctor quaternion (x:double^4)</a></pre>
<pre>0006:    <a href="/share/lib/std/scalar/quaternion.flx#0006">fun r(x:q)</a></pre>
<pre>0007:    <a href="/share/lib/std/scalar/quaternion.flx#0007">fun i(x:q)</a></pre>
<pre>0008:    <a href="/share/lib/std/scalar/quaternion.flx#0008">fun j(x:q)</a></pre>
<pre>0009:    <a href="/share/lib/std/scalar/quaternion.flx#0009">fun k(x:q)</a></pre>
<pre>0011:    <a href="/share/lib/std/scalar/quaternion.flx#0011">ctor q (x:double)</a></pre>
<pre>0026:    <a href="/share/lib/std/scalar/quaternion.flx#0026">fun conj (a:q):q</a></pre>
<pre>0027:    <a href="/share/lib/std/scalar/quaternion.flx#0027">fun norm (a:q):double</a></pre>
<pre>0032:    <a href="/share/lib/std/scalar/quaternion.flx#0032">fun reciprocal (a:q):q</a></pre>
<hr/><a href="/share/lib/std/scalar/real.flx">scalar/real.flx</a>
<hr/><a href="/share/lib/std/semaphore.flx">semaphore.flx</a>

<pre>0001:  <a href="/share/lib/std/semaphore.flx#0001">open class Semaphore</a></pre>
<pre>0004:    <a href="/share/lib/std/semaphore.flx#0004">type semaphore</a></pre>
<pre>0005:    <a href="/share/lib/std/semaphore.flx#0005">ctor semaphore</a></pre>
<pre>0006:    <a href="/share/lib/std/semaphore.flx#0006">ctor semaphore * int</a></pre>
<pre>0007:    <a href="/share/lib/std/semaphore.flx#0007">proc destroy : semaphore</a></pre>
<pre>0008:    <a href="/share/lib/std/semaphore.flx#0008">proc post: semaphore</a></pre>
<pre>0009:    <a href="/share/lib/std/semaphore.flx#0009">proc wait: semaphore</a></pre>
<pre>0010:    <a href="/share/lib/std/semaphore.flx#0010">gen trywait: semaphore -> int</a></pre>
<hr/><a href="/share/lib/std/strings/__init__.fdoc">strings/__init__.fdoc</a>
<hr/><a href="/share/lib/std/strings/lexer.flx">strings/lexer.flx</a>

<pre>0001:  <a href="/share/lib/std/strings/lexer.flx#0001">class Lexer</a></pre>
<pre>0003:    <a href="/share/lib/std/strings/lexer.flx#0003">pod type lex_iterator</a></pre>
<pre>0004:    <a href="/share/lib/std/strings/lexer.flx#0004">fun start_iterator : string -> lex_iterator</a></pre>
<pre>0005:    <a href="/share/lib/std/strings/lexer.flx#0005">fun end_iterator: string -> lex_iterator</a></pre>
<pre>0006:    <a href="/share/lib/std/strings/lexer.flx#0006">fun bounds (x:string): lex_iterator * lex_iterator</a></pre>
<pre>0012:    <a href="/share/lib/std/strings/lexer.flx#0012">fun string_between: lex_iterator * lex_iterator -> string</a></pre>
<pre>0018:    <a href="/share/lib/std/strings/lexer.flx#0018">fun deref: lex_iterator -> char</a></pre>
<hr/><a href="/share/lib/std/strings/re2.flx">strings/re2.flx</a>

<pre>0004:  <a href="/share/lib/std/strings/re2.flx#0004">open class Re2</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Binding of Google RE2 regexp library.
</p></div>
<pre>0033:    <a href="/share/lib/std/strings/re2.flx#0033">gen _ctor_RE2 : string -> RE2</a></pre>
<pre>0036:    <a href="/share/lib/std/strings/re2.flx#0036">type StringPiece</a></pre>
<pre>0037:    <a href="/share/lib/std/strings/re2.flx#0037">ctor StringPiece: string</a></pre>
<pre>0038:    <a href="/share/lib/std/strings/re2.flx#0038">ctor StringPiece: unit</a></pre>
<pre>0039:    <a href="/share/lib/std/strings/re2.flx#0039">ctor string: StringPiece</a></pre>
<pre>0040:    <a href="/share/lib/std/strings/re2.flx#0040">fun len: StringPiece -> size</a></pre>
<pre>0041:    <a href="/share/lib/std/strings/re2.flx#0041">fun data: StringPiece -> +char</a></pre>
<pre>0045:    <a href="/share/lib/std/strings/re2.flx#0045">fun len: StringPiece -> size</a></pre>
<pre>0054:    <a href="/share/lib/std/strings/re2.flx#0054">fun str: StringPiece -> string</a></pre>
<pre>0057:    <a href="/share/lib/std/strings/re2.flx#0057">type Arg</a></pre>
<pre>0059:    <a href="/share/lib/std/strings/re2.flx#0059">type Encoding</a></pre>
<pre>0063:    <a href="/share/lib/std/strings/re2.flx#0063">type RE2Options</a></pre>
<pre>0065:    <a href="/share/lib/std/strings/re2.flx#0065">proc Copy: RE2Options * RE2Options</a></pre>
<pre>0067:    <a href="/share/lib/std/strings/re2.flx#0067">fun encoding: RE2Options -> Encoding</a></pre>
<pre>0068:    <a href="/share/lib/std/strings/re2.flx#0068">proc set_encoding: RE2Options * Encoding</a></pre>
<pre>0070:    <a href="/share/lib/std/strings/re2.flx#0070">fun posix_syntax: RE2Options -> bool</a></pre>
<pre>0071:    <a href="/share/lib/std/strings/re2.flx#0071">proc set_posix_syntax: RE2Options * bool</a></pre>
<pre>0073:    <a href="/share/lib/std/strings/re2.flx#0073">fun longest_match: RE2Options -> bool</a></pre>
<pre>0074:    <a href="/share/lib/std/strings/re2.flx#0074">proc set_longest_match: RE2Options * bool</a></pre>
<pre>0076:    <a href="/share/lib/std/strings/re2.flx#0076">fun log_errors: RE2Options -> bool</a></pre>
<pre>0077:    <a href="/share/lib/std/strings/re2.flx#0077">proc set_log_errors: RE2Options * bool</a></pre>
<pre>0079:    <a href="/share/lib/std/strings/re2.flx#0079">fun max_mem: RE2Options -> int</a></pre>
<pre>0080:    <a href="/share/lib/std/strings/re2.flx#0080">proc set_max_mem: RE2Options * int</a></pre>
<pre>0082:    <a href="/share/lib/std/strings/re2.flx#0082">fun literal: RE2Options -> bool</a></pre>
<pre>0083:    <a href="/share/lib/std/strings/re2.flx#0083">proc set_literal: RE2Options * bool</a></pre>
<pre>0085:    <a href="/share/lib/std/strings/re2.flx#0085">fun never_nl: RE2Options -> bool</a></pre>
<pre>0086:    <a href="/share/lib/std/strings/re2.flx#0086">proc set_never_nl: RE2Options * bool</a></pre>
<pre>0088:    <a href="/share/lib/std/strings/re2.flx#0088">fun case_sensitive: RE2Options -> bool</a></pre>
<pre>0089:    <a href="/share/lib/std/strings/re2.flx#0089">proc set_case_sensitive: RE2Options * bool</a></pre>
<pre>0091:    <a href="/share/lib/std/strings/re2.flx#0091">fun perl_classes: RE2Options -> bool</a></pre>
<pre>0092:    <a href="/share/lib/std/strings/re2.flx#0092">proc set_perl_classes: RE2Options * bool</a></pre>
<pre>0094:    <a href="/share/lib/std/strings/re2.flx#0094">fun word_boundary: RE2Options -> bool</a></pre>
<pre>0095:    <a href="/share/lib/std/strings/re2.flx#0095">proc set_word_boundary: RE2Options * bool</a></pre>
<pre>0097:    <a href="/share/lib/std/strings/re2.flx#0097">fun one_line: RE2Options -> bool</a></pre>
<pre>0098:    <a href="/share/lib/std/strings/re2.flx#0098">proc set_one_line: RE2Options * bool</a></pre>
<pre>0100:    <a href="/share/lib/std/strings/re2.flx#0100">fun ParseFlags: RE2Options -> int</a></pre>
<pre>0102:    <a href="/share/lib/std/strings/re2.flx#0102">type ErrorCode</a></pre>
<pre>0119:    <a href="/share/lib/std/strings/re2.flx#0119">type Anchor</a></pre>
<pre>0124:    <a href="/share/lib/std/strings/re2.flx#0124">fun pattern: RE2 -> string</a></pre>
<pre>0125:    <a href="/share/lib/std/strings/re2.flx#0125">fun error: RE2 -> string</a></pre>
<pre>0126:    <a href="/share/lib/std/strings/re2.flx#0126">fun error_code: RE2 -> ErrorCode</a></pre>
<pre>0127:    <a href="/share/lib/std/strings/re2.flx#0127">fun error_arg: RE2 -> string</a></pre>
<pre>0128:    <a href="/share/lib/std/strings/re2.flx#0128">fun ok: RE2 -> bool</a></pre>
<pre>0129:    <a href="/share/lib/std/strings/re2.flx#0129">fun ProgramSize: RE2 -> int</a></pre>
<pre>0131:    <a href="/share/lib/std/strings/re2.flx#0131">gen GlobalReplace: &string * RE2 * StringPiece -> int</a></pre>
<pre>0132:    <a href="/share/lib/std/strings/re2.flx#0132">gen Extract: StringPiece * RE2 * StringPiece * &string -> bool</a></pre>
<pre>0134:    <a href="/share/lib/std/strings/re2.flx#0134">fun QuoteMeta: StringPiece -> string</a></pre>
<pre>0136:    <a href="/share/lib/std/strings/re2.flx#0136">fun PossibleMatchRange: RE2 * &string * &string * int -> bool</a></pre>
<pre>0137:    <a href="/share/lib/std/strings/re2.flx#0137">fun NumberOfCapturingGroups: RE2 -> int</a></pre>
<pre>0138:    <a href="/share/lib/std/strings/re2.flx#0138">fun NamedCapturingGroups: RE2 -> Stl_Map::stl_map[string, int]</a></pre>
<pre>0141:    <a href="/share/lib/std/strings/re2.flx#0141">gen Match: RE2 * StringPiece * int * Anchor * +StringPiece * int -> bool</a></pre>
<pre>0145:    <a href="/share/lib/std/strings/re2.flx#0145">noinline gen Match(re:RE2, var s:string) : opt[varray[string]]</a></pre>
<pre>0158:    <a href="/share/lib/std/strings/re2.flx#0158">gen apply (re:RE2, s:string)</a></pre>
<pre>0160:    <a href="/share/lib/std/strings/re2.flx#0160">fun CheckRewriteString: RE2 * StringPiece * &string -> bool</a></pre>
<pre>0168:    <a href="/share/lib/std/strings/re2.flx#0168">gen iterator (re2:string, var target:string)</a></pre>
<pre>0171:    <a href="/share/lib/std/strings/re2.flx#0171">gen iterator (r:RE2, var target:string) () : opt[varray[string]]</a></pre>
<pre>0196:    <a href="/share/lib/std/strings/re2.flx#0196">fun extract (re2:string, target:string) : opt[varray[string]]</a></pre>
<pre>0197:    <a href="/share/lib/std/strings/re2.flx#0197">fun extract (re2:RE2, target:string) : opt[varray[string]]</a></pre>
<hr/><a href="/share/lib/std/strings/regdef.flx">strings/regdef.flx</a>

<pre>0001:  <a href="/share/lib/std/strings/regdef.flx#0001">class Regdef</a></pre>
<pre>0002:    <a href="/share/lib/std/strings/regdef.flx#0002">union regex</a></pre>
<pre>0045:    <a href="/share/lib/std/strings/regdef.flx#0045">fun ngrp (s:string)</a></pre>
<pre>0048:    <a href="/share/lib/std/strings/regdef.flx#0048">fun render: regex -> string</a></pre>
<hr/><a href="/share/lib/std/strings/string.fdoc">strings/string.fdoc</a>
<pre>0010:    <a href="/share/lib/std/strings/string.fdoc#0010">typedef cstring</a></pre>
<pre>0011:    <a href="/share/lib/std/strings/string.fdoc#0011">type string</a></pre>
<pre>0017:    <a href="/share/lib/std/strings/string.fdoc#0017">typedef strings</a></pre>

<pre>0028:  <a href="/share/lib/std/strings/string.fdoc#0028">open class String</a></pre>
<pre>0050:    <a href="/share/lib/std/strings/string.fdoc#0050">fun len: string -> size</a></pre>
<pre>0073:    <a href="/share/lib/std/strings/string.fdoc#0073">fun apply (x:string, y:string):string</a></pre>
<pre>0074:    <a href="/share/lib/std/strings/string.fdoc#0074">fun apply (x:string, y:int):string</a></pre>
<pre>0079:    <a href="/share/lib/std/strings/string.fdoc#0079">ctor char (x:string)</a></pre>
<pre>0082:    <a href="/share/lib/std/strings/string.fdoc#0082">ctor string (c:char)</a></pre>
<pre>0083:    <a href="/share/lib/std/strings/string.fdoc#0083">ctor string: +char</a></pre>
<pre>0084:    <a href="/share/lib/std/strings/string.fdoc#0084">ctor string: +char  * !ints</a></pre>
<pre>0085:    <a href="/share/lib/std/strings/string.fdoc#0085">fun utf8: int -> string</a></pre>
<pre>0089:    <a href="/share/lib/std/strings/string.fdoc#0089">fun subscript: string * !ints -> char</a></pre>
<pre>0091:    <a href="/share/lib/std/strings/string.fdoc#0091">fun copyfrom: string * !ints -> string</a></pre>
<pre>0093:    <a href="/share/lib/std/strings/string.fdoc#0093">fun copyto: string * !ints -> string</a></pre>
<pre>0095:    <a href="/share/lib/std/strings/string.fdoc#0095">fun substring: string * !ints * !ints -> string</a></pre>
<pre>0098:    <a href="/share/lib/std/strings/string.fdoc#0098">fun subscript (x:string, s:slice[int]):string</a></pre>
<pre>0108:    <a href="/share/lib/std/strings/string.fdoc#0108">proc store: &string * !ints * char</a></pre>
<pre>0112:    <a href="/share/lib/std/strings/string.fdoc#0112">fun map (f:char->char) (var x:string): string</a></pre>
<pre>0128:    <a href="/share/lib/std/strings/string.fdoc#0128">fun stl_find: string * string -> int</a></pre>
<pre>0129:    <a href="/share/lib/std/strings/string.fdoc#0129">fun stl_find: string * string * int -> int</a></pre>
<pre>0130:    <a href="/share/lib/std/strings/string.fdoc#0130">fun stl_find: string * +char -> int</a></pre>
<pre>0131:    <a href="/share/lib/std/strings/string.fdoc#0131">fun stl_find: string * +char * int -> int</a></pre>
<pre>0132:    <a href="/share/lib/std/strings/string.fdoc#0132">fun stl_find: string * char -> int</a></pre>
<pre>0133:    <a href="/share/lib/std/strings/string.fdoc#0133">fun stl_find: string * char * int -> int</a></pre>
<pre>0135:    <a href="/share/lib/std/strings/string.fdoc#0135">fun find (s:string, e:string) : opt[int]</a></pre>
<pre>0136:    <a href="/share/lib/std/strings/string.fdoc#0136">fun find (s:string, e:string, i:int) : opt[int]</a></pre>
<pre>0137:    <a href="/share/lib/std/strings/string.fdoc#0137">fun find (s:string, e:+char) : opt[int]</a></pre>
<pre>0138:    <a href="/share/lib/std/strings/string.fdoc#0138">fun find (s:string, e:+char, i:int) : opt[int]</a></pre>
<pre>0139:    <a href="/share/lib/std/strings/string.fdoc#0139">fun find (s:string, e:char) : opt[int]</a></pre>
<pre>0140:    <a href="/share/lib/std/strings/string.fdoc#0140">fun find (s:string, e:char, i:int) : opt[int]</a></pre>
<pre>0142:    <a href="/share/lib/std/strings/string.fdoc#0142">fun stl_rfind: string * string -> int</a></pre>
<pre>0143:    <a href="/share/lib/std/strings/string.fdoc#0143">fun stl_rfind: string * string * int -> int</a></pre>
<pre>0144:    <a href="/share/lib/std/strings/string.fdoc#0144">fun stl_rfind: string * +char-> int</a></pre>
<pre>0145:    <a href="/share/lib/std/strings/string.fdoc#0145">fun stl_rfind: string * +char * int -> int</a></pre>
<pre>0146:    <a href="/share/lib/std/strings/string.fdoc#0146">fun stl_rfind: string * char -> int</a></pre>
<pre>0147:    <a href="/share/lib/std/strings/string.fdoc#0147">fun stl_rfind: string * char * int -> int</a></pre>
<pre>0149:    <a href="/share/lib/std/strings/string.fdoc#0149">fun rfind (s:string, e:string) : opt[int]</a></pre>
<pre>0150:    <a href="/share/lib/std/strings/string.fdoc#0150">fun rfind (s:string, e:string, i:int) : opt[int]</a></pre>
<pre>0151:    <a href="/share/lib/std/strings/string.fdoc#0151">fun rfind (s:string, e:+char) : opt[int]</a></pre>
<pre>0152:    <a href="/share/lib/std/strings/string.fdoc#0152">fun rfind (s:string, e:+char, i:int) : opt[int]</a></pre>
<pre>0153:    <a href="/share/lib/std/strings/string.fdoc#0153">fun rfind (s:string, e:char) : opt[int]</a></pre>
<pre>0154:    <a href="/share/lib/std/strings/string.fdoc#0154">fun rfind (s:string, e:char, i:int) : opt[int]</a></pre>
<pre>0156:    <a href="/share/lib/std/strings/string.fdoc#0156">fun stl_find_first_of: string * string -> int</a></pre>
<pre>0157:    <a href="/share/lib/std/strings/string.fdoc#0157">fun stl_find_first_of: string * string * int -> int</a></pre>
<pre>0158:    <a href="/share/lib/std/strings/string.fdoc#0158">fun stl_find_first_of: string * +char -> int</a></pre>
<pre>0159:    <a href="/share/lib/std/strings/string.fdoc#0159">fun stl_find_first_of: string * +char * int -> int</a></pre>
<pre>0160:    <a href="/share/lib/std/strings/string.fdoc#0160">fun stl_find_first_of: string * char -> int</a></pre>
<pre>0161:    <a href="/share/lib/std/strings/string.fdoc#0161">fun stl_find_first_of: string * char * int -> int</a></pre>
<pre>0163:    <a href="/share/lib/std/strings/string.fdoc#0163">fun find_first_of (s:string, e:string) : opt[int]</a></pre>
<pre>0164:    <a href="/share/lib/std/strings/string.fdoc#0164">fun find_first_of (s:string, e:string, i:int) : opt[int]</a></pre>
<pre>0165:    <a href="/share/lib/std/strings/string.fdoc#0165">fun find_first_of (s:string, e:+char) : opt[int]</a></pre>
<pre>0166:    <a href="/share/lib/std/strings/string.fdoc#0166">fun find_first_of (s:string, e:+char, i:int) : opt[int]</a></pre>
<pre>0167:    <a href="/share/lib/std/strings/string.fdoc#0167">fun find_first_of (s:string, e:char) : opt[int]</a></pre>
<pre>0168:    <a href="/share/lib/std/strings/string.fdoc#0168">fun find_first_of (s:string, e:char, i:int) : opt[int]</a></pre>
<pre>0170:    <a href="/share/lib/std/strings/string.fdoc#0170">fun stl_find_first_not_of: string * string -> int</a></pre>
<pre>0171:    <a href="/share/lib/std/strings/string.fdoc#0171">fun stl_find_first_not_of: string * string * int -> int</a></pre>
<pre>0172:    <a href="/share/lib/std/strings/string.fdoc#0172">fun stl_find_first_not_of: string * +char -> int</a></pre>
<pre>0173:    <a href="/share/lib/std/strings/string.fdoc#0173">fun stl_find_first_not_of: string * +char * int -> int</a></pre>
<pre>0174:    <a href="/share/lib/std/strings/string.fdoc#0174">fun stl_find_first_not_of: string * char -> int</a></pre>
<pre>0175:    <a href="/share/lib/std/strings/string.fdoc#0175">fun stl_find_first_not_of: string * char * int -> int</a></pre>
<pre>0177:    <a href="/share/lib/std/strings/string.fdoc#0177">fun find_first_not_of (s:string, e:string) : opt[int]</a></pre>
<pre>0178:    <a href="/share/lib/std/strings/string.fdoc#0178">fun find_first_not_of (s:string, e:string, i:int) : opt[int]</a></pre>
<pre>0179:    <a href="/share/lib/std/strings/string.fdoc#0179">fun find_first_not_of (s:string, e:+char) : opt[int]</a></pre>
<pre>0180:    <a href="/share/lib/std/strings/string.fdoc#0180">fun find_first_not_of (s:string, e:+char, i:int) : opt[int]</a></pre>
<pre>0181:    <a href="/share/lib/std/strings/string.fdoc#0181">fun find_first_not_of (s:string, e:char) : opt[int]</a></pre>
<pre>0182:    <a href="/share/lib/std/strings/string.fdoc#0182">fun find_first_not_of (s:string, e:char, i:int) : opt[int]</a></pre>
<pre>0184:    <a href="/share/lib/std/strings/string.fdoc#0184">fun stl_find_last_of: string * string -> int</a></pre>
<pre>0185:    <a href="/share/lib/std/strings/string.fdoc#0185">fun stl_find_last_of: string * string * int -> int</a></pre>
<pre>0186:    <a href="/share/lib/std/strings/string.fdoc#0186">fun stl_find_last_of: string * +char -> int</a></pre>
<pre>0187:    <a href="/share/lib/std/strings/string.fdoc#0187">fun stl_find_last_of: string * +char * int -> int</a></pre>
<pre>0188:    <a href="/share/lib/std/strings/string.fdoc#0188">fun stl_find_last_of: string * char -> int</a></pre>
<pre>0189:    <a href="/share/lib/std/strings/string.fdoc#0189">fun stl_find_last_of: string * char * int -> int</a></pre>
<pre>0191:    <a href="/share/lib/std/strings/string.fdoc#0191">fun find_last_of (s:string, e:string) : opt[int]</a></pre>
<pre>0192:    <a href="/share/lib/std/strings/string.fdoc#0192">fun find_last_of (s:string, e:string, i:int) : opt[int]</a></pre>
<pre>0193:    <a href="/share/lib/std/strings/string.fdoc#0193">fun find_last_of (s:string, e:+char) : opt[int]</a></pre>
<pre>0194:    <a href="/share/lib/std/strings/string.fdoc#0194">fun find_last_of (s:string, e:+char, i:int) : opt[int]</a></pre>
<pre>0195:    <a href="/share/lib/std/strings/string.fdoc#0195">fun find_last_of (s:string, e:char) : opt[int]</a></pre>
<pre>0196:    <a href="/share/lib/std/strings/string.fdoc#0196">fun find_last_of (s:string, e:char, i:int) : opt[int]</a></pre>
<pre>0198:    <a href="/share/lib/std/strings/string.fdoc#0198">fun stl_find_last_not_of: string * string -> int</a></pre>
<pre>0199:    <a href="/share/lib/std/strings/string.fdoc#0199">fun stl_find_last_not_of: string * string * int -> int</a></pre>
<pre>0200:    <a href="/share/lib/std/strings/string.fdoc#0200">fun stl_find_last_not_of: string * +char -> int</a></pre>
<pre>0201:    <a href="/share/lib/std/strings/string.fdoc#0201">fun stl_find_last_not_of: string * +char * int -> int</a></pre>
<pre>0202:    <a href="/share/lib/std/strings/string.fdoc#0202">fun stl_find_last_not_of: string * char -> int</a></pre>
<pre>0203:    <a href="/share/lib/std/strings/string.fdoc#0203">fun stl_find_last_not_of: string * char * int -> int</a></pre>
<pre>0205:    <a href="/share/lib/std/strings/string.fdoc#0205">fun find_last_not_of (s:string, e:string) : opt[int]</a></pre>
<pre>0206:    <a href="/share/lib/std/strings/string.fdoc#0206">fun find_last_not_of (s:string, e:string, i:int) : opt[int]</a></pre>
<pre>0207:    <a href="/share/lib/std/strings/string.fdoc#0207">fun find_last_not_of (s:string, e:+char) : opt[int]</a></pre>
<pre>0208:    <a href="/share/lib/std/strings/string.fdoc#0208">fun find_last_not_of (s:string, e:+char, i:int) : opt[int]</a></pre>
<pre>0209:    <a href="/share/lib/std/strings/string.fdoc#0209">fun find_last_not_of (s:string, e:char) : opt[int]</a></pre>
<pre>0210:    <a href="/share/lib/std/strings/string.fdoc#0210">fun find_last_not_of (s:string, e:char, i:int) : opt[int]</a></pre>
<pre>0222:    <a href="/share/lib/std/strings/string.fdoc#0222">gen iterator(var x:string) ()</a></pre>
<pre>0231:    <a href="/share/lib/std/strings/string.fdoc#0231">fun prefix(arg:string,key:string)</a></pre>
<pre>0235:    <a href="/share/lib/std/strings/string.fdoc#0235">fun suffix (arg:string,key:string)</a></pre>
<pre>0240:    <a href="/share/lib/std/strings/string.fdoc#0240">fun startswith (x:string) (e:string) : bool</a></pre>
<pre>0243:    <a href="/share/lib/std/strings/string.fdoc#0243">fun endswith (x:string) (e:string) : bool</a></pre>
<pre>0245:    <a href="/share/lib/std/strings/string.fdoc#0245">fun startswith (x:string) (e:char) : bool</a></pre>
<pre>0246:    <a href="/share/lib/std/strings/string.fdoc#0246">fun endswith (x:string) (e:char) : bool</a></pre>
<pre>0250:    <a href="/share/lib/std/strings/string.fdoc#0250">fun ltrim (x:string) (e:string) : string</a></pre>
<pre>0258:    <a href="/share/lib/std/strings/string.fdoc#0258">fun rtrim (x:string) (e:string) : string</a></pre>
<pre>0266:    <a href="/share/lib/std/strings/string.fdoc#0266">fun trim (x:string) (e:string) : string</a></pre>
<pre>0270:    <a href="/share/lib/std/strings/string.fdoc#0270">fun lstrip (x:string, e:string) : string</a></pre>
<pre>0289:    <a href="/share/lib/std/strings/string.fdoc#0289">fun rstrip (x:string, e:string) : string</a></pre>
<pre>0308:    <a href="/share/lib/std/strings/string.fdoc#0308">fun strip (x:string, e:string) : string</a></pre>
<pre>0310:    <a href="/share/lib/std/strings/string.fdoc#0310">fun lstrip (x:string) : string</a></pre>
<pre>0311:    <a href="/share/lib/std/strings/string.fdoc#0311">fun rstrip (x:string) : string</a></pre>
<pre>0312:    <a href="/share/lib/std/strings/string.fdoc#0312">fun strip (x:string) : string</a></pre>
<pre>0316:    <a href="/share/lib/std/strings/string.fdoc#0316">fun ljust(x:string, width:int) : string</a></pre>
<pre>0323:    <a href="/share/lib/std/strings/string.fdoc#0323">fun rjust(x:string, width:int) : string</a></pre>
<pre>0332:    <a href="/share/lib/std/strings/string.fdoc#0332">fun split (x:string, d:char): List::list[string]</a></pre>
<pre>0334:    <a href="/share/lib/std/strings/string.fdoc#0334">fun rev_split (x:string, d:char): List::list[string]</a></pre>
<pre>0335:    <a href="/share/lib/std/strings/string.fdoc#0335">fun aux (x:string,y:List::list[string])</a></pre>
<pre>0344:    <a href="/share/lib/std/strings/string.fdoc#0344">fun split (x:string, d:string): List::list[string]</a></pre>
<pre>0346:    <a href="/share/lib/std/strings/string.fdoc#0346">fun rev_split (x:string, d:string): List::list[string]</a></pre>
<pre>0347:    <a href="/share/lib/std/strings/string.fdoc#0347">fun aux (x:string,y:List::list[string])</a></pre>
<pre>0356:    <a href="/share/lib/std/strings/string.fdoc#0356">fun split (x:string, d:+char): List::list[string]</a></pre>
<pre>0358:    <a href="/share/lib/std/strings/string.fdoc#0358">fun rev_split (x:string, d:+char): List::list[string]</a></pre>
<pre>0359:    <a href="/share/lib/std/strings/string.fdoc#0359">fun aux (x:string,y:List::list[string])</a></pre>
<pre>0368:    <a href="/share/lib/std/strings/string.fdoc#0368">fun split_first (x:string, d:string): opt[string*string]</a></pre>

<pre>0380:  <a href="/share/lib/std/strings/string.fdoc#0380">class RespectfulParser</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Split a string on whitespace but respecting
 double quotes, single quotes, and slosh escapes.
</p></div>
<pre>0381:    <a href="/share/lib/std/strings/string.fdoc#0381">union quote_action_t</a></pre>
<pre>0386:    <a href="/share/lib/std/strings/string.fdoc#0386">union dquote_action_t</a></pre>
<pre>0391:    <a href="/share/lib/std/strings/string.fdoc#0391">union escape_action_t</a></pre>
<pre>0396:    <a href="/share/lib/std/strings/string.fdoc#0396">typedef action_t</a></pre>
<pre>0398:    <a href="/share/lib/std/strings/string.fdoc#0398">union mode_t</a></pre>
<pre>0399:    <a href="/share/lib/std/strings/string.fdoc#0399">typedef state_t</a></pre>
<pre>0527:    <a href="/share/lib/std/strings/string.fdoc#0527">fun respectful_split (action:RespectfulParser::action_t) (s:string) : list[string]</a></pre>
<pre>0547:    <a href="/share/lib/std/strings/string.fdoc#0547">fun respectful_split (s:string) : list[string]</a></pre>
<pre>0569:    <a href="/share/lib/std/strings/string.fdoc#0569">proc erase: &string * int * int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> mutators
</p></div>
<pre>0570:    <a href="/share/lib/std/strings/string.fdoc#0570">proc insert: &string * int * string</a></pre>
<pre>0571:    <a href="/share/lib/std/strings/string.fdoc#0571">proc replace: &string * int * int * string</a></pre>
<pre>0574:    <a href="/share/lib/std/strings/string.fdoc#0574">fun erase: string * int * int -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> functional
</p></div>
<pre>0575:    <a href="/share/lib/std/strings/string.fdoc#0575">fun insert: string * int * string -> string</a></pre>
<pre>0576:    <a href="/share/lib/std/strings/string.fdoc#0576">fun replace: string * int * int * string -> string</a></pre>
<pre>0582:    <a href="/share/lib/std/strings/string.fdoc#0582">fun search_and_replace (x:string, var spos:size, s:string, r:string) : string</a></pre>
<pre>0595:    <a href="/share/lib/std/strings/string.fdoc#0595">fun search_and_replace (x:string, s:string, r:string) : string</a></pre>
<pre>0597:    <a href="/share/lib/std/strings/string.fdoc#0597">fun search_and_replace (vs:list[string * string]) (var v:string)</a></pre>
<pre>0608:    <a href="/share/lib/std/strings/string.fdoc#0608">fun subst(s:string, v:varray[StringPiece]): string</a></pre>
<pre>0658:    <a href="/share/lib/std/strings/string.fdoc#0658">fun search_and_replace (x:string, var spos: size, re:Re2::RE2, r:string) : string</a></pre>
<pre>0676:    <a href="/share/lib/std/strings/string.fdoc#0676">fun atoi: string -> int</a></pre>
<pre>0677:    <a href="/share/lib/std/strings/string.fdoc#0677">fun atol: string -> long</a></pre>
<pre>0678:    <a href="/share/lib/std/strings/string.fdoc#0678">fun atoll: string -> long</a></pre>
<pre>0679:    <a href="/share/lib/std/strings/string.fdoc#0679">fun atof: string -> double</a></pre>
<pre>0683:    <a href="/share/lib/std/strings/string.fdoc#0683">proc reserve: &string * !ints</a></pre>
<pre>0688:    <a href="/share/lib/std/strings/string.fdoc#0688">fun _unsafe_cstr: string -> +char</a></pre>
<pre>0691:    <a href="/share/lib/std/strings/string.fdoc#0691">fun stl_begin: &string -> +char</a></pre>
<pre>0692:    <a href="/share/lib/std/strings/string.fdoc#0692">fun stl_end: &string -> +char</a></pre>
<pre>0696:    <a href="/share/lib/std/strings/string.fdoc#0696">fun cstr (x:string) : +char</a></pre>
<pre>0700:    <a href="/share/lib/std/strings/string.fdoc#0700">fun vsprintf[t]: +char  * t -> string</a></pre>
<pre>0704:    <a href="/share/lib/std/strings/string.fdoc#0704">fun vsprintf[t]: string * t -> string</a></pre>
<pre>0711:    <a href="/share/lib/std/strings/string.fdoc#0711">fun toupper(s:string):string</a></pre>
<pre>0713:    <a href="/share/lib/std/strings/string.fdoc#0713">fun tolower(s:string):string</a></pre>
<pre>0721:    <a href="/share/lib/std/strings/string.fdoc#0721">fun str (s:string) : string</a></pre>
<pre>0725:    <a href="/share/lib/std/strings/string.fdoc#0725">fun str: +char -> string</a></pre>
<pre>0729:    <a href="/share/lib/std/strings/string.fdoc#0729">fun repr (x:string) : string</a></pre>
<hr/><a href="/share/lib/std/strings/tre.flx">strings/tre.flx</a>

<pre>0001:  <a href="/share/lib/std/strings/tre.flx#0001">class Tre</a></pre>
<pre>0005:    <a href="/share/lib/std/strings/tre.flx#0005">type tre_regex_t</a></pre>
<pre>0013:    <a href="/share/lib/std/strings/tre.flx#0013">fun tre_regcomp (x:string): opt[tre_regex_t]</a></pre>
<pre>0021:    <a href="/share/lib/std/strings/tre.flx#0021">fun nsub: &tre_regex_t -> int</a></pre>
<pre>0029:    <a href="/share/lib/std/strings/tre.flx#0029">fun add: +char * regoff_t -> +char</a></pre>
<pre>0030:    <a href="/share/lib/std/strings/tre.flx#0030">fun sub: regoff_t * regoff_t -> int</a></pre>
<pre>0031:    <a href="/share/lib/std/strings/tre.flx#0031">ctor int : regoff_t</a></pre>
<pre>0043:    <a href="/share/lib/std/strings/tre.flx#0043">fun tre_regexec (re_in: tre_regex_t) (x:string): int * int * +regmatch_t</a></pre>
<hr/><a href="/share/lib/std/time.flx">time.flx</a>

<pre>0001:  <a href="/share/lib/std/time.flx#0001">class Time_class [os]</a></pre>
<pre>0002:    <a href="/share/lib/std/time.flx#0002">virtual gen time: 1 -> double</a></pre>

<pre>0005:  <a href="/share/lib/std/time.flx#0005">open class Time</a></pre>
<hr/><a href="/share/lib/std/typing.flx">typing.flx</a>

<pre>0001:  <a href="/share/lib/std/typing.flx#0001">open class Typing</a></pre>
<pre>0003:    <a href="/share/lib/std/typing.flx#0003">typedef fun dom(t:TYPE):TYPE</a></pre>
<pre>0004:    <a href="/share/lib/std/typing.flx#0004">typematch t with</a></pre>
<pre>0009:    <a href="/share/lib/std/typing.flx#0009">typedef fun cod(t:TYPE):TYPE</a></pre>
<pre>0010:    <a href="/share/lib/std/typing.flx#0010">typematch t with</a></pre>
<pre>0015:    <a href="/share/lib/std/typing.flx#0015">typedef fun prj1(t:TYPE):TYPE</a></pre>
<pre>0016:    <a href="/share/lib/std/typing.flx#0016">typematch t with</a></pre>
<pre>0021:    <a href="/share/lib/std/typing.flx#0021">typedef fun prj2(t:TYPE):TYPE</a></pre>
<pre>0022:    <a href="/share/lib/std/typing.flx#0022">typematch t with</a></pre>
<pre>0027:    <a href="/share/lib/std/typing.flx#0027">typedef fun type_land(x:TYPE, y:TYPE):TYPE</a></pre>
<pre>0028:    <a href="/share/lib/std/typing.flx#0028">typematch (x,  y) with</a></pre>
<pre>0035:    <a href="/share/lib/std/typing.flx#0035">typedef fun type_lor(x:TYPE, y:TYPE):TYPE</a></pre>
<pre>0036:    <a href="/share/lib/std/typing.flx#0036">typematch (x,  y) with</a></pre>
<pre>0042:    <a href="/share/lib/std/typing.flx#0042">typedef fun eq(x:TYPE, y:TYPE):TYPE</a></pre>
<pre>0043:    <a href="/share/lib/std/typing.flx#0043">typematch x with</a></pre>
<pre>0049:    <a href="/share/lib/std/typing.flx#0049">typedef fun</a></pre>
<pre>0050:    <a href="/share/lib/std/typing.flx#0050">typematch x with</a></pre>
<hr/><a href="/share/lib/std/win32/__init__.flx">win32/__init__.flx</a>
<pre>0001:    <a href="/share/lib/std/win32/__init__.flx#0001">struct Win32</a></pre>
<hr/><a href="/share/lib/std/win32/directory.flx">win32/directory.flx</a>

<pre>0001:  <a href="/share/lib/std/win32/directory.flx#0001">class Win32Directory</a></pre>
<pre>0005:    <a href="/share/lib/std/win32/directory.flx#0005">type DIR_t</a></pre>
<pre>0006:    <a href="/share/lib/std/win32/directory.flx#0006">type FINDDATA_t</a></pre>
<pre>0008:    <a href="/share/lib/std/win32/directory.flx#0008">proc findfirst: string * &FINDDATA_t * &DIR_t</a></pre>
<pre>0009:    <a href="/share/lib/std/win32/directory.flx#0009">proc findnext: DIR_t * &FINDDATA_t * &int</a></pre>
<pre>0010:    <a href="/share/lib/std/win32/directory.flx#0010">proc findclose : DIR_t</a></pre>
<pre>0012:    <a href="/share/lib/std/win32/directory.flx#0012">fun findfailed : DIR_t -> bool</a></pre>
<pre>0013:    <a href="/share/lib/std/win32/directory.flx#0013">fun filename : FINDDATA_t -> string</a></pre>
<pre>0028:    <a href="/share/lib/std/win32/directory.flx#0028">gen mkdir: string * Win32FileStat::mode_t -> int</a></pre>
<pre>0029:    <a href="/share/lib/std/win32/directory.flx#0029">gen mkdir: string  -> int</a></pre>
<pre>0030:    <a href="/share/lib/std/win32/directory.flx#0030">proc mkdirs (s:string)</a></pre>
<pre>0041:    <a href="/share/lib/std/win32/directory.flx#0041">fun getcwd():string</a></pre>
<pre>0055:    <a href="/share/lib/std/win32/directory.flx#0055">fun mk_absolute_filename(s:string)</a></pre>
<pre>0062:    <a href="/share/lib/std/win32/directory.flx#0062">fun filesin(dname:string): opt[list[string]]</a></pre>
<hr/><a href="/share/lib/std/win32/faio_win32.flx">win32/faio_win32.flx</a>
<pre>0013:    <a href="/share/lib/std/win32/faio_win32.flx#0013">type WFILE</a></pre>
<pre>0014:    <a href="/share/lib/std/win32/faio_win32.flx#0014">typedef fd_t</a></pre>
<pre>0019:    <a href="/share/lib/std/win32/faio_win32.flx#0019">type SOCKET</a></pre>
<pre>0020:    <a href="/share/lib/std/win32/faio_win32.flx#0020">typedef socket_t</a></pre>
<pre>0023:    <a href="/share/lib/std/win32/faio_win32.flx#0023">fun str: socket_t -> string</a></pre>
<pre>0029:    <a href="/share/lib/std/win32/faio_win32.flx#0029">fun GetLastError: 1 -> int</a></pre>
<pre>0034:    <a href="/share/lib/std/win32/faio_win32.flx#0034">fun cmk_socket : unit -> SOCKET</a></pre>
<pre>0039:    <a href="/share/lib/std/win32/faio_win32.flx#0039">proc mk_socket(s: &SOCKET)</a></pre>
<pre>0046:    <a href="/share/lib/std/win32/faio_win32.flx#0046">type wasync_accept</a></pre>
<pre>0048:    <a href="/share/lib/std/win32/faio_win32.flx#0048">fun mk_accept: demuxer *  SOCKET*SOCKET -> wasync_accept</a></pre>
<pre>0050:    <a href="/share/lib/std/win32/faio_win32.flx#0050">fun get_success[t]: t -> bool</a></pre>
<pre>0055:    <a href="/share/lib/std/win32/faio_win32.flx#0055">fun eq : SOCKET*SOCKET -> bool</a></pre>
<pre>0058:    <a href="/share/lib/std/win32/faio_win32.flx#0058">proc Accept(success: &bool, listener: SOCKET, accepted: SOCKET)</a></pre>
<pre>0065:    <a href="/share/lib/std/win32/faio_win32.flx#0065">type connect_ex</a></pre>
<pre>0066:    <a href="/share/lib/std/win32/faio_win32.flx#0066">fun mk_connect_ex: demuxer * SOCKET*+char*int -> connect_ex</a></pre>
<pre>0070:    <a href="/share/lib/std/win32/faio_win32.flx#0070">proc Connect(s: SOCKET, addr: +char, port: int, err: &int)</a></pre>
<pre>0078:    <a href="/share/lib/std/win32/faio_win32.flx#0078">proc Connect(s: &SOCKET, addr: +char, port: int, err: &int)</a></pre>
<pre>0085:    <a href="/share/lib/std/win32/faio_win32.flx#0085">proc cmk_listener: &SOCKET*&int*int</a></pre>
<pre>0088:    <a href="/share/lib/std/win32/faio_win32.flx#0088">proc mk_listener(listener: &SOCKET, port: &int, backlog: int)</a></pre>
<pre>0095:    <a href="/share/lib/std/win32/faio_win32.flx#0095">proc closesocket: SOCKET</a></pre>
<pre>0101:    <a href="/share/lib/std/win32/faio_win32.flx#0101">proc shutdown: SOCKET*int</a></pre>
<pre>0103:    <a href="/share/lib/std/win32/faio_win32.flx#0103">type wasync_transmit_file</a></pre>
<pre>0111:    <a href="/share/lib/std/win32/faio_win32.flx#0111">gen OpenFile: string -> WFILE</a></pre>
<pre>0116:    <a href="/share/lib/std/win32/faio_win32.flx#0116">gen OpenFileDuplex: string -> WFILE</a></pre>
<pre>0121:    <a href="/share/lib/std/win32/faio_win32.flx#0121">proc CloseFile: WFILE</a></pre>
<pre>0127:    <a href="/share/lib/std/win32/faio_win32.flx#0127">fun mk_transmit_file : demuxer * SOCKET*WFILE -> wasync_transmit_file</a></pre>
<pre>0131:    <a href="/share/lib/std/win32/faio_win32.flx#0131">proc TransmitFile(s: SOCKET, f: WFILE)</a></pre>
<pre>0142:    <a href="/share/lib/std/win32/faio_win32.flx#0142">fun mk_reuse_socket : demuxer * SOCKET -> wasync_transmit_file</a></pre>
<pre>0145:    <a href="/share/lib/std/win32/faio_win32.flx#0145">proc ReuseSocket(s: SOCKET)</a></pre>
<pre>0151:    <a href="/share/lib/std/win32/faio_win32.flx#0151">type wsa_socketio</a></pre>
<pre>0152:    <a href="/share/lib/std/win32/faio_win32.flx#0152">gen mk_wsa_socketio: demuxer * SOCKET*sel_param_ptr*bool->wsa_socketio</a></pre>
<pre>0157:    <a href="/share/lib/std/win32/faio_win32.flx#0157">proc WSARecv(s: SOCKET, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0169:    <a href="/share/lib/std/win32/faio_win32.flx#0169">proc WSASend(s: SOCKET, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0180:    <a href="/share/lib/std/win32/faio_win32.flx#0180">type winfile_io</a></pre>
<pre>0182:    <a href="/share/lib/std/win32/faio_win32.flx#0182">fun mk_winfile_io: demuxer * WFILE*address*int*bool->winfile_io</a></pre>
<pre>0185:    <a href="/share/lib/std/win32/faio_win32.flx#0185">fun get_pb: winfile_io -> sel_param_ptr</a></pre>
<pre>0187:    <a href="/share/lib/std/win32/faio_win32.flx#0187">proc ReadFile(f: WFILE, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0195:    <a href="/share/lib/std/win32/faio_win32.flx#0195">proc WriteFile(f: WFILE, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0205:    <a href="/share/lib/std/win32/faio_win32.flx#0205">type iocp_associator</a></pre>
<pre>0206:    <a href="/share/lib/std/win32/faio_win32.flx#0206">fun mk_iocp_associator: demuxer * SOCKET -> iocp_associator</a></pre>
<pre>0211:    <a href="/share/lib/std/win32/faio_win32.flx#0211">proc associate_with_iocp(s: SOCKET)</a></pre>
<hr/><a href="/share/lib/std/win32/filestat.flx">win32/filestat.flx</a>

<pre>0001:  <a href="/share/lib/std/win32/filestat.flx#0001">class Win32FileStat</a></pre>
<pre>0013:    <a href="/share/lib/std/win32/filestat.flx#0013">pod type mode_t</a></pre>
<pre>0014:    <a href="/share/lib/std/win32/filestat.flx#0014">pod type stat_t</a></pre>
<pre>0032:    <a href="/share/lib/std/win32/filestat.flx#0032">fun raw_mode: &stat_t -> mode_t</a></pre>
<pre>0033:    <a href="/share/lib/std/win32/filestat.flx#0033">fun file_type(m:mode_t)</a></pre>
<pre>0034:    <a href="/share/lib/std/win32/filestat.flx#0034">fun file_perm(m:mode_t)</a></pre>
<pre>0036:    <a href="/share/lib/std/win32/filestat.flx#0036">ctor uint: mode_t</a></pre>
<pre>0043:    <a href="/share/lib/std/win32/filestat.flx#0043">proc stat: string * &stat_t * &int</a></pre>
<pre>0045:    <a href="/share/lib/std/win32/filestat.flx#0045">proc utime: string * double * double * &int</a></pre>
<pre>0057:    <a href="/share/lib/std/win32/filestat.flx#0057">gen chmod: string * mode_t -> int</a></pre>
<pre>0058:    <a href="/share/lib/std/win32/filestat.flx#0058">gen umask: mode_t -> mode_t</a></pre>
<pre>0060:    <a href="/share/lib/std/win32/filestat.flx#0060">fun file_type (s:&stat_t): file_type_t</a></pre>
<hr/><a href="/share/lib/std/win32/filesystem.flx">win32/filesystem.flx</a>

<pre>0001:  <a href="/share/lib/std/win32/filesystem.flx#0001">class Win32FileSystem</a></pre>
<pre>0006:    <a href="/share/lib/std/win32/filesystem.flx#0006">pod type file_perm_t</a></pre>
<pre>0026:    <a href="/share/lib/std/win32/filesystem.flx#0026">pod type posix_file</a></pre>
<pre>0027:    <a href="/share/lib/std/win32/filesystem.flx#0027">fun valid: posix_file -> bool</a></pre>
<pre>0028:    <a href="/share/lib/std/win32/filesystem.flx#0028">ctor int : posix_file</a></pre>
<pre>0033:    <a href="/share/lib/std/win32/filesystem.flx#0033">gen open: string * file_perm_t * Win32FileStat::mode_t -> posix_file</a></pre>
<pre>0034:    <a href="/share/lib/std/win32/filesystem.flx#0034">gen open: string * file_perm_t -> posix_file</a></pre>
<pre>0036:    <a href="/share/lib/std/win32/filesystem.flx#0036">gen ropen: string -> posix_file</a></pre>
<pre>0037:    <a href="/share/lib/std/win32/filesystem.flx#0037">gen wopen: string -> posix_file</a></pre>
<pre>0038:    <a href="/share/lib/std/win32/filesystem.flx#0038">gen rwopen: string -> posix_file</a></pre>
<pre>0039:    <a href="/share/lib/std/win32/filesystem.flx#0039">gen creat: string * Win32FileStat::mode_t-> posix_file</a></pre>
<pre>0041:    <a href="/share/lib/std/win32/filesystem.flx#0041">gen close: posix_file -> int</a></pre>
<pre>0042:    <a href="/share/lib/std/win32/filesystem.flx#0042">gen read: posix_file * &char * size -> size</a></pre>
<pre>0043:    <a href="/share/lib/std/win32/filesystem.flx#0043">gen write: posix_file * &char * size -> size</a></pre>
<pre>0045:    <a href="/share/lib/std/win32/filesystem.flx#0045">gen dup: posix_file -> posix_file</a></pre>
<pre>0046:    <a href="/share/lib/std/win32/filesystem.flx#0046">gen dup2: posix_file * posix_file -> posix_file</a></pre>
<pre>0048:    <a href="/share/lib/std/win32/filesystem.flx#0048">struct _piper_hack</a></pre>
<pre>0060:    <a href="/share/lib/std/win32/filesystem.flx#0060">gen pipe ()</a></pre>
<pre>0062:    <a href="/share/lib/std/win32/filesystem.flx#0062">gen fdopen_input: posix_file ->  ifile</a></pre>
<pre>0063:    <a href="/share/lib/std/win32/filesystem.flx#0063">gen fdopen_output: posix_file ->  ofile</a></pre>
<pre>0068:    <a href="/share/lib/std/win32/filesystem.flx#0068">gen unlink_file: string -> int</a></pre>
<pre>0073:    <a href="/share/lib/std/win32/filesystem.flx#0073">gen rename_file: string * string -> int</a></pre>
<pre>0079:    <a href="/share/lib/std/win32/filesystem.flx#0079">gen filecopy(src: string, dst: string) :  bool</a></pre>
<pre>0147:    <a href="/share/lib/std/win32/filesystem.flx#0147">gen tmp_filename: 1 -> string</a></pre>
<hr/><a href="/share/lib/std/win32/process.flx">win32/process.flx</a>

<pre>0001:  <a href="/share/lib/std/win32/process.flx#0001">class Win32Process</a></pre>
<pre>0006:    <a href="/share/lib/std/win32/process.flx#0006">gen popen_in: string -> Cstdio::ifile</a></pre>
<pre>0007:    <a href="/share/lib/std/win32/process.flx#0007">gen pclose: Cstdio::ifile -> process_status_t</a></pre>
<pre>0010:    <a href="/share/lib/std/win32/process.flx#0010">type process_status_t</a></pre>
<pre>0011:    <a href="/share/lib/std/win32/process.flx#0011">ctor intptr:process_status_t</a></pre>
<pre>0012:    <a href="/share/lib/std/win32/process.flx#0012">ctor int:process_status_t</a></pre>
<pre>0013:    <a href="/share/lib/std/win32/process.flx#0013">ctor process_status_t : intptr</a></pre>
<pre>0014:    <a href="/share/lib/std/win32/process.flx#0014">fun int_of_process_status_t: process_status_t -> int</a></pre>
<pre>0018:    <a href="/share/lib/std/win32/process.flx#0018">fun WIFCONTINUED: process_status_t -> bool</a></pre>
<pre>0019:    <a href="/share/lib/std/win32/process.flx#0019">fun WIFEXITED: process_status_t -> bool</a></pre>
<pre>0020:    <a href="/share/lib/std/win32/process.flx#0020">fun WIFSIGNALED: process_status_t -> bool</a></pre>
<pre>0021:    <a href="/share/lib/std/win32/process.flx#0021">fun WIFSTOPPED: process_status_t -> bool</a></pre>
<pre>0023:    <a href="/share/lib/std/win32/process.flx#0023">fun WEXITSTATUS: process_status_t -> int</a></pre>
<pre>0024:    <a href="/share/lib/std/win32/process.flx#0024">fun WTERMSIG: process_status_t -> signal_t</a></pre>
<pre>0025:    <a href="/share/lib/std/win32/process.flx#0025">fun WSTOPSIG: process_status_t -> signal_t</a></pre>
<pre>0028:    <a href="/share/lib/std/win32/process.flx#0028">fun  WCOREDUMP: process_status_t -> int</a></pre>
<pre>0031:    <a href="/share/lib/std/win32/process.flx#0031">fun str(x:process_status_t)</a></pre>
<pre>0045:    <a href="/share/lib/std/win32/process.flx#0045">type exec_result_t</a></pre>
<pre>0049:    <a href="/share/lib/std/win32/process.flx#0049">gen execv:+char *  + +char -> exec_result_t</a></pre>
<pre>0050:    <a href="/share/lib/std/win32/process.flx#0050">gen execvp:+char *  + +char -> exec_result_t</a></pre>
<pre>0051:    <a href="/share/lib/std/win32/process.flx#0051">gen execve:+char *  + +char * + +char -> exec_result_t</a></pre>
<pre>0056:    <a href="/share/lib/std/win32/process.flx#0056">type pid_t</a></pre>
<pre>0057:    <a href="/share/lib/std/win32/process.flx#0057">ctor intptr: pid_t</a></pre>
<pre>0062:    <a href="/share/lib/std/win32/process.flx#0062">fun str: pid_t -> string</a></pre>
<pre>0065:    <a href="/share/lib/std/win32/process.flx#0065">union spawn_result_t</a></pre>
<pre>0075:    <a href="/share/lib/std/win32/process.flx#0075">gen spawnv:+char *  + +char -> pid_t</a></pre>
<pre>0076:    <a href="/share/lib/std/win32/process.flx#0076">gen spawnvp:+char *  + +char -> pid_t</a></pre>
<pre>0077:    <a href="/share/lib/std/win32/process.flx#0077">gen spawnve:+char *  + +char * + +char -> pid_t</a></pre>
<pre>0079:    <a href="/share/lib/std/win32/process.flx#0079">gen spawnv(file: string, argv:+ +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0088:    <a href="/share/lib/std/win32/process.flx#0088">gen spawnvp(file: string, argv:+ +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0097:    <a href="/share/lib/std/win32/process.flx#0097">gen spawnve(file: string, argv:+ +char, env: + +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0106:    <a href="/share/lib/std/win32/process.flx#0106">type process_status_options_t</a></pre>
<pre>0114:    <a href="/share/lib/std/win32/process.flx#0114">gen waitpid: pid_t * &process_status_t * process_status_options_t -> pid_t requires Posix_headers::sys_wait_h</a></pre>
<pre>0116:    <a href="/share/lib/std/win32/process.flx#0116">gen waitpid(pid:pid_t)</a></pre>
<pre>0127:    <a href="/share/lib/std/win32/process.flx#0127">union ProcesStatus</a></pre>
<pre>0129:    <a href="/share/lib/std/win32/process.flx#0129">gen checkpid(pid:pid_t)</a></pre>
<pre>0142:    <a href="/share/lib/std/win32/process.flx#0142">gen kill: pid_t * signal_t -> int</a></pre>
<hr/><a href="/share/lib/std/win32/shell.flx">win32/shell.flx</a>

<pre>0036:  <a href="/share/lib/std/win32/shell.flx#0036">class CmdExe</a></pre>
<pre>0040:    <a href="/share/lib/std/win32/shell.flx#0040">fun quote_arg(s:string):string</a></pre>
<pre>0041:    <a href="/share/lib/std/win32/shell.flx#0041">fun quote_line_for_system(s:string)</a></pre>
<pre>0042:    <a href="/share/lib/std/win32/shell.flx#0042">fun quote_line_for_popen(s:string)</a></pre>
<pre>0044:    <a href="/share/lib/std/win32/shell.flx#0044">gen get_stdout(x:string)</a></pre>
<pre>0057:    <a href="/share/lib/std/win32/shell.flx#0057">fun parse (s:string) : list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Parse a CMD.EXE command line into words.
</p></div>
<pre>0061:    <a href="/share/lib/std/win32/shell.flx#0061">union mode_t</a></pre>
<hr/><a href="/share/lib/std/win32/signal.flx">win32/signal.flx</a>

<pre>0001:  <a href="/share/lib/std/win32/signal.flx#0001">class Win32Signal</a></pre>
<pre>0003:    <a href="/share/lib/std/win32/signal.flx#0003">type signal_t</a></pre>
<pre>0004:    <a href="/share/lib/std/win32/signal.flx#0004">ctor signal_t: int</a></pre>
<pre>0005:    <a href="/share/lib/std/win32/signal.flx#0005">ctor int: signal_t</a></pre>
<pre>0008:    <a href="/share/lib/std/win32/signal.flx#0008">type sig_t</a></pre>
<pre>0009:    <a href="/share/lib/std/win32/signal.flx#0009">gen signal: signal_t * sig_t -> sig_t</a></pre>
<pre>0022:    <a href="/share/lib/std/win32/signal.flx#0022">fun str: signal_t -> string</a></pre>
<pre>0036:    <a href="/share/lib/std/win32/signal.flx#0036">proc ignore_signal(s:signal_t)</a></pre>
<pre>0049:    <a href="/share/lib/std/win32/signal.flx#0049">proc trap_ctrl_c: unit requires ctrl_c_handling</a></pre>
<hr/><a href="/share/lib/std/win32/time.flx">win32/time.flx</a>

<pre>0001:  <a href="/share/lib/std/win32/time.flx#0001">class Win32Time</a></pre>
<pre>0019:    <a href="/share/lib/std/win32/time.flx#0019">gen time () : double</a></pre>
<hr/><a href="/share/lib/std/win32/win32_headers.flx">win32/win32_headers.flx</a>

<pre>0001:  <a href="/share/lib/std/win32/win32_headers.flx#0001">class Win32_headers</a></pre>
</body></html>
