#line 8 "C:/projects/felix/src/packages/chips.fdoc"
class BaseChips
{

chip writeblock[T]
  connector io
    pin inp : %<T
{
}

#line 20 "C:/projects/felix/src/packages/chips.fdoc"
chip readblock[T]
  connector io
    pin inp: %>T
{
}


#line 30 "C:/projects/felix/src/packages/chips.fdoc"
chip sink[T]
  connector io
    pin inp : %<T
{
  while true do
    var x = read (io.inp);
    C_hack::ignore (x);
  done
}

#line 43 "C:/projects/felix/src/packages/chips.fdoc"
chip source[T] (a:T)
  connector io
    pin out: %>T
{
  while true do
    write (io.out, a);
  done
}

#line 54 "C:/projects/felix/src/packages/chips.fdoc"
chip source_from_list[T] (a:list[T])
  connector io
    pin out: %>T
{
  for y in a perform write (io.out,y);
}

#line 64 "C:/projects/felix/src/packages/chips.fdoc"
chip function[D,C] (f:D->C)
  connector io
    pin inp: %<D
    pin out: %>C
{
  while true do
    var x = read io.inp;
    var y = f x;
    write (io.out, y);
  done
}

#line 79 "C:/projects/felix/src/packages/chips.fdoc"
chip procedure[D] (p:D->0)
  connector io
    pin inp: %<D
{
  while true do
    var x = read io.inp;
    p x;
  done
}

#line 91 "C:/projects/felix/src/packages/chips.fdoc"
chip sink_to_list[T] (p: &list[T])
  connector io
    pin inp : %<T
{
  while true do
    var x = read (io.inp);
    p <- Cons (x,*p);
  done
}


#line 105 "C:/projects/felix/src/packages/chips.fdoc"
chip buffer [T]
  connector io
    pin inp: %<T
    pin out: %>T
{
  while true do
    var x = read io.inp;
    write (io.out, x);
  done
}

#line 122 "C:/projects/felix/src/packages/chips.fdoc"
// two transducers
chip pipe[T,U,V] (a:iochip_t[T,U],b:iochip_t[U,V])
 connector io
   pin inp: %<T
   pin out: %>V
{
  circuit
    connect a.out,b.inp
    wire io.inp to a.inp
    wire io.out to b.out
  endcircuit
}

// source to transducer
chip pipe[T,U] (a:ochip_t[T],b:iochip_t[T,U])
 connector io
   pin out: %>U
{
  circuit
    connect a.out,b.inp
    wire io.out to b.out
  endcircuit
}

// transducer to sink
chip pipe[T,U] (a:iochip_t[T,U],b:ichip_t[U])
 connector io
   pin inp: %<T
{
  circuit
    connect a.out,b.inp
    wire io.inp to a.inp
  endcircuit
}

// source to sink
proc pipe[T] (a:ochip_t[T],b:ichip_t[T]) ()
{
  circuit
    connect a.out,b.inp
  endcircuit
}


#line 169 "C:/projects/felix/src/packages/chips.fdoc"
chip debug_buffer [T with Str[T]] (tag:string)
  connector io
    pin inp: %<T
    pin out: %>T
{
  while true do
    println$ "Debug buffer [" + tag + "] READ";
    var x = read io.inp;
    println$ "Debug buffer [" + tag + "] read " + x.str;
    write (io.out, x);
    println$ "Debug buffer [" + tag + "] written " + x.str;
  done
}

#line 186 "C:/projects/felix/src/packages/chips.fdoc"
chip oneshot [T]
  connector io
    pin inp: %<T
    pin out: %>T
{
  var x = read io.inp;
  write (io.out, x);
}

#line 198 "C:/projects/felix/src/packages/chips.fdoc"
chip store[T] (p:&T)
  connector io
    pin inp: %<T
{
  while true do
    var x = read io.inp;
    p <- x;
  done
}

#line 211 "C:/projects/felix/src/packages/chips.fdoc"
chip fetch[T] (p:&T)
  connector io
    pin out: %>T
{
  while true do
    write (io.out, *p);
  done
}

#line 224 "C:/projects/felix/src/packages/chips.fdoc"
chip debug_sink [T with Str[T]] (s:string)
  connector io
    pin inp: %<T
{
  while true do
    var x = read io.inp;
    println$ "Debug sink ["+s+"] "+x.str;
  done
}


#line 240 "C:/projects/felix/src/packages/chips.fdoc"
chip latch[T]
  connector io
    pin inp: %<T
    pin out: %>T
{
   var x = read io.inp;
   device w = fetch &x;
   device r = store &x;
   circuit
     wire io.inp to r.inp
     wire io.out to w.out
   endcircuit
}

#line 261 "C:/projects/felix/src/packages/chips.fdoc"
chip serialise_chan_list[T] (a: list[%<T])
 connector io
   pin out: %>T
{
  while true do
    var current = a;
next:>
    match current with
    | Cons (h,t) =>
      var x = read h;
      write (io.out, x);
      current = t;
      goto next;
    | Empty => ;
    endmatch;
  done
}

typedef iopair_t[D,C] = (inp: %<D, out: %>C);

// transducer
typedef iochip_t[D,C] = iopair_t[D,C] -> 1 -> 0;

// sink
typedef ichip_t[T] = (inp: %<T) -> 1 -> 0;

// source
typedef ochip_t[T] = (out: %>T) -> 1 -> 0;

// NOTE: this is currently a one-shot!
// .. Well sort of!
// It can do multiple reads if its first chip
// cycles. If the pipeline drops dead, it will
// not be reuable.
//
// To be reusable, components should not return,
// instead loop back to reading without writing.

chip pipeline_list[T] (a: list[iochip_t[T,T]])
  connector io
    pin inp: %<T
    pin out: %>T
{
  proc aux (lst:list[iochip_t[T,T]]) (inp: %<T) {
    match lst with
    | h1 ! h2 ! tail =>
      var inchan,outchan = mk_ioschannel_pair[T]();
      spawn_fthread$  h1 (inp=inp, out=outchan);
      aux (h2!tail) inchan;
    | h1 ! _ =>
      spawn_fthread$  h1 (inp=inp, out=io.out);
    endmatch;
  }
  aux a io.inp;
}

// This loops, but only by repeatedly spawning
// the alternative set. The alternatives are restricted
// to a single read on each iteration. The chips are
// respawned because they might be locked up, in which
// case the whole thing locks up.
//
// NOTE: if one of the alternatives starts, and does not
// read the input, everything locks up. This is because
// the implementation ACTUALLY progresses serially.
//
// this COULD be fixed by adding a buffer to the front of
// each. Actually better, add a one shot source based
// on the input.
chip tryall_list[D,C with Str[D]] (a: list[iochip_t[D,C]])
  connector io
    pin inp: %<D
    pin out: %>C
{
  while true do
    var x = read io.inp;
println$ "Tryall read " + a.len.str + " alternatives: " + x.str;
var counter = 1;
    for h in a do
println$ "    Trying alternative #" + counter.str + "/"+a.len.str;
++counter;
      var lin,lout = mk_ioschannel_pair[D]();
      spawn_fthread (h (inp=lin, out=io.out));
      write (lout,x);
    done
println$ "Tryall read done";
  done
}

#line 354 "C:/projects/felix/src/packages/chips.fdoc"
chip deref_each_read[D,C] (p:&iochip_t[D,C])
  connector io
    pin inp: %<D
    pin out: %>C
{
  while true do
    var x = read io.inp;
    var rinp,rout = mk_ioschannel_pair[D]();
    spawn_fthread ((*p) (inp=rinp, out=io.out));
    write (rout,x);
  done
}

chip deref_first_read[D,C] (p:&iochip_t[D,C])
  connector io
    pin inp: %<D
    pin out: %>C
{
  var x = read io.inp;
  var rinp,rout = mk_ioschannel_pair[D]();
  spawn_fthread ((*p) (inp=rinp, out=io.out));
  write (rout,x);
  while true do
    x = read io.inp;
    write (rout,x);
  done
}
#line 385 "C:/projects/felix/src/packages/chips.fdoc"
chip epsilon[T]
  connector io
   pin inp: %<T
   pin out: %>T
{
  while true do
    var x = read io.inp;
    write (io.out, x);
  done
}
#line 400 "C:/projects/felix/src/packages/chips.fdoc"
chip optional[T] (p:iochip_t[T,T])
  connector io
    pin inp: %<T
    pin out: %>T
{
  device both = tryall_list ([
    p,
    epsilon[T]
  ]);
  circuit
    wire io.inp to both.inp
    wire io.out to both.out
  endcircuit
}

#line 417 "C:/projects/felix/src/packages/chips.fdoc"

chip oneormore_matcher[T] (A:iochip_t[T,T])
connector chans
  pin inp: %<T
  pin out: %>T
{
 device As = oneormore_matcher A;
 device As2 = pipeline_list (A,As).list;
 device Ass = tryall_list (A, As2).list;
 circuit
   wire chans.inp to Ass.inp
   wire chans.out to Ass.out
 endcircuit
}

#line 434 "C:/projects/felix/src/packages/chips.fdoc"

chip zeroormore_matcher[T] (A:iochip_t[T,T])
connector chans
  pin inp: %<T
  pin out: %>T
{
 device As = oneormore_matcher A;
 device Ass = tryall_list (epsilon[T], As).list;
 circuit
   wire chans.inp to Ass.inp
   wire chans.out to Ass.out
 endcircuit
}
#line 450 "C:/projects/felix/src/packages/chips.fdoc"
} // end class BaseChips

