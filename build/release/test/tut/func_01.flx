println$ "Square of " + str 1 + " is " + str (1 * 1);
println$ "Square of " + str 2 + " is " + str (2 * 2);
println$ "Sguare of " + str 3 + " is " + str (3 * 1);
fun square(x:int)=>x * x;  // define a function
println$ "Square of " + str 1 + " is " + str (square 1);
println$ "Square of " + str 2 + " is " + str 2.square;
println$ "Sguare of " + str 3 + " is " + (str$ square 3);
fun long-winded-square(x:int):int = {
  val s = x * x;
  return x;
}
proc ps(x:int) {
  println$ "Square of " + str x + " is " + str x.square;
}
ps 1; ps 2; ps 3;
fun addup (x:int, y:int) => x + y;
println$ addup (1,2); // 3
val pair = 1,2;
println$ addup pair; // 3
var x =0;
gen incx():int = { val tmp = x; ++x; return tmp; }
println$ incx(), incx();
gen g1 (y:int) = { ++x; return y + x; } 
gen g2 (y:int) = { ++x; return y + 2 * x; } 
x = 0;
var r1 = (g1 1).g2;
println$ r1;
x = 0;
var a1 = g1 1;  // 2 (x=1) 
var r2 = g2 a1; // 6 (x=2)
println$ r2;
cfun f(x:int) => x;
cproc p(x:int) { println x; }
fun f(x:int) = {
  fun g(y:long)=> x.long + y;
   return g;
}
fun f(x:int) (y:long) => x.long + y;
proc h(x:int) (y:long) { println$ x.long + y; }
fun f2(x:int) (y:long) => x.long + y;
val g = f2 1;
println$ g 2l;
val three = (fun (x:int)=> x + 1) 2;
val hello1 = { println "Hello"; };
val hello2 = proc () { println "Hello"; };
val y = 1;
val add1 = { val x = y + 1; return x; };
